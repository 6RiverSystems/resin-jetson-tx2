From e58f36a80e30d55a93439641daedab0792a28e94 Mon Sep 17 00:00:00 2001
From: Alexandru Costache <alexandru@balena.io>
Date: Mon, 24 Feb 2020 14:33:46 +0100
Subject: [PATCH 3/5] d3: Backport D3 drivers

Upstream-Status: Backport
Signed-off-by: Alexandru Costache <alexandru@balena.io>
---
 drivers/d3/Kconfig                            |   13 +
 drivers/d3/Makefile                           |   28 +
 drivers/d3/ar0820/Kconfig                     |    5 +
 drivers/d3/ar0820/Makefile                    |    2 +
 drivers/d3/ar0820/ar0820.c                    |  692 +++
 drivers/d3/ar0820/ar0820_tables.h             |  360 ++
 drivers/d3/build-id/Kconfig                   |    5 +
 drivers/d3/build-id/Makefile                  |    3 +
 drivers/d3/build-id/build-id.c                |   66 +
 drivers/d3/config-eeprom/Kconfig              |    5 +
 drivers/d3/config-eeprom/Makefile             |    3 +
 drivers/d3/config-eeprom/config-eeprom.c      |  215 +
 drivers/d3/early-at24/Kconfig                 |    6 +
 drivers/d3/early-at24/Makefile                |   18 +
 drivers/d3/early-at24/modify-at24.sed         |   44 +
 drivers/d3/imx390/Kconfig                     |    9 +
 drivers/d3/imx390/Makefile                    |   14 +
 drivers/d3/imx390/imx390-main.c               | 1204 +++++
 drivers/d3/imx390/imx390-mode-1936x1100-HDR.c | 4492 +++++++++++++++++
 drivers/d3/imx390/imx390-mode-1936x1100-HDR.h |   28 +
 .../d3/imx390/imx390-mode-1936x1100-SP1H.c    | 3104 ++++++++++++
 .../d3/imx390/imx390-mode-1936x1100-SP1H.h    |   30 +
 .../d3/imx390/imx390-mode-1936x1100-SP1L.c    | 3105 ++++++++++++
 .../d3/imx390/imx390-mode-1936x1100-SP1L.h    |   28 +
 drivers/d3/imx390/imx390-mode-1936x1100-SP2.c | 3104 ++++++++++++
 drivers/d3/imx390/imx390-mode-1936x1100-SP2.h |   28 +
 drivers/d3/imx390/imx390-modes.c              |  104 +
 drivers/d3/imx390/imx390-modes.h              |   55 +
 drivers/d3/max9296/Kconfig                    |   43 +
 drivers/d3/max9296/Makefile                   |    6 +
 drivers/d3/max9296/max9286.c                  |  474 ++
 drivers/d3/max9296/max9286.h                  |   44 +
 drivers/d3/max9296/max9286_tables.h           |   50 +
 drivers/d3/max9296/max9295.c                  |  481 ++
 drivers/d3/max9296/max9295.h                  |   77 +
 drivers/d3/max9296/max9295_tables.h           |  102 +
 drivers/d3/max9296/max9296.c                  |  817 +++
 drivers/d3/max9296/max9296.h                  |   79 +
 drivers/d3/max9296/max9296_tables.h           |  201 +
 drivers/d3/max9296/max96705.c                 |  278 +
 drivers/d3/max9296/max96705.h                 |   39 +
 drivers/d3/max9296/max96705_tables.h          |  148 +
 drivers/d3/max9296/serdes.c                   |  446 ++
 drivers/d3/max9296/serdes.h                   |  124 +
 drivers/d3/ov10640/Kconfig                    |   10 +
 drivers/d3/ov10640/Makefile                   |    3 +
 drivers/d3/ov10640/ov10640.h                  |   67 +
 drivers/d3/ov10640/ov10640_ctrls.c            |  614 +++
 drivers/d3/ov10640/ov10640_ctrls.h            |   30 +
 drivers/d3/ov10640/ov10640_main.c             |  483 ++
 drivers/d3/ov10640/ov10640_reg.h              |   72 +
 drivers/d3/ov10640/ov10640_tables.c           | 2743 ++++++++++
 drivers/d3/ov10640/ov10640_tables.h           |   66 +
 drivers/d3/overlay-loader/Kconfig             |    4 +
 drivers/d3/overlay-loader/Makefile            |    3 +
 drivers/d3/overlay-loader/overlay-loader.c    |  794 +++
 drivers/d3/ub953/Kconfig                      |    4 +
 drivers/d3/ub953/Makefile                     |    3 +
 drivers/d3/ub953/ub953.c                      |  658 +++
 drivers/d3/ub960/Kconfig                      |    9 +
 drivers/d3/ub960/Makefile                     |    4 +
 drivers/d3/ub960/ub960.c                      | 2186 ++++++++
 drivers/d3/ub960/ub960tp.c                    |  767 +++
 drivers/d3/vg6768/.gitignore                  |    8 +
 drivers/d3/vg6768/Kconfig                     |    4 +
 drivers/d3/vg6768/Makefile                    |    2 +
 drivers/d3/vg6768/vg6768.c                    |  789 +++
 drivers/d3/vg6768/vg6768.h                    |   85 +
 drivers/d3/vg6768/vg6768_tables.h             |  184 +
 include/d3/config-eeprom.h                    |   36 +
 include/d3/d3-jetson-bsp.h                    |   13 +
 include/d3/of_private.h                       |   98 +
 include/d3/ub960.h                            |   30 +
 73 files changed, 29948 insertions(+)
 create mode 100644 drivers/d3/Kconfig
 create mode 100644 drivers/d3/Makefile
 create mode 100644 drivers/d3/ar0820/Kconfig
 create mode 100644 drivers/d3/ar0820/Makefile
 create mode 100644 drivers/d3/ar0820/ar0820.c
 create mode 100644 drivers/d3/ar0820/ar0820_tables.h
 create mode 100644 drivers/d3/build-id/Kconfig
 create mode 100644 drivers/d3/build-id/Makefile
 create mode 100644 drivers/d3/build-id/build-id.c
 create mode 100644 drivers/d3/config-eeprom/Kconfig
 create mode 100644 drivers/d3/config-eeprom/Makefile
 create mode 100644 drivers/d3/config-eeprom/config-eeprom.c
 create mode 100644 drivers/d3/early-at24/Kconfig
 create mode 100644 drivers/d3/early-at24/Makefile
 create mode 100644 drivers/d3/early-at24/modify-at24.sed
 create mode 100644 drivers/d3/imx390/Kconfig
 create mode 100644 drivers/d3/imx390/Makefile
 create mode 100644 drivers/d3/imx390/imx390-main.c
 create mode 100644 drivers/d3/imx390/imx390-mode-1936x1100-HDR.c
 create mode 100644 drivers/d3/imx390/imx390-mode-1936x1100-HDR.h
 create mode 100644 drivers/d3/imx390/imx390-mode-1936x1100-SP1H.c
 create mode 100644 drivers/d3/imx390/imx390-mode-1936x1100-SP1H.h
 create mode 100644 drivers/d3/imx390/imx390-mode-1936x1100-SP1L.c
 create mode 100644 drivers/d3/imx390/imx390-mode-1936x1100-SP1L.h
 create mode 100644 drivers/d3/imx390/imx390-mode-1936x1100-SP2.c
 create mode 100644 drivers/d3/imx390/imx390-mode-1936x1100-SP2.h
 create mode 100644 drivers/d3/imx390/imx390-modes.c
 create mode 100644 drivers/d3/imx390/imx390-modes.h
 create mode 100644 drivers/d3/max9296/Kconfig
 create mode 100644 drivers/d3/max9296/Makefile
 create mode 100644 drivers/d3/max9296/max9286.c
 create mode 100644 drivers/d3/max9296/max9286.h
 create mode 100644 drivers/d3/max9296/max9286_tables.h
 create mode 100644 drivers/d3/max9296/max9295.c
 create mode 100644 drivers/d3/max9296/max9295.h
 create mode 100644 drivers/d3/max9296/max9295_tables.h
 create mode 100644 drivers/d3/max9296/max9296.c
 create mode 100644 drivers/d3/max9296/max9296.h
 create mode 100644 drivers/d3/max9296/max9296_tables.h
 create mode 100644 drivers/d3/max9296/max96705.c
 create mode 100644 drivers/d3/max9296/max96705.h
 create mode 100644 drivers/d3/max9296/max96705_tables.h
 create mode 100644 drivers/d3/max9296/serdes.c
 create mode 100644 drivers/d3/max9296/serdes.h
 create mode 100644 drivers/d3/ov10640/Kconfig
 create mode 100644 drivers/d3/ov10640/Makefile
 create mode 100644 drivers/d3/ov10640/ov10640.h
 create mode 100644 drivers/d3/ov10640/ov10640_ctrls.c
 create mode 100644 drivers/d3/ov10640/ov10640_ctrls.h
 create mode 100644 drivers/d3/ov10640/ov10640_main.c
 create mode 100644 drivers/d3/ov10640/ov10640_reg.h
 create mode 100644 drivers/d3/ov10640/ov10640_tables.c
 create mode 100644 drivers/d3/ov10640/ov10640_tables.h
 create mode 100644 drivers/d3/overlay-loader/Kconfig
 create mode 100644 drivers/d3/overlay-loader/Makefile
 create mode 100644 drivers/d3/overlay-loader/overlay-loader.c
 create mode 100644 drivers/d3/ub953/Kconfig
 create mode 100644 drivers/d3/ub953/Makefile
 create mode 100644 drivers/d3/ub953/ub953.c
 create mode 100644 drivers/d3/ub960/Kconfig
 create mode 100644 drivers/d3/ub960/Makefile
 create mode 100644 drivers/d3/ub960/ub960.c
 create mode 100644 drivers/d3/ub960/ub960tp.c
 create mode 100644 drivers/d3/vg6768/.gitignore
 create mode 100644 drivers/d3/vg6768/Kconfig
 create mode 100644 drivers/d3/vg6768/Makefile
 create mode 100644 drivers/d3/vg6768/vg6768.c
 create mode 100644 drivers/d3/vg6768/vg6768.h
 create mode 100644 drivers/d3/vg6768/vg6768_tables.h
 create mode 100644 include/d3/config-eeprom.h
 create mode 100644 include/d3/d3-jetson-bsp.h
 create mode 100644 include/d3/of_private.h
 create mode 100644 include/d3/ub960.h

diff --git a/drivers/d3/Kconfig b/drivers/d3/Kconfig
new file mode 100644
index 000000000000..702f278a9c63
--- /dev/null
+++ b/drivers/d3/Kconfig
@@ -0,0 +1,13 @@
+menu "D3 Drivers"
+  source "drivers/d3/build-id/Kconfig"
+  source "drivers/d3/early-at24/Kconfig"
+  source "drivers/d3/config-eeprom/Kconfig"
+  source "drivers/d3/overlay-loader/Kconfig"
+  source "drivers/d3/ub960/Kconfig"
+  source "drivers/d3/ub953/Kconfig"
+# source "drivers/d3/max9296/Kconfig"
+  source "drivers/d3/imx390/Kconfig"
+  source "drivers/d3/ar0820/Kconfig"
+  source "drivers/d3/vg6768/Kconfig"
+  source "drivers/d3/ov10640/Kconfig"
+endmenu
diff --git a/drivers/d3/Makefile b/drivers/d3/Makefile
new file mode 100644
index 000000000000..f0d882812503
--- /dev/null
+++ b/drivers/d3/Makefile
@@ -0,0 +1,28 @@
+# The static build ID
+obj-$(CONFIG_D3_BUILDID) += build-id/
+
+# The driver to read configuration from the EEPROM.
+# List before config-eeprom so config-eeprom will be able to
+# access this EEPROM.
+# Note: initialization order is link order within an initcall level.
+obj-$(CONFIG_D3_EARLY_AT24) += early-at24/
+
+# The driver to read configuration from the EEPROM.
+# List before overlay-loader so overlay-loader will be able to
+# retrieve the EEPROM information.
+# Note: initialization order is link order within an initcall level.
+obj-$(CONFIG_D3_CONFIG_EEPROM) += config-eeprom/
+
+# The overlay loader to activate the configured camera drivers.
+# List after config-eeprom; recommend listing before any other drivers
+# so that the device tree is fully populated when the drivers load.
+obj-$(CONFIG_D3_OVERLAY_LOADER) += overlay-loader/
+
+# The drivers that can be activated by the overlay loader
+obj-$(CONFIG_D3_UB960) += ub960/
+obj-$(CONFIG_D3_UB953) += ub953/
+# obj-y += max9296/
+obj-$(CONFIG_D3_IMX390) += imx390/
+obj-$(CONFIG_D3_AR0820) += ar0820/
+obj-$(CONFIG_D3_VG6768) += vg6768/
+obj-$(CONFIG_D3_OV10640) += ov10640/
diff --git a/drivers/d3/ar0820/Kconfig b/drivers/d3/ar0820/Kconfig
new file mode 100644
index 000000000000..817a3bd34b71
--- /dev/null
+++ b/drivers/d3/ar0820/Kconfig
@@ -0,0 +1,5 @@
+config D3_AR0820
+	tristate "Enable OnSemi AR0820 CMOS Image Sensor."
+	help
+	  OnSemi AR0820 CMOS Image Sensor.
+
diff --git a/drivers/d3/ar0820/Makefile b/drivers/d3/ar0820/Makefile
new file mode 100644
index 000000000000..a01a383f668f
--- /dev/null
+++ b/drivers/d3/ar0820/Makefile
@@ -0,0 +1,2 @@
+obj-$(CONFIG_D3_AR0820)		+= ar0820.o
+
diff --git a/drivers/d3/ar0820/ar0820.c b/drivers/d3/ar0820/ar0820.c
new file mode 100644
index 000000000000..e750cbe6dd3f
--- /dev/null
+++ b/drivers/d3/ar0820/ar0820.c
@@ -0,0 +1,692 @@
+/*
+ * ar0820.c - OnSemi AR0820 CMOS Sensor
+ *
+ * Copyright (c) 2018-2019, D3 Engineering.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+
+// #define DEBUG 1
+
+#include <linux/module.h>
+#include <linux/module.h>
+#include <media/camera_common.h>
+#include <d3/d3-jetson-bsp.h>
+#include <linux/of_device.h>
+
+
+#include <ar0820_tables.h>
+
+/* #define AR0820_DEFAULT_FMT MEDIA_BUS_FMT_SRGGB12_1X12 */
+/* #define AR0820_DEFAULT_FMT MEDIA_BUS_FMT_SGRBG12_1X12 */
+#define AR0820_DEFAULT_FMT MEDIA_BUS_FMT_SBGGR12_1X12
+#define AR0820_DEFAULT_MODE AR0820_MODE_3848X2168
+#define AR0820_DEFAULT_CLK_FREQ 25000000
+
+/* Register definitions */
+#define AR0820_REG_COARSE_INT_TIME 0x3012
+#define AR0820_REG_GROUPED_PARAMETER_HOLD 0x3022
+#define AR0820_REG_GLOBAL_GAIN 0x305E
+#define AR0820_REG_ANALOG_GAIN 0X3366
+#define AR0820_REG_ANALOG_GAIN_CB 0X3368
+#define AR0820_REG_ANALOG_GAIN2 0X336A
+#define AR0820_REG_ANALOG_GAIN2_CB 0X336C
+#define AR0820_REG_ANALOG_LOW_GAIN 0X33BE
+
+
+
+#ifdef DEBUG
+/* Expose some registers in debugfs */
+static const struct regmap_range ar0820_yes_ranges[] = {
+	regmap_reg_range(0x2000, 0x200A), /* Frame count, and status */
+	regmap_reg_range(0x205C, 0x205C), /* Data format actual */
+	regmap_reg_range(0x3000, 0x3000), /* chip version */
+	regmap_reg_range(0x3002, 0x3002), /* Y addr. start (0) */
+	regmap_reg_range(0x3004, 0x3004), /* X addr. start (0) */
+	regmap_reg_range(0x3006, 0x3006), /* Y addr. end (2167) */
+	regmap_reg_range(0x3008, 0x3008), /* X addr. end (3847) */
+	regmap_reg_range(0x301A, 0x301C), /* reset reg, mode, orientation */
+	regmap_reg_range(0x3056, 0x305E), /* gain */
+	regmap_reg_range(0x3070, 0x307A), /* test pattern */
+	regmap_reg_range(0x30AA, 0x30AA), /* frame length lines cb */
+	regmap_reg_range(0x31AC, 0x31B2), /* data format, frame preamble, line preamble */
+	regmap_reg_range(0x31BE, 0x31BE), /* MIPI config status */
+	regmap_reg_range(0x31FE, 0x31FE), /* chip revision */
+	regmap_reg_range(0x3366, 0x336A),
+	regmap_reg_range(0x3372, 0x3372),
+	regmap_reg_range(0x340A, 0x340E), /* GPIO control */
+	regmap_reg_range(0x351A, 0x351A),
+};
+
+static const struct regmap_access_table ar0820_regmap_rd_access_table = {
+	.yes_ranges = ar0820_yes_ranges,
+	.n_yes_ranges = ARRAY_SIZE(ar0820_yes_ranges),
+};
+#endif /* DEBUG */
+
+static struct regmap_config ar0820_regmap_config = {
+	.reg_bits = 16,
+	.val_bits = 16,
+#ifdef DEBUG
+	.max_register = 0x517F,
+	.rd_table = &ar0820_regmap_rd_access_table,
+#endif /* DEBUG */
+};
+
+struct ar0820 {
+	struct camera_common_power_rail power;
+
+	struct i2c_client *client;
+	struct regmap *map;
+
+	struct camera_common_data *s_data;
+	struct camera_common_pdata *pdata;
+
+	struct v4l2_ctrl_handler ctrl_handler;
+	struct v4l2_subdev *subdev;
+	struct media_pad pad;
+
+	int frame_sync_mode;
+
+
+	struct v4l2_ctrl *ctrls[];
+};
+
+static int ar0820_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct ar0820 *priv =
+		container_of(ctrl->handler, struct ar0820, ctrl_handler);
+	int ret = 0;
+
+	switch (ctrl->id) {
+	default:
+		dev_err(&priv->client->dev, "%s: unknown ctrl id.", __func__);
+		return -EINVAL;
+	}
+	return ret;
+}
+
+static int ar0820_set_group_hold(struct ar0820 *priv, s32 val)
+{
+	u16 reg_val = !!val;
+	int ret = 0;
+
+	dev_dbg(&priv->client->dev, "%s: %u.", __func__, reg_val);
+	ret = regmap_write(priv->map, AR0820_REG_GROUPED_PARAMETER_HOLD,
+			reg_val);
+	if (ret)
+		dev_err(&priv->client->dev, "%s: error writing register.",
+				__func__);
+	return ret;
+}
+
+static int ar0820_set_gain(struct ar0820 *priv, u64 val)
+{
+	u16 gain = 0;
+	int ret = 0;
+
+	gain = (u16) ((val << 7) / FIXED_POINT_SCALING_FACTOR);
+
+	dev_dbg(&priv->client->dev, "%s: gain: %u.", __func__, gain);
+	ret = ar0820_set_group_hold(priv, 1);
+	if (ret) {
+		dev_err(&priv->client->dev, "%s: group hold err.", __func__);
+		return ret;
+	}
+	ret = regmap_write(priv->map, AR0820_REG_GLOBAL_GAIN, gain);
+	if (ret) {
+		dev_err(&priv->client->dev, "%s: error writing register.",
+				__func__);
+	}
+	ar0820_set_group_hold(priv, 0);
+	return ret;
+}
+
+static int ar0820_set_exposure(struct ar0820 *priv, s64 val)
+{
+	u16 c_int_t; /* coarse integration time */
+	int ret = 0;
+	struct camera_common_data *s_data = priv->s_data;
+	const struct sensor_mode_properties *mode =
+		&s_data->sensor_props.sensor_modes[s_data->mode];
+
+	c_int_t = mode->signal_properties.pixel_clock.val * val /
+		mode->image_properties.line_length / FIXED_POINT_SCALING_FACTOR;
+	/* CIT times specified in multiples of
+	 * ROPS * (NUM_EXP_MAX + 1 ) * LINE_LENGTH_PCK_
+	 * See AR0820 Register ref. guide, register 0x3012
+	 */
+	c_int_t /= 4;
+	dev_dbg(&priv->client->dev, "%s: c_int_t: %llu -> 0x%x.", __func__,
+			val, c_int_t);
+	ret = regmap_write(priv->map, AR0820_REG_COARSE_INT_TIME, c_int_t);
+	if (ret) {
+		dev_err(&priv->client->dev, "%s: error writing register",
+				__func__);
+	}
+	return ret;
+}
+
+static int ar0820_set_frame_rate(struct ar0820 *priv, s64 val)
+{
+	dev_warn(&priv->client->dev, "%s: not implemented.", __func__);
+	return 0;
+}
+
+static int ar0820_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct ar0820 *priv =
+		container_of(ctrl->handler, struct ar0820, ctrl_handler);
+	int ret = 0;
+
+	switch (ctrl->id) {
+	case TEGRA_CAMERA_CID_GAIN:
+		ret = ar0820_set_gain(priv, *ctrl->p_new.p_s64);
+		break;
+	case TEGRA_CAMERA_CID_EXPOSURE:
+		ret = ar0820_set_exposure(priv, *ctrl->p_new.p_s64);
+		break;
+	case TEGRA_CAMERA_CID_FRAME_RATE:
+		ret = ar0820_set_frame_rate(priv, *ctrl->p_new.p_s64);
+		break;
+	case TEGRA_CAMERA_CID_GROUP_HOLD:
+		ret = ar0820_set_group_hold(priv, ctrl->val);
+		break;
+	case TEGRA_CAMERA_CID_HDR_EN:
+		break;
+	case TEGRA_CAMERA_CID_SENSOR_MODE_ID:
+		break;
+	default:
+		dev_err(&priv->client->dev, "control %d not supported!", ctrl->id);
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static const struct v4l2_ctrl_ops ar0820_ctrl_ops = {
+	.g_volatile_ctrl = ar0820_g_volatile_ctrl,
+	.s_ctrl = ar0820_s_ctrl,
+};
+
+static struct v4l2_ctrl_config ctrl_config_list[] = {
+	{
+		.ops = &ar0820_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_GAIN,
+		.name = "Gain",
+		.type = V4L2_CTRL_TYPE_INTEGER64,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = 0 * FIXED_POINT_SCALING_FACTOR,
+		.max = 48 * FIXED_POINT_SCALING_FACTOR,
+		.def = 0 * FIXED_POINT_SCALING_FACTOR,
+		.step = 3 * FIXED_POINT_SCALING_FACTOR / 10, /* 0.3 db */
+	},
+	{ /* Exposure times are in microseconds */
+		.ops = &ar0820_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_EXPOSURE,
+		.name = "Exposure",
+		.type = V4L2_CTRL_TYPE_INTEGER64,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = 30 * FIXED_POINT_SCALING_FACTOR / 1000000,
+		.max = 1000000LL * FIXED_POINT_SCALING_FACTOR / 1000000,
+		.def = 30 * FIXED_POINT_SCALING_FACTOR / 1000000,
+		.step = 1 * FIXED_POINT_SCALING_FACTOR / 1000000,
+	},
+	{
+		.ops = &ar0820_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_FRAME_RATE,
+		.name = "Frame Rate",
+		.type = V4L2_CTRL_TYPE_INTEGER64,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = 20 * FIXED_POINT_SCALING_FACTOR,
+		.max = 20 * FIXED_POINT_SCALING_FACTOR,
+		.def = 20 * FIXED_POINT_SCALING_FACTOR,
+		.step = 1 * FIXED_POINT_SCALING_FACTOR,
+	},
+	{
+		.ops = &ar0820_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_GROUP_HOLD,
+		.name = "Group Hold",
+		.type = V4L2_CTRL_TYPE_INTEGER_MENU,
+		.min = 0,
+		.max = ARRAY_SIZE(switch_ctrl_qmenu) - 1,
+		.menu_skip_mask = 0,
+		.def = 0,
+		.qmenu_int = switch_ctrl_qmenu,
+	},
+	{
+		.ops = &ar0820_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_HDR_EN,
+		.name = "HDR enable",
+		.type = V4L2_CTRL_TYPE_INTEGER_MENU,
+		.min = 0,
+		.max = ARRAY_SIZE(switch_ctrl_qmenu) - 1,
+		.menu_skip_mask = 0,
+		.def = 0,
+		.qmenu_int = switch_ctrl_qmenu,
+	},
+	{
+		.ops = &ar0820_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_SENSOR_MODE_ID,
+		.name = "Sensor Mode",
+		.type = V4L2_CTRL_TYPE_INTEGER64,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = 0,
+		.max = 0xFF,
+		.def = 0xFE,
+		.step = 1,
+	},
+
+};
+
+static const struct i2c_device_id ar0820_idtable[] = {
+	{ "ar0820", 0 },
+	{},
+};
+MODULE_DEVICE_TABLE(i2c, ar0820_idtable);
+
+static const struct of_device_id ar0820_of_match[] = {
+	{ .compatible = "d3,ar0820" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, ar0820_of_match);
+
+static int ar0820_power_on(struct camera_common_data *s_data)
+{
+	struct ar0820 *priv = (struct ar0820*) s_data->priv;
+	struct camera_common_power_rail *power = &priv->power;
+
+	dev_dbg(&priv->client->dev, "power on.");
+	power->state = SWITCH_ON;
+	return 0;
+}
+
+static int ar0820_power_off(struct camera_common_data *s_data)
+{
+	struct ar0820 *priv = (struct ar0820*) s_data->priv;
+	struct camera_common_power_rail *power = &priv->power;
+
+	dev_dbg(&priv->client->dev, "power off.");
+	power->state = SWITCH_OFF;
+	return 0;
+}
+
+static int ar0820_write_reg(struct camera_common_data *s_data,
+		u16 addr, u8 val)
+{
+	struct ar0820 *priv = (struct ar0820*) s_data->priv;
+	int ret;
+
+	dev_dbg(&priv->client->dev, "%s: [0x%04x] = 0x%04x\n",
+			__func__, addr, val);
+	ret = regmap_write(priv->map, addr, val);
+	if (ret) {
+		dev_err(&priv->client->dev,
+			"%s: i2c write failed: 0x%x, 0x%x",
+			__func__, addr, val);
+	}
+	return ret;
+}
+
+static inline int ar0820_read_reg(struct camera_common_data *s_data,
+		u16 addr, u8 *val)
+{
+	struct ar0820 *priv = (struct ar0820*) s_data->priv;
+	u32 reg_val;
+	int ret;
+
+	ret = regmap_read(priv->map, addr, &reg_val);
+	if (ret) {
+		dev_err(&priv->client->dev,
+			"%s: i2c read failed: 0x%x, ret = %d",
+			__func__, addr, ret);
+	}
+	else {
+		*val = reg_val & 0xFF;
+	}
+	return ret;
+}
+
+static struct camera_common_sensor_ops ar0820_common_ops = {
+	.power_on = ar0820_power_on,
+	.power_off = ar0820_power_off,
+	.write_reg = ar0820_write_reg, /* TODO: warning here: type of val in prototype is u8 */
+	.read_reg = ar0820_read_reg, /* TODO: same as above */
+};
+
+/* v4l2 subdev */
+static int ar0820_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_common_data *s_data = to_camera_common_data(&client->dev);
+	struct ar0820 *priv = (struct ar0820*)s_data->priv;
+	int ret = 0;
+
+	if (enable) {
+		dev_dbg(&client->dev, "start streaming.");
+		ret = regmap_multi_reg_write(priv->map, ar0820_start, ARRAY_SIZE(ar0820_start));
+	}
+	else {
+		dev_dbg(&client->dev, "stop streaming.");
+		ret = regmap_multi_reg_write(priv->map, ar0820_stop, ARRAY_SIZE(ar0820_stop));
+	}
+	if (ret) {
+		dev_err(&client->dev, "Can't write registers: %d.", ret);
+	}
+	return ret;
+}
+
+static int ar0820_g_input_status(struct v4l2_subdev *sd, u32 *status)
+{
+	/* TODO: return the actual status */
+	*status = 1;
+	return 0;
+}
+
+static int ar0820_set_fmt(struct v4l2_subdev *sd,
+		struct v4l2_subdev_pad_config *cfg,
+		struct v4l2_subdev_format *format)
+{
+	int ret;
+
+	if (format->which == V4L2_SUBDEV_FORMAT_TRY) {
+		ret = camera_common_try_fmt(sd, &format->format);
+	}
+	else {
+		ret = camera_common_s_fmt(sd, &format->format);
+	}
+	return ret;
+}
+
+static int ar0820_get_fmt(struct v4l2_subdev *sd,
+		struct v4l2_subdev_pad_config *cfg,
+		struct v4l2_subdev_format *format)
+{
+	return camera_common_g_fmt(sd, &format->format);
+}
+
+static struct v4l2_subdev_core_ops ar0820_subdev_core_ops = {
+	.s_power = camera_common_s_power,
+};
+
+static struct v4l2_subdev_video_ops ar0820_subdev_video_ops = {
+	.s_stream = ar0820_s_stream,
+	.g_mbus_config = camera_common_g_mbus_config,
+	.g_input_status = ar0820_g_input_status,
+};
+
+static struct v4l2_subdev_pad_ops ar0820_subdev_pad_ops = {
+	.set_fmt = ar0820_set_fmt,
+	.get_fmt = ar0820_get_fmt,
+	.enum_mbus_code = camera_common_enum_mbus_code,
+	.enum_frame_size = camera_common_enum_framesizes,
+	.enum_frame_interval = camera_common_enum_frameintervals,
+};
+
+static struct v4l2_subdev_ops ar0820_subdev_ops = {
+	.core = &ar0820_subdev_core_ops,
+	.video = &ar0820_subdev_video_ops,
+	.pad = &ar0820_subdev_pad_ops,
+};
+
+static int ar0820_ctrls_init(struct ar0820 *priv)
+{
+	struct i2c_client *client = priv->client;
+	struct v4l2_ctrl *ctrl;
+	int num_ctrls = ARRAY_SIZE(ctrl_config_list);
+	int ret;
+	int i;
+
+	dev_dbg(&client->dev, "%s:", __func__);
+
+	v4l2_ctrl_handler_init(&priv->ctrl_handler, num_ctrls);
+
+	for (i = 0; i < num_ctrls; i++) {
+		ctrl = v4l2_ctrl_new_custom(&priv->ctrl_handler,
+				&ctrl_config_list[i], NULL);
+		if (ctrl == NULL) {
+			dev_err(&client->dev, "failed to init %s ctrl",
+					ctrl_config_list[i].name);
+			continue;
+		}
+		if (ctrl_config_list[i].type == V4L2_CTRL_TYPE_STRING &&
+			ctrl_config_list[i].flags & V4L2_CTRL_FLAG_READ_ONLY )
+		{
+			ctrl->p_new.p_char = devm_kzalloc(&client->dev,
+					ctrl_config_list[i].max + 1, GFP_KERNEL);
+		}
+		priv->ctrls[i] = ctrl;
+	}
+
+	priv->subdev->ctrl_handler = &priv->ctrl_handler;
+	if (priv->ctrl_handler.error) {
+		dev_err(&client->dev, "Error %d adding controls",
+				priv->ctrl_handler.error);
+		ret = priv->ctrl_handler.error;
+		goto error;
+	}
+
+	ret = v4l2_ctrl_handler_setup(&priv->ctrl_handler);
+	if (ret) {
+		dev_err(&client->dev, "Error %d setting default controls", ret);
+		goto error;
+	}
+
+	return 0;
+error:
+	v4l2_ctrl_handler_free(&priv->ctrl_handler);
+	return ret;
+}
+
+static int ar0820_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+
+	dev_dbg(&client->dev, "%s", __func__);
+	return 0;
+}
+
+static const struct v4l2_subdev_internal_ops ar0820_subdev_internal_ops = {
+	.open = ar0820_open,
+};
+
+static const struct media_entity_operations ar0820_media_ops = {
+	.link_validate = v4l2_subdev_link_validate,
+};
+
+static struct camera_common_pdata *ar0820_parse_dt(
+		struct ar0820 *self,
+		struct camera_common_data *s_data)
+{
+	struct i2c_client *client = self->client;
+	struct device_node *np = client->dev.of_node;
+	struct camera_common_pdata *board_priv_data;
+	const struct of_device_id *match;
+	int ret;
+
+	if (!np) {
+		dev_err(&client->dev, "open firmware node is NULL!");
+		return NULL;
+	}
+
+	match = of_match_device(ar0820_of_match, &client->dev);
+	if (!match) {
+		dev_err(&client->dev, "failed to find matching DT id.");
+		return NULL;
+	}
+
+	board_priv_data = devm_kzalloc(&client->dev,
+			sizeof(struct camera_common_data), GFP_KERNEL);
+	if (!board_priv_data) {
+		dev_err(&client->dev, "failed to allocate memory!");
+		return NULL;
+	}
+
+	ret = of_property_read_string(np, "mclk",
+			&board_priv_data->mclk_name);
+	if (ret)
+		dev_warn(&client->dev, "can't find mclk in DT.");
+
+	if (of_property_read_s32(np, "frame-sync-mode", &self->frame_sync_mode) != 0) {
+		self->frame_sync_mode = 0;
+	}
+
+	return board_priv_data;
+}
+
+
+static int ar0820_probe(struct i2c_client *client,
+		const struct i2c_device_id *id)
+{
+	struct camera_common_data *common_data;
+	struct ar0820 *priv;
+	int ret = 0;
+
+	dev_info(&client->dev, "Probing AR0820.");
+
+	if (!IS_ENABLED(CONFIG_OF) || !client->dev.of_node)
+		return -EINVAL;
+
+	common_data = devm_kzalloc(&client->dev,
+			sizeof(struct camera_common_data), GFP_KERNEL);
+	priv = devm_kzalloc(&client->dev,
+			sizeof(struct ar0820) + sizeof(struct v4l2_ctrl*) *
+			ARRAY_SIZE(ctrl_config_list),
+			GFP_KERNEL);
+	if (!common_data || !priv) {
+		dev_err(&client->dev, "failed to allocate memory!");
+		return -ENOMEM;
+	}
+
+	priv->client = client;
+	i2c_set_clientdata(client, priv);
+
+	priv->map = devm_regmap_init_i2c(client, &ar0820_regmap_config);
+	if (IS_ERR(priv->map)) {
+		dev_err(&client->dev, "failed to create regmap!");
+		return PTR_ERR(priv->map);
+	}
+
+	if (client->dev.of_node)
+		priv->pdata = ar0820_parse_dt(priv, common_data);
+	if (!priv->pdata) {
+		dev_err(&client->dev, "unable to get platform data!");
+		return -EFAULT;
+	}
+
+	common_data->ops = &ar0820_common_ops;
+	common_data->ctrl_handler = &priv->ctrl_handler;
+	common_data->dev = &client->dev;
+	common_data->frmfmt = ar0820_frmfmt;
+	common_data->colorfmt = camera_common_find_datafmt(AR0820_DEFAULT_FMT);
+	common_data->power = &priv->power;
+	common_data->ctrls = priv->ctrls;
+	common_data->priv = priv;
+	common_data->numctrls = ARRAY_SIZE(ctrl_config_list);
+	common_data->numfmts = ARRAY_SIZE(ar0820_frmfmt);
+	common_data->def_mode = AR0820_DEFAULT_MODE;
+	common_data->def_width = common_data->frmfmt[AR0820_DEFAULT_MODE].size.width;
+	common_data->def_height = common_data->frmfmt[AR0820_DEFAULT_MODE].size.height;
+	common_data->fmt_width = common_data->def_width;
+	common_data->fmt_height = common_data->def_height;
+	common_data->def_clk_freq = AR0820_DEFAULT_CLK_FREQ;
+
+	priv->s_data = common_data;
+	priv->subdev = &common_data->subdev;
+	priv->subdev->dev = &client->dev;
+	priv->s_data->dev = &client->dev;
+
+	/* get power? */
+
+	ret = camera_common_initialize(common_data, "ar0820");
+	if (ret) {
+		dev_err(&client->dev, "failed to initialize ar0820.");
+		return ret;
+	}
+
+	v4l2_i2c_subdev_init(priv->subdev, client, &ar0820_subdev_ops);
+
+	ret = ar0820_ctrls_init(priv);
+	if (ret)
+		return ret;
+	priv->subdev->internal_ops = &ar0820_subdev_internal_ops;
+	priv->subdev->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE
+		| V4L2_SUBDEV_FL_HAS_EVENTS;
+
+#if defined(CONFIG_MEDIA_CONTROLLER)
+	priv->pad.flags = MEDIA_PAD_FL_SOURCE;
+	//priv->subdev->entity.type = MEDIA_ENT_T_V4L2_SUBDEV_SENSOR;
+	priv->subdev->entity.ops = &ar0820_media_ops;
+	ret = tegra_media_entity_init(&priv->subdev->entity, 1, &priv->pad,
+				      true, true);
+	if (ret < 0) {
+		dev_err(&client->dev, "failed to initialize media entity!");
+		return ret;
+	}
+#endif
+	ret = regmap_multi_reg_write(priv->map, ar0820_mode_3848x2168, ARRAY_SIZE(ar0820_mode_3848x2168));
+	if (ret) {
+		dev_err(&client->dev, "failed to initialize the sensor!");
+		return ret;
+	}
+	if (priv->frame_sync_mode == 1) {
+		dev_info(&client->dev, "enabling frame sync mode.");
+		ret = regmap_multi_reg_write(priv->map, ar0820_frame_sync, ARRAY_SIZE(ar0820_frame_sync));
+		if (ret) {
+			dev_err(&client->dev, "failed to enable frame sync!");
+			return ret;
+		}
+	}
+	ret = v4l2_async_register_subdev(priv->subdev);
+	if (ret)
+		return ret;
+	dev_info(&client->dev, "probed AR0820 sensor.");
+
+	return 0;
+}
+
+static int ar0820_remove(struct i2c_client *client)
+{
+	struct camera_common_data *s_data = to_camera_common_data(&client->dev);
+	struct ar0820 *priv = (struct ar0820 *) s_data->priv;
+
+	dev_info(&client->dev, "Removing AR0820.");
+	v4l2_async_unregister_subdev(priv->subdev);
+#if defined(CONFIG_MEDIA_CONTROLLER)
+	media_entity_cleanup(&priv->subdev->entity);
+#endif
+
+	v4l2_ctrl_handler_free(&priv->ctrl_handler);
+	camera_common_cleanup(s_data);
+	return 0;
+}
+
+
+static struct i2c_driver ar0820_driver = {
+	.driver = {
+		.name = "ar0820",
+		.owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(ar0820_of_match),
+	},
+	.probe = ar0820_probe,
+	.remove = ar0820_remove,
+	.id_table = ar0820_idtable,
+};
+
+module_i2c_driver(ar0820_driver);
+
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Catalin Petrescu <cpetrescu@d3engineering.com>");
+MODULE_DESCRIPTION("OnSemi AR0820 CMOS Sensor driver");
+MODULE_VERSION(D3_JETSON_BSP_VERSION);
+
diff --git a/drivers/d3/ar0820/ar0820_tables.h b/drivers/d3/ar0820/ar0820_tables.h
new file mode 100644
index 000000000000..f621f2a915ad
--- /dev/null
+++ b/drivers/d3/ar0820/ar0820_tables.h
@@ -0,0 +1,360 @@
+/*
+ * ar0820_tables.h - OnSemi AR0820 CMOS Sensor mode tables
+ *
+ * Copyright (c) 2018-2019, D3 Engineering.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+/* Sequences copied from AR0820_MAX9295A_config10.ini */
+
+#ifndef _AR0820_TABLES_
+#define _AR0820_TABLES_
+
+
+static const struct reg_sequence ar0820_mode_3848x2168[] = {
+	{ 0x301A, 0x0059, 200000 }, // STATE= Sensor Reset,1
+	{ 0x301A, 0x0058, 100000 }, // STATE= Sensor Reset,0
+	// Disable streaming in serial mode; SERIALISER_DIS = 0, PARALLEL_EN = 0, DRIVE_PINS = 1, RESET_REGISTER_LOCK_REG=1
+	// LOAD= Feb21_Sequencer
+	// [Hidden: Feb21_Sequencer]
+	// pix_timing_J_test4 from JIDC
+	{ 0x2512, 0x8000 },
+	{ 0x2510, 0xFFFF },
+	{ 0x2510, 0xFFFF },
+	{ 0x2510, 0xFFFF },
+	{ 0x2510, 0xFFFF },
+	{ 0x2510, 0xFFFF },
+	{ 0x2510, 0xFFFF },
+	{ 0x2510, 0xFFFF },
+	{ 0x2510, 0xFFFF },
+	{ 0x2510, 0xFF07 },
+	{ 0x2510, 0xFFFF },
+	{ 0x2510, 0xFFFF },
+	{ 0x2510, 0xFFFF },
+	{ 0x2510, 0xFFFF },
+	{ 0x2510, 0xFFFF },
+	{ 0x2510, 0xFFFF },
+	{ 0x2510, 0xFFFF },
+	{ 0x2510, 0xFFFF },
+	{ 0x2510, 0xFFFF },
+	{ 0x2510, 0xFFFF },
+	{ 0x2510, 0xFFFF },
+	{ 0x2510, 0xFFFF },
+	{ 0x2510, 0xFFFF },
+	{ 0x2510, 0xFFFF },
+	{ 0x2510, 0xFFFF },
+	{ 0x2510, 0xFFFF },
+	{ 0x2510, 0xFFFF },
+	{ 0x2510, 0xFFFF },
+	{ 0x2510, 0xFFFF },
+	{ 0x2510, 0x3001 },
+	{ 0x2510, 0x3010 },
+	{ 0x2510, 0x3006 },
+	{ 0x2510, 0x3020 },
+	{ 0x2510, 0x3008 },
+	{ 0x2510, 0xB031 },
+	{ 0x2510, 0xA824 },
+	{ 0x2510, 0x003C },
+	{ 0x2510, 0x001F },
+	{ 0x2510, 0xB0F9 },
+	{ 0x2510, 0x006D },
+	{ 0x2510, 0x00EF },
+	{ 0x2510, 0x005C },
+	{ 0x2510, 0x106F },
+	{ 0x2510, 0xC013 },
+	{ 0x2510, 0x016E },
+	{ 0x2510, 0xC806 },
+	{ 0x2510, 0x106E },
+	{ 0x2510, 0x0017 },
+	{ 0x2510, 0x0013 },
+	{ 0x2510, 0x004B },
+	{ 0x2510, 0x0002 },
+	{ 0x2510, 0x90F2 },
+	{ 0x2510, 0x90FF },
+	{ 0x2510, 0xD034 },
+	{ 0x2510, 0x1032 },
+	{ 0x2510, 0x0000 },
+	{ 0x2510, 0x0033 },
+	{ 0x2510, 0x00D1 },
+	{ 0x2510, 0x092E },
+	{ 0x2510, 0x1333 },
+	{ 0x2510, 0x123D },
+	{ 0x2510, 0x045B },
+	{ 0x2510, 0x11BB },
+	{ 0x2510, 0x133A },
+	{ 0x2510, 0x907D },
+	{ 0x2510, 0x1017 },
+	{ 0x2510, 0x1115 },
+	{ 0x2510, 0x14DB },
+	{ 0x2510, 0x00DD },
+	{ 0x2510, 0x3088 },
+	{ 0x2510, 0x3084 },
+	{ 0x2510, 0x2007 },
+	{ 0x2510, 0x02DA },
+	{ 0x2510, 0xD80C },
+	{ 0x2510, 0x2009 },
+	{ 0x2510, 0x01F0 },
+	{ 0x2510, 0x14F0 },
+	{ 0x2510, 0x018B },
+	{ 0x2510, 0x128B },
+	{ 0x2510, 0x00E4 },
+	{ 0x2510, 0x0072 },
+	{ 0x2510, 0x203B },
+	{ 0x2510, 0x8A28 },
+	{ 0x2510, 0x10CC },
+	{ 0x2510, 0xC02A },
+	{ 0x2510, 0x1064 },
+	{ 0x2510, 0x0063 },
+	{ 0x2510, 0x1072 },
+	{ 0x2510, 0x06BE },
+	{ 0x2510, 0x006E },
+	{ 0x2510, 0x100E },
+	{ 0x2510, 0x0019 },
+	{ 0x2510, 0x0015 },
+	{ 0x2510, 0x16EE },
+	{ 0x2510, 0x0071 },
+	{ 0x2510, 0x10BE },
+	{ 0x2510, 0x1063 },
+	{ 0x2510, 0x1671 },
+	{ 0x2510, 0x1095 },
+	{ 0x2510, 0x1019 },
+	{ 0x2510, 0x3088 },
+	{ 0x2510, 0x3084 },
+	{ 0x2510, 0x2003 },
+	{ 0x2510, 0x018B },
+	{ 0x2510, 0x128B },
+	{ 0x2510, 0x00E4 },
+	{ 0x2510, 0x0072 },
+	{ 0x2510, 0x20C4 },
+	{ 0x2510, 0x10E4 },
+	{ 0x2510, 0x1072 },
+	{ 0x2510, 0x3041 },
+	{ 0x2510, 0xD800 },
+	{ 0x2510, 0x000A },
+	{ 0x2510, 0x100C },
+	{ 0x2510, 0x008E },
+	{ 0x2510, 0x3081 },
+	{ 0x2510, 0x10CB },
+	{ 0x2510, 0x10D2 },
+	{ 0x2510, 0xC200 },
+	{ 0x2510, 0xCA00 },
+	{ 0x2510, 0xD230 },
+	{ 0x2510, 0x8200 },
+	{ 0x2510, 0x11AE },
+	{ 0x2510, 0x1039 },
+	{ 0x2510, 0xD000 },
+	{ 0x2510, 0x106D },
+	{ 0x2510, 0x101F },
+	{ 0x2510, 0x100E },
+	{ 0x2510, 0x100A },
+	{ 0x2510, 0x3042 },
+	{ 0x2510, 0x3086 },
+	{ 0x2510, 0x102F },
+	{ 0x2510, 0x3090 },
+	{ 0x2510, 0x9010 },
+	{ 0x2510, 0xB000 },
+	{ 0x2510, 0x30A0 },
+	{ 0x2510, 0x1016 },
+	{ 0x2510, 0x7FFF },
+	{ 0x2510, 0x7FFF },
+	{ 0x2510, 0x7FFF },
+	{ 0x2510, 0x7FFF },
+	{ 0x2510, 0x7FFF },
+	{ 0x2510, 0x7FFF },
+	{ 0x2510, 0x7FFF },
+	// LOAD= Recommended Settings - No Bin
+	// [Hidden: Recommended Settings - No Bin]
+	// Char recommended settings
+
+	// IF_0x31FE 0x0C00, ==1, ; LOAD= 1v1 CHAR No bin, ELSE; LOAD= 1v2 CHAR No bin
+	// Only one of the following two sections should be applied, depending on rev of sensor:
+
+	// [Hidden: 1v1 CHAR No bin] Rev 1.1 silicon
+	// 0x350A 0xC1C1		; Vtxhi=3.3V, Vrsthi=3.3V
+	// 0x350C 0xC1C1		; Vrshi and Vdcghi 3.3V
+	// 0x350E 0x8D8D		; Vtxlo_x=-0.9V, Vtxlo_ro=-0.9V,
+	// 0x3510 0x8D88		; Vsublo=-0.9V,
+	// 0x3512 0x8C8C		; Vrstlo_ro and Vrstlo_ro  0.8V
+	// 0x3514 0xA0A0		; Vdcglo_ro and Vdcglo_x=0V
+
+	// [Hidden: 1v2 CHAR No bin] Rev 1.2 silicon
+	{ 0x350A, 0xC1C0 },	// Vtxhi=2.8V, Vrsthi=3.3V
+	{ 0x350C, 0xC1C1 },	// Vrshi and Vdcghi 3.3V
+	{ 0x350E, 0x8C8C },	// Vtxlo_x=-0.8V, Vtxlo_ro=-0.8V,
+	{ 0x3510, 0x8C88 },	// Vsublo=-0.8V
+	{ 0x3512, 0x8C8C },	// Vrstlo_ro and Vrstlo_ro  0.8V
+	{ 0x3514, 0xA0A0 },	// Vdcglo_ro and Vdcglo_x=0V
+	{ 0x3518, 0x0000 },	// row_latch_en_tx_act and row_vaapix_en_rst disabled
+
+	{ 0x351A, 0x8600 },	// GREF_SUPPRESS_TX_SAMP=1
+	{ 0x3506, 0x004A },	// vln 5uA
+	{ 0x3520, 0x1422 },	// ECL setting HCG=34, LCG=20
+	{ 0x3522, 0x3E37 },	// FSC setting HCG_8x=55, HCG_4x=62
+	{ 0x3524, 0x6E48 },	// FSC setting HCG_2x=72, HCG_1x=110
+	{ 0x3526, 0x4237 },	// FSC setting LCG_8x=55, LCG_4x=66
+	{ 0x3528, 0x6249 },	// FSC setting LCG_2x=73, LCG_1x=98
+	{ 0x30FE, 0x00A8 },	// noise pedestal 168
+	{ 0x342A, 0x0011 },	// CRM
+	{ 0x3584, 0x0000 },	// row_ab_ctrl=0
+	{ 0x354C, 0x0030 },	// pwr_dn_clamp=0, ECL off
+	{ 0x3370, 0x0111 },	// DBLC gaintrig enabled
+	{ 0x337A, 0x0E74 },	// scaling factor ~0.9
+	{ 0x3110, 0x0011 },	// pre_hdr_gain_enabled to help soft eclipse in HDR mode
+	{ 0x3100, 0x4000 },	// enable noise filtering
+	// Design recommended settings dated 23 Jan 2018
+	{ 0x33FC, 0x00E4 },	// pixel color indication, do not change
+	{ 0x33FE, 0x00E4 },	// cb
+	{ 0x301E, 0x00A8 },	// data_pedestal
+	{ 0x3180, 0x0021 },	// DBLC dither enabled
+	{ 0x3372, 0x710F },	// DBLC_fs0_control, dblc_scale_en
+	{ 0x3E4C, 0x0404 },	// DBLC filter settings
+	{ 0x3180, 0x0021 },	// DBLC_DITHER_EN
+	{ 0x37a0, 0x0001 },	// coarse_integration_ad_time
+	{ 0x37a4, 0x0000 },	// coarse_integration_ad_time2
+	{ 0x37a8, 0x0000 },	// coarse_integration_ad_time3
+	{ 0x37ac, 0x0001 },	// coarse_integration_ad_time4
+
+	// LOAD= f2_pll_setup_800M
+	// [Hidden: f2_pll_setup_800M]
+	{ 0x302A, 0x0005 },	// vtpixclk p2 div
+	{ 0x302C, 0x0701 },	// vtsysclk p1 div
+	{ 0x302E, 0x0009 },	// pll pre divider
+	{ 0x3030, 0x0086 },	// pll multiplier
+	{ 0x3036, 0x0006 },	// op word clk div
+	{ 0x3038, 0x0001 },	// op sys clk div
+	{ 0x303A, 0x00CD },	// pll multiplier Ana
+	{ 0x303C, 0x0009 },	// pll pre div Ana
+
+	// LOAD= m1_mipi_timing_recommended_800M
+	// [Hidden: m1_mipi_timing_recommended_800M]
+	{ 0x31B0, 0x005C },	// frame preamble
+	{ 0x31B2, 0x0041 },	// line preamble
+	{ 0x31B4, 0x1187 },	//  Mipi_timing_0
+	{ 0x31B6, 0x120A },	//  Mipi_timing_1
+	{ 0x31B8, 0x6049 },	//  Mipi_timing_2
+	{ 0x31BA, 0x0289 },	//  Mipi_timing_3
+	{ 0x31BC, 0x8A07 },	//  Mipi_timing_4
+
+	// LOAD= a01_array_setup_3848_2168_skip1
+	// [Hidden: a01_array_setup_3848_2168_skip1]
+	{ 0x3002, 0x0000 },	// y_addr_start
+	{ 0x3004, 0x0000 },	// x_addr_start
+	{ 0x3006, 0x0877 },	// y_addr_end
+	{ 0x3008, 0x0F07 },	// x_addr_end
+	{ 0x32FC, 0x0000 },	// no binning
+	{ 0x37E0, 0x8421 },
+	{ 0x37E2, 0x8421 },	// cb
+	{ 0x323C, 0x8421 },
+	{ 0x323E, 0x8421 },	// cb
+	{ 0x3040, 0x0001 },	// no mirror or flip and stats rows at 4
+	{ 0x301D, 0x0000 },	// no mirror or flip
+
+	{ 0x3082, 0x0000 },	// 0x3082 = 1 exposures
+	{ 0x30BA, 0x1100 },	// Num_exp_max
+	{ 0x3012, 0x0014 },	// coarse_integration_time was 0x0140
+	{ 0x3014, 0x0000 },	// fine_integration_time
+	{ 0x3362, 0x0001 },	// DCG =high
+	{ 0x3366, 0x0000 },	// Gain =1x
+	{ 0x336A, 0x0000 },	// Gain =1x
+
+	{ 0x300C, 0x0cac },	// line_length_pclk was 0x0A08, min = 0x0cac
+	{ 0x300A, 0x08F8 },	// frame_length_lines
+
+	// LOAD= c1_corrections_recommended
+	{ 0x31AE, 0x0204 },
+	{ 0x31AC, 0x0C0C },
+
+	// -------------- TEST PATTERN ------------
+	{ 0x3070, 0x0000 },	// 0 = normal operation, 1 = solid color, 2 = color bar, 3 = fade to grey, 256 = walking 1's
+	{ 0x3072, 0x0200 },	// Test data Red (for solid color)
+	{ 0x3074, 0x0400 },	// Test data GreenR
+	{ 0x3076, 0x0100 },	// Test data Blue
+	{ 0x3078, 0x0400 },	// Test data GreenB
+	// -------------- TEST PATTERN ------------
+
+	// LOAD= Disable Embedded Data and Stats
+	// [Hidden: Disable Embedded Data and Stats]
+	// LOAD= Embedded Data off
+	// [Hidden: Embedded Data off]
+	// BITFIELD = 0x301A [0058], 0x04, 0; Streaming off
+	{ 0x301A, 0x0058, 100000 },
+	// BITFIELD = 0x3064 [0100], 0x0100, 0; Embedded data off
+	{ 0x3064, 0x0000 },
+	// BITFIELD = 0x301A [0058], 0x04, 1; Streaming on
+	{ 0x301A, 0x005C },
+	// LOAD= Embedded Stats off
+	// [Hidden: Embedded Stats off]
+	// BITFIELD = 0x301A [], 0x04, 0; Streaming off
+	{ 0x301A, 0x0058, 100000 },
+	// BITFIELD = 0x3064 [0000], 0x80, 0; Embedded stats off
+	{ 0x3064, 0x0000 },
+	// BITFIELD = 0x301A [], 0x04, 1; Streaming on
+	{ 0x301A, 0x0058, 128000 }, // Disable streaming.
+	// IMAGE= 3848,2168, BAYER-12
+};
+
+static const struct reg_sequence ar0820_frame_sync[] = {
+	{ 0x30CE, 0x0120 },  // Slave Mode: Deterministic Trigger
+	{ 0x340A, 0x0077 },  // GPIO3: Input enable, output disable
+	{ 0x340C, 0x0080 },  // GPIO3: Trigger Input
+};
+
+static const struct reg_sequence ar0820_start[] = {
+	{ 0x301A, 0x015C, 128000 },
+};
+
+static const struct reg_sequence ar0820_stop[] = {
+	{ 0x0301A, 0x0058, 100000 },
+};
+
+static const struct reg_sequence ar0820_test_pattern[] = {
+	{ 0x3070, 0x0000, }, // 0 = normal operation, 1 = solid color, 2 = color bar, 3 = fade to grey, 256 = walking 1's
+	{ 0x3072, 0x0200, }, // Test data Red (for solid color)
+	{ 0x3074, 0x0400, }, // Test data GreenR
+	{ 0x3076, 0x0100, }, // Test data Blue
+	{ 0x3078, 0x0400, }, // Test data GreenB
+};
+
+enum ar0820_modes {
+	AR0820_MODE_3848X2168 = 0,
+	AR0820_MODE_START_STREAM,
+	AR0820_MODE_STOP_STREAM,
+	AR0820_MODE_TEST_PATTERN,
+};
+
+#if 0
+static const struct reg_sequence *ar0820_mode_table[] = {
+	[AR0820_MODE_3848X2168] = ar0820_mode_3848x2168,
+	[AR0820_MODE_START_STREAM] = ar0820_start,
+	[AR0820_MODE_STOP_STREAM] = ar0820_stop,
+	[AR0820_MODE_TEST_PATTERN] = ar0820_test_pattern,
+};
+#endif
+
+static const int ar0820_20fps[] = {
+	20,
+};
+
+
+static const struct camera_common_frmfmt ar0820_frmfmt[] = {
+	{
+		.size = { 3848, 2168 },
+		.framerates = ar0820_20fps,
+		.num_framerates = 1,
+		.hdr_en = 0,
+		.mode = AR0820_MODE_3848X2168,
+	},
+};
+
+#endif /* _AR0820_TABLES_ */
+
diff --git a/drivers/d3/build-id/Kconfig b/drivers/d3/build-id/Kconfig
new file mode 100644
index 000000000000..cd25294283e9
--- /dev/null
+++ b/drivers/d3/build-id/Kconfig
@@ -0,0 +1,5 @@
+config D3_BUILDID
+	bool "Include a build identifier"
+	select NVMEM
+	help
+        This will include a unique identifier for each build in the kernel.
diff --git a/drivers/d3/build-id/Makefile b/drivers/d3/build-id/Makefile
new file mode 100644
index 000000000000..cba91d099957
--- /dev/null
+++ b/drivers/d3/build-id/Makefile
@@ -0,0 +1,3 @@
+# -*-makefile-*-
+obj-$(CONFIG_D3_BUILDID) += build-id.o
+
diff --git a/drivers/d3/build-id/build-id.c b/drivers/d3/build-id/build-id.c
new file mode 100644
index 000000000000..a97c67293593
--- /dev/null
+++ b/drivers/d3/build-id/build-id.c
@@ -0,0 +1,66 @@
+/**
+ * @author Greg Rowe <growe@d3engineering.com>
+ *
+ * Copyright (c) 2019, D3 Engineering.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+#include <linux/module.h>
+
+#include <linux/of.h>
+#include <d3/d3-jetson-bsp.h>
+
+#define MODULE_NAME "build-id"
+MODULE_DESCRIPTION("Unique build id");
+MODULE_VERSION(D3_JETSON_BSP_BUILDID);
+MODULE_AUTHOR("Greg Rowe <growe@d3engineering.com>");
+MODULE_LICENSE("GPL v2");
+
+
+static void buildid_check_dtb_match(void) {
+	static const char *NAME = "d3,jetson-bsp-build-id";
+	const char *build_id = NULL;
+
+	int err = of_property_read_string(of_root, NAME, &build_id);
+	if (err != 0) {
+		printk(KERN_WARNING
+		       MODULE_NAME
+		       ": could not read device tree %s \n", NAME);
+		return;
+	}
+	if (strcasecmp(D3_JETSON_BSP_BUILDID, build_id) != 0) {
+		printk(KERN_WARNING
+		       MODULE_NAME
+		       ": kernel build id does not match device tree: "
+		       "kernel=\"%s\", device-tree=\"%s\" \n",
+		       D3_JETSON_BSP_BUILDID, build_id);
+		return;
+	}
+}
+
+
+static int __init buildid_init(void) {
+
+	printk(KERN_INFO
+	       "D3 Jetson BSP v"
+	       D3_JETSON_BSP_VERSION
+	       " build id:"
+	       D3_JETSON_BSP_BUILDID
+	       "\n");
+
+	buildid_check_dtb_match();
+	return 0;
+}
+module_init(buildid_init);
+
+
diff --git a/drivers/d3/config-eeprom/Kconfig b/drivers/d3/config-eeprom/Kconfig
new file mode 100644
index 000000000000..c10b58a49457
--- /dev/null
+++ b/drivers/d3/config-eeprom/Kconfig
@@ -0,0 +1,5 @@
+config D3_CONFIG_EEPROM
+	bool "Configuration EEPROM"
+	depends on NVMEM
+	help
+	  D3 A driver that accesses a configuration EEPROM.
diff --git a/drivers/d3/config-eeprom/Makefile b/drivers/d3/config-eeprom/Makefile
new file mode 100644
index 000000000000..c9836d469423
--- /dev/null
+++ b/drivers/d3/config-eeprom/Makefile
@@ -0,0 +1,3 @@
+# -*-makefile-*-
+obj-$(CONFIG_D3_CONFIG_EEPROM) += config-eeprom.o
+
diff --git a/drivers/d3/config-eeprom/config-eeprom.c b/drivers/d3/config-eeprom/config-eeprom.c
new file mode 100644
index 000000000000..11f5c4995eb0
--- /dev/null
+++ b/drivers/d3/config-eeprom/config-eeprom.c
@@ -0,0 +1,215 @@
+/*
+ * Copyright (c) 2019, D3 Engineering  All rights reserved.
+ * Author: Christopher White <cwhite@d3engineering.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ */
+
+#include <linux/err.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/vmalloc.h>
+
+#include <linux/nvmem-consumer.h>
+#include <linux/of.h>
+
+#include <d3/config-eeprom.h>
+
+#define MODULE_NAME "config-eeprom"
+
+/* Define to see a debugging dump of the first 16 bytes of the EEPROM
+ * at bootup. */
+//#define DEBUG_DUMP
+
+/* The device-tree node holding the phandle of the EEPROM we want.
+ * Defined in hardware/d3/d3-config-eeprom.dtsi. */
+#define CONFIG_NODE_PATH ("/chosen/d3,config-eeprom@0")
+
+// EEPROMs I know of:
+// RSP: ST M24512, 64KByte
+// CIC: 24AA1026, 128KByte
+
+static struct config_eeprom_data *curr_data = NULL;
+
+#define DEBUG_BUFSIZE (512)
+
+/**
+ * config_eeprom_load_from_eeprom() - Read the EEPROM.
+ *
+ * This is an internal function.
+ *
+ * Return: A pointer to the data, or NULL on failure.
+ */
+
+static struct config_eeprom_data *config_eeprom_load_from_eeprom(void)
+{
+	/// The device node holding the nvmem-names and nvmem properties
+	struct config_eeprom_data *retval = NULL;
+	struct device_node *config = NULL;
+	struct nvmem_device *nvmem = NULL;
+
+	do {	/* once - cleanup follows */
+
+#ifdef DEBUG_DUMP
+		unsigned char d[16];
+		char str[DEBUG_BUFSIZE];
+#endif //DEBUG_DUMP
+
+		int len;
+
+		config = of_find_node_by_path(CONFIG_NODE_PATH);
+		if(!config)
+			break;
+
+		pr_info(MODULE_NAME ": Found config node %s (%s)\n",
+				config->name, config->full_name);
+
+		nvmem = of_nvmem_device_get(config, "overlay");
+		if(IS_ERR(nvmem)) {
+			pr_notice(MODULE_NAME ": Could not open NVMEM device: %lld\n", (long long)nvmem);
+			nvmem = NULL;
+			break;
+		}
+
+		pr_info(MODULE_NAME ": Found NVMEM %p\n", (void *)nvmem);
+
+#ifdef DEBUG_DUMP
+		/* Dump the first 16 bytes of the EEPROM.
+		 * This is a debugging aid. */
+		len = nvmem_device_read(nvmem, 0, 16, d);
+		if(len<0) {
+			pr_notice(MODULE_NAME ": Could not read data: error %d\n", len);
+			break;
+		}
+
+		/* Brute force!  Made with Vim. */
+		snprintf(str, DEBUG_BUFSIZE, "Got EEPROM data: "
+				"%02x %02x %02x %02x "
+				"%02x %02x %02x %02x  "
+				"%02x %02x %02x %02x "
+				"%02x %02x %02x %02x "
+				"%c%c%c%c%c%c%c%c "
+				"%c%c%c%c%c%c%c%c\n",
+				d[0], d[1], d[2], d[3],
+				d[4], d[5], d[6], d[7],
+				d[8], d[9], d[10], d[11],
+				d[12], d[13], d[14], d[15],
+				(d[0] < 32 || d[0] >= 127) ? '.' : d[0],
+				(d[1] < 32 || d[1] >= 127) ? '.' : d[1],
+				(d[2] < 32 || d[2] >= 127) ? '.' : d[2],
+				(d[3] < 32 || d[3] >= 127) ? '.' : d[3],
+				(d[4] < 32 || d[4] >= 127) ? '.' : d[4],
+				(d[5] < 32 || d[5] >= 127) ? '.' : d[5],
+				(d[6] < 32 || d[6] >= 127) ? '.' : d[6],
+				(d[7] < 32 || d[7] >= 127) ? '.' : d[7],
+				(d[8] < 32 || d[8] >= 127) ? '.' : d[8],
+				(d[9] < 32 || d[9] >= 127) ? '.' : d[9],
+				(d[10] < 32 || d[10] >= 127) ? '.' : d[10],
+				(d[11] < 32 || d[11] >= 127) ? '.' : d[11],
+				(d[12] < 32 || d[12] >= 127) ? '.' : d[12],
+				(d[13] < 32 || d[13] >= 127) ? '.' : d[13],
+				(d[14] < 32 || d[14] >= 127) ? '.' : d[14],
+				(d[15] < 32 || d[15] >= 127) ? '.' : d[15]
+		);
+
+		pr_info(MODULE_NAME ": %s\n", str);
+
+#endif //DEBUG_DUMP
+
+		retval = vmalloc(sizeof(struct config_eeprom_data));
+		if(!retval)
+			break;
+
+		len = nvmem_device_read(nvmem, 0, CONFIG_EEPROM_DATA_SIZE,
+					retval);
+		if(len<0) {
+			pr_notice("Could not read data: error %d\n", len);
+			vfree(retval);
+			retval = NULL;
+			break;
+		}
+
+	} while(0);
+
+	if(nvmem) {
+		nvmem_device_put(nvmem);	// free nvmem
+		nvmem = NULL;
+	} else {
+		pr_notice(MODULE_NAME ": could not find nvmem\n");
+	}
+
+	if(config) {
+		of_node_put(config);
+		config = NULL;
+	} else {
+		pr_notice(MODULE_NAME ": could not find config device-tree node\n");
+	}
+
+	return retval;
+} //config_eeprom_load_from_eeprom
+
+/**
+ * config_eeprom_get_data() - retrieve the data loaded from the EEPROM.
+ *
+ * This function is the main interface to users of this module.  Any driver
+ * initialized after this one can retrieve the data pointer using this
+ * function.  Interpretation of the data is left to the driver user.
+ *
+ * Return: A pointer to the data, or NULL on failure.
+ */
+
+struct config_eeprom_data *config_eeprom_get_data(void)
+{
+	return curr_data;
+}
+EXPORT_SYMBOL_GPL(config_eeprom_get_data);
+
+/**
+ * config_eeprom_init() - startup routine - load the data
+ *
+ * Return: always 0
+ */
+
+static int __init config_eeprom_init(void)
+{
+	// __LINE__: Poor-man's double-check that we have the right file
+	pr_info(MODULE_NAME ": Initializing " __stringify(__LINE__) "\n");
+	curr_data = config_eeprom_load_from_eeprom();
+
+	return 0;
+}
+
+/**
+ * config_eeprom_exit() - shutdown routine - free the data
+ *
+ * Return: A pointer to the data, or NULL on failure.
+ */
+
+static void __exit config_eeprom_exit(void)
+{
+	pr_info(MODULE_NAME ": Terminating " __stringify(__LINE__) "\n");
+	if(curr_data) {
+		vfree(curr_data);
+		curr_data = NULL;
+	}
+}
+
+/* Initialize at level 5 (fs).  This is after subsys (#4), so nvmem is
+ * available, and is before device (#6), when devices are initialized based on
+ * the DTB state. */
+
+fs_initcall(config_eeprom_init);
+module_exit(config_eeprom_exit);
+
+MODULE_DESCRIPTION("Driver that accesses a configuration EEPROM.");
+MODULE_AUTHOR("Christopher White <cwhite@d3engineering.com>");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/d3/early-at24/Kconfig b/drivers/d3/early-at24/Kconfig
new file mode 100644
index 000000000000..2b53ad27a76e
--- /dev/null
+++ b/drivers/d3/early-at24/Kconfig
@@ -0,0 +1,6 @@
+config D3_EARLY_AT24
+	bool "EEPROM driver for D3 CIC (AT24-compatible)"
+	depends on NVMEM
+	help
+	  D3 Permits reading configuration from an AT24-compatible EEPROM,
+	  such as the 24AA1026 on the D3 Camera Interface Card.
diff --git a/drivers/d3/early-at24/Makefile b/drivers/d3/early-at24/Makefile
new file mode 100644
index 000000000000..0aa378008684
--- /dev/null
+++ b/drivers/d3/early-at24/Makefile
@@ -0,0 +1,18 @@
+# -*-makefile-*-
+obj-$(CONFIG_D3_EARLY_AT24) += early-at24-generated.o
+
+# We are copying and modifying the kernel's at24.c.
+orig_at24 = $(srctree)/drivers/misc/eeprom/at24.c
+modified_at24 = $(obj)/early-at24-generated.c
+
+# The script that makes the modifications
+sed_script = $(srctree)/$(src)/modify-at24.sed
+
+# How to make the generated file
+quiet_cmd_early_at24 = CONVERT $@
+      cmd_early_at24 = sed -E -f "$(sed_script)" "$<" > "$@"
+
+$(obj)/early-at24-generated.o: $(modified_at24)
+
+$(modified_at24): $(orig_at24) $(sed_script)
+	$(call cmd,early_at24)
diff --git a/drivers/d3/early-at24/modify-at24.sed b/drivers/d3/early-at24/modify-at24.sed
new file mode 100644
index 000000000000..14e9bef2682e
--- /dev/null
+++ b/drivers/d3/early-at24/modify-at24.sed
@@ -0,0 +1,44 @@
+# modify-at24.sed: sed script to modify at24.c to produce early-at24.c.
+# Run with `sed -E`.
+#
+# Copyright (c) 2019, D3 Engineering  All rights reserved.
+# Author: Christopher White <cwhite@d3engineering.com>
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms and conditions of the GNU General Public License,
+# version 2, as published by the Free Software Foundation.
+#
+# This program is distributed in the hope it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+# more details.
+
+# Identifiers: change prefix at24_
+s|\bat24_|early_at24_|g
+
+# Exceptions
+s|\bearly_at24_platform_data\b|at24_platform_data|g
+
+# Kernel messages
+s|\bat24:|early_at24:|g
+
+# Kernel command-line parameters
+s|\bio_limit\b|early_at24_io_limit|g
+s|\bwrite_timeout\b|early_at24_write_timeout|g
+
+# The I2C device IDs.  Not a global search - only replace the first " on
+# each line.
+/i2c_device_id.*\[\]/,/^\s*\};/s|"|"early|
+
+# I2C driver name
+s|\.name\s*=\s*"at24"|.name = "early_at24"|
+
+# Cause the early_at24 driver to be loaded early at level 5 (fs).
+# This is after subsys (#4), so nvmem is available, and is before device (#6),
+# when devices are initialized based on the DTB state. */
+
+s|^\s*module_init\(|fs_initcall\(|
+
+# Change the module description
+s|^\s*MODULE_DESCRIPTION\([^\)]+\)|MODULE_DESCRIPTION("AT24 driver, but loaded at fs_initcall time")|
+
diff --git a/drivers/d3/imx390/Kconfig b/drivers/d3/imx390/Kconfig
new file mode 100644
index 000000000000..b14b26a77687
--- /dev/null
+++ b/drivers/d3/imx390/Kconfig
@@ -0,0 +1,9 @@
+config D3_IMX390
+	tristate "IMX390 Camera Driver"
+	help
+	  D3 IMX390 Camera Driver for Nvidia Tegra systems.
+config D3_IMX390_HDR_ENABLE
+    bool "IMX390 HDR Mode"
+    depends on D3_IMX390
+    help
+      Enable HDR mode for D3 imx390 driver
diff --git a/drivers/d3/imx390/Makefile b/drivers/d3/imx390/Makefile
new file mode 100644
index 000000000000..9ee343955bee
--- /dev/null
+++ b/drivers/d3/imx390/Makefile
@@ -0,0 +1,14 @@
+# -*-makefile-*-
+imx390-objs	:= \
+	imx390-main.o \
+	imx390-modes.o \
+	imx390-mode-1936x1100-SP1L.o \
+	imx390-mode-1936x1100-SP1H.o \
+	imx390-mode-1936x1100-SP2.o
+
+ifeq ($(CONFIG_D3_IMX390_HDR_ENABLE),y)
+	imx390-objs += imx390-mode-1936x1100-HDR.o
+endif
+
+obj-$(CONFIG_D3_IMX390) += imx390.o
+
diff --git a/drivers/d3/imx390/imx390-main.c b/drivers/d3/imx390/imx390-main.c
new file mode 100644
index 000000000000..116a6292a1fe
--- /dev/null
+++ b/drivers/d3/imx390/imx390-main.c
@@ -0,0 +1,1204 @@
+/**
+ * @author Greg Rowe <growe@d3engineering.com>
+ *
+ * imx390 v4l2 driver for Nvidia Jetson
+ *
+ * Copyright (c) 2018-2019, D3 Engineering.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+#include <linux/module.h>
+#include <linux/of_device.h>
+
+#include <media/camera_common.h>
+
+#include <d3/d3-jetson-bsp.h>
+#include <d3/ub960.h>
+
+#include "imx390-modes.h"
+
+
+/**
+ * If @p expr evalutes to non-zero assign it to @p err and return @p err
+ */
+#define TRY(err, expr) if(((err) = (expr))) { return (err); }
+
+
+
+
+/**
+ * Register addresses (see data sheet/register map)
+ */
+enum {
+	IMX390_REG_STANDBY = 0x0000,
+	IMX390_REG_REG_HOLD = 0x0008,
+	IMX390_REG_SHS1 = 0x000c,
+	IMX390_REG_SHS2 = 0x0010,
+	IMX390_REG_AGAIN_SP1H = 0x0018,
+	IMX390_REG_AGAIN_SP1L = 0x001a,
+	IMX390_REG_OBB_CLAMP_CTRL_SEL = 0x0083,
+	IMX390_REG_REV1 = 0x3060,
+	IMX390_REG_REV2 = 0x3064,
+	IMX390_REG_REV3 = 0x3067,
+	IMX390_REG_REAR_EMBDATA_LINE = 0x2E18,
+};
+
+
+/**
+ * The 390 has 16 bit addresses and 8 bit values.
+ */
+static struct regmap_config imx390_regmap_cfg = {
+	.reg_bits = 16,
+	.val_bits = 8,
+};
+
+
+/**
+ * The is the imx390 driver class. Some of the pointers are not
+ * strictly needed as they can be obtained via things like
+ * 'client'. These pointers exist for convenience.
+ */
+struct imx390 {
+	struct camera_common_power_rail	power;
+
+	struct i2c_client *client;
+	struct device *dev;
+	struct regmap *map;
+
+	struct camera_common_data *s_data;
+	struct camera_common_pdata *pdata;
+	bool hflip;
+	bool vflip;
+
+	u32 frame_length;
+	s64 last_wdr_et_val;
+
+	struct media_pad pad;
+	struct v4l2_ctrl_handler ctrl_handler;
+	struct v4l2_subdev *subdev;
+	struct i2c_client *deserializer;
+
+	/* @todo don't use this feature of C here, it's not necessary */
+	struct v4l2_ctrl *ctrls[];
+};
+
+
+static int imx390_g_volatile_ctrl(struct v4l2_ctrl *ctrl);
+static int imx390_s_ctrl(struct v4l2_ctrl *ctrl);
+static const struct v4l2_ctrl_ops imx390_ctrl_ops = {
+	.g_volatile_ctrl = imx390_g_volatile_ctrl,
+	.s_ctrl = imx390_s_ctrl,
+};
+
+
+static struct v4l2_ctrl_config ctrl_config_list[] = {
+	{
+		.ops = &imx390_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_SENSOR_MODE_ID,
+		.name = "Sensor Mode",
+		.type = V4L2_CTRL_TYPE_INTEGER64,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = 0,
+		.max = IMX390_MODE_ENDMARKER - 1,
+		.def = IMX390_MODE_DEFAULT,
+		.step = 1,
+	},
+	{			/* 0 */
+		.ops = &imx390_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_GAIN,
+		.name = "Gain",
+		.type = V4L2_CTRL_TYPE_INTEGER64,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = 0 * FIXED_POINT_SCALING_FACTOR,
+		.max = 30 * FIXED_POINT_SCALING_FACTOR,
+		.def = 0 * FIXED_POINT_SCALING_FACTOR,
+		.step = 3 * FIXED_POINT_SCALING_FACTOR / 10, /* 0.3 db */
+	},
+	{			/* 1 */
+		.ops = &imx390_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_FRAME_RATE,
+		.name = "Frame Rate",
+		.type = V4L2_CTRL_TYPE_INTEGER64,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = 30 * FIXED_POINT_SCALING_FACTOR,
+		.max = 60 * FIXED_POINT_SCALING_FACTOR,
+		.def = 60 * FIXED_POINT_SCALING_FACTOR,
+		.step = 1 * FIXED_POINT_SCALING_FACTOR,
+	},
+	{			/* 2 */
+		.ops = &imx390_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_EXPOSURE,
+		.name = "Exposure",
+		.type = V4L2_CTRL_TYPE_INTEGER64,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		/* 30 us  */
+		.min = 30 * FIXED_POINT_SCALING_FACTOR / 1000000,
+		/* 33.3 ms */
+		.max = 33333 * FIXED_POINT_SCALING_FACTOR / 1000000,
+		/* 30 ms */
+		.def = 11000 * FIXED_POINT_SCALING_FACTOR / 1000000,
+		/* Microsecond steps (should probably be in units of
+		 * lines */
+		.step = 1 * FIXED_POINT_SCALING_FACTOR / 1000000,
+	},
+	{			/* 3 */
+		.ops = &imx390_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_GROUP_HOLD,
+		.name = "Group Hold",
+		.type = V4L2_CTRL_TYPE_INTEGER_MENU,
+		.min = 0,
+		.max = ARRAY_SIZE(switch_ctrl_qmenu) - 1,
+		.menu_skip_mask = 0,
+		.def = 0,
+		.qmenu_int = switch_ctrl_qmenu,
+	},
+	{			/* 4 */
+		.ops = &imx390_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_HDR_EN,
+		.name = "HDR enable",
+		.type = V4L2_CTRL_TYPE_INTEGER_MENU,
+		.min = 0,
+		.max = ARRAY_SIZE(switch_ctrl_qmenu) - 1,
+		.menu_skip_mask = 0,
+		.def = 0,
+		.qmenu_int = switch_ctrl_qmenu,
+	},
+};
+
+
+/* Standard controls:
+
+   V4L2_CID_HFLIP
+   V4L2_CID_VFLIP
+
+*/
+
+#define NUM_CUSTOM_CONTROLS	ARRAY_SIZE(ctrl_config_list)
+#define NUM_STD_CONTROLS	(2)
+#define NUM_CONTROLS		(NUM_CUSTOM_CONTROLS + NUM_STD_CONTROLS)
+
+
+/**
+ * Reads a single register from the sensor and prints it.
+ *
+ * @param self
+ * @param addr which register
+ * @param out where to store result
+ *
+ * @return 0 on success
+ */
+static int imx390_reg_read(struct imx390 *self, u16 addr, u8 *out)
+{
+	int err = 0;
+	unsigned int val = 0;
+	if ((err = regmap_read(self->map, addr, &val))) {
+		dev_warn(self->dev, "regmap_read returned %d", err);
+		return err;
+	}
+	*out = val;
+	dev_dbg(self->dev, "read: %#.4x=%#.2x", addr, *out);
+	return 0;
+}
+
+
+/**
+ * This is part of Nvidia camera_common framework. They create a file
+ * in sysfs that you can use to read and write registers. That hooks
+ * into this.
+ *
+ * @param s_data
+ * @param addr address to read
+ * @param val where to store value
+ *
+ * @return 0 on success
+ */
+static int imx390_read_reg(struct camera_common_data *s_data, u16 addr, u8 *val)
+{
+	int err = 0;
+	struct imx390 *self = s_data->priv;
+
+	TRY(err, imx390_reg_read(self, addr, val));
+	return 0;
+}
+
+
+/**
+ * This is part of Nvidia camera_common framework. They create a file
+ * in sysfs that you can use to read and write registers. That hooks
+ * into this.
+ *
+ * @param s_data
+ * @param addr address to write
+ * @param val what to write
+ *
+ * @return 0 on success
+ */
+static int imx390_write_reg(struct camera_common_data *s_data, u16 addr, u8 val)
+{
+	int err = 0;
+	struct imx390 *self = s_data->priv;
+
+	TRY(err, regmap_write(self->map, addr, val));
+	return 0;
+}
+
+
+static int imx390_mode_set(struct imx390 *self, enum imx390_mode mode)
+{
+	/* This entire function is a hack and I only allow it because
+	 * it's for debugging purposes. */
+	int err = 0;
+	struct imx390_modes_map *pmode = NULL;
+
+	if ((mode < 0)
+	    || (mode > IMX390_MODE_ENDMARKER)) {
+		dev_err(self->dev, "invalid mode %d (0-4)", mode);
+		return -EINVAL;
+	}
+	pmode = &imx390_modes_map[mode];
+	dev_info(self->dev, "setting mode: %s\n", pmode->desc);
+	TRY(err, regmap_multi_reg_write(self->map, pmode->vals, *pmode->n_vals));
+	return 0;
+}
+
+
+static int imx390_set_hflip_raw(struct imx390 *self, s32 val)
+{
+	int err;
+	TRY(err, regmap_update_bits(self->map, 0x74, 1 << 1, (val & 1) << 1));
+	TRY(err, regmap_update_bits(self->map, 0x3C0, 1 << 3, (val & 1) << 3));
+	return 0;
+}
+
+
+static int imx390_set_vflip_raw(struct imx390 *self, s32 val)
+{
+	int err;
+	TRY(err, regmap_update_bits(self->map, 0x74, 1 << 0, (val & 1) << 0));
+	TRY(err, regmap_update_bits(self->map, 0x3C0, 1 << 2, (val & 1) << 2));
+	return 0;
+}
+
+
+/**
+ * This is called to start the stream. Currently this doesn't really
+ * do anything other than log start/stop.
+ *
+ * @param sd sub device
+ * @param enable enable/disable stream
+ *
+ * @return
+ */
+static int imx390_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	int err = 0;
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_common_data *s_data = to_camera_common_data(&client->dev);
+	struct imx390 *self = (struct imx390 *)s_data->priv;
+	int mode_ix = self->s_data->sensor_mode_id;
+
+	dev_dbg(self->dev, "%s", enable ? "START" : "STOP");
+
+	if (self->deserializer) {
+		ub960_s_stream(self->deserializer, self->client, enable);
+	}
+
+	if (enable) {
+		TRY(err, imx390_mode_set(self, mode_ix));
+
+		if (self->hflip)
+			imx390_set_hflip_raw(self, self->hflip);
+		if (self->vflip)
+			imx390_set_vflip_raw(self, self->vflip);
+	}
+
+	TRY(err, regmap_write(self->map, IMX390_REG_STANDBY, enable ? 0:1));
+	return 0;
+}
+
+
+/**
+ * I am not sure what the intent of this function is.
+ *
+ * @param sd sub device
+ * @param status
+ *
+ * @return 0, always
+ */
+static int imx390_g_input_status(struct v4l2_subdev *sd, u32 *status)
+{
+	return 0;
+}
+
+
+/**
+ * Called by Linux when unloading the driver instance.
+ *
+ * @param client which instance
+ *
+ * @return 0, always
+ */
+static int imx390_remove(struct i2c_client *client)
+{
+	struct device *dev = &client->dev;
+	dev_dbg(dev, "removed");
+	return 0;
+}
+
+
+static const struct i2c_device_id imx390_id[] = {
+	{"imx390", 0},
+	{}
+};
+MODULE_DEVICE_TABLE(i2c, imx390_id);
+
+
+static struct v4l2_subdev_video_ops imx390_subdev_video_ops = {
+	.s_stream	= imx390_s_stream,
+	.g_mbus_config	= camera_common_g_mbus_config,
+	.g_input_status	= imx390_g_input_status,
+};
+
+
+static struct v4l2_subdev_core_ops imx390_subdev_core_ops = {
+	.s_power	= camera_common_s_power,
+};
+
+
+static int imx390_power_on(struct camera_common_data *s_data)
+{
+	/* int err = 0; */
+	struct imx390 *priv = (struct imx390 *)s_data->priv;
+	struct camera_common_power_rail *pw = &priv->power;
+
+	dev_dbg(priv->dev, "%s: power on\n", __func__);
+	pw->state = SWITCH_ON;
+	return 0;
+}
+
+
+static int imx390_power_off(struct camera_common_data *s_data)
+{
+	/* int err = 0; */
+	struct imx390 *priv = (struct imx390 *)s_data->priv;
+	struct camera_common_power_rail *pw = &priv->power;
+
+	dev_dbg(priv->dev, "%s: power off\n", __func__);
+	pw->state = SWITCH_OFF;
+	return 0;
+}
+
+
+/**
+ * v4l2 set and tryset format handler
+ *
+ * @param sd sub dev
+ * @param cfg
+ * @param format format to attempt to set or to set
+ *
+ * @return 0 on success
+ */
+static int imx390_set_fmt(struct v4l2_subdev *sd,
+                          struct v4l2_subdev_pad_config *cfg,
+                          struct v4l2_subdev_format *format)
+{
+	/* struct camera_common_data *s_data = to_camera_common_data(sd->dev); */
+	int err = 0;
+
+	if (format->which == V4L2_SUBDEV_FORMAT_TRY) {
+		TRY(err, camera_common_try_fmt(sd, &format->format));
+	}
+	else {
+		TRY(err, camera_common_s_fmt(sd, &format->format));
+	}
+	return 0;
+}
+
+
+/**
+ * Returns the active format
+ *
+ * @param sd sub dev
+ * @param cfg
+ * @param format output - the active format
+ *
+ * @return
+ */
+static int imx390_get_fmt(struct v4l2_subdev *sd,
+                          struct v4l2_subdev_pad_config *cfg,
+                          struct v4l2_subdev_format *format)
+{
+	return camera_common_g_fmt(sd, &format->format);
+}
+
+
+static struct v4l2_subdev_pad_ops imx390_subdev_pad_ops = {
+	.set_fmt	     = imx390_set_fmt,
+	.get_fmt	     = imx390_get_fmt,
+	.enum_mbus_code	     = camera_common_enum_mbus_code,
+	.enum_frame_size     = camera_common_enum_framesizes,
+	.enum_frame_interval = camera_common_enum_frameintervals,
+};
+
+
+static struct v4l2_subdev_ops imx390_subdev_ops = {
+	.core  = &imx390_subdev_core_ops,
+	.video = &imx390_subdev_video_ops,
+	.pad   = &imx390_subdev_pad_ops,
+};
+
+
+static struct of_device_id imx390_of_match[] = {
+	{ .compatible = "d3,imx390"},
+	{ },
+};
+MODULE_DEVICE_TABLE(of, imx390_of_match);
+
+
+/**
+ * These are for debugging. The Nvidia camera_common code creates a
+ * file in sysfs to read and write the image sensor.
+ */
+static struct camera_common_sensor_ops imx390_common_ops = {
+	.power_on = imx390_power_on,
+	.power_off = imx390_power_off,
+	.write_reg = imx390_write_reg,
+	.read_reg  = imx390_read_reg,
+};
+
+
+/**
+ * Initializes v4l2 controls (taken from example code).
+ */
+static int imx390_ctrls_init(struct imx390 *self)
+{
+	struct v4l2_ctrl *ctrl;
+	int err;
+	int custom_index;
+	int ctrl_index;
+
+	dev_dbg(self->dev, "%s++", __func__);
+
+	v4l2_ctrl_handler_init(&self->ctrl_handler, NUM_CONTROLS);
+
+	ctrl_index = 0;
+	ctrl = v4l2_ctrl_new_std(&self->ctrl_handler, &imx390_ctrl_ops, V4L2_CID_HFLIP, 0, 1, 1, 0);
+	if (ctrl == NULL) {
+		dev_err(self->dev, "Error initializing standard control\n");
+		err = -EINVAL;
+		goto error;
+	}
+	self->ctrls[ctrl_index++] = ctrl;
+
+	ctrl = v4l2_ctrl_new_std(&self->ctrl_handler, &imx390_ctrl_ops, V4L2_CID_VFLIP, 0, 1, 1, 0);
+	if (ctrl == NULL) {
+		dev_err(self->dev, "Error initializing standard control\n");
+		err = -EINVAL;
+		goto error;
+	}
+	self->ctrls[ctrl_index++] = ctrl;
+
+	for (custom_index = 0;
+	     custom_index < NUM_CUSTOM_CONTROLS;
+	     custom_index++) {
+
+		ctrl = v4l2_ctrl_new_custom(&self->ctrl_handler,
+					    &ctrl_config_list[custom_index],
+					    NULL);
+		if (ctrl == NULL)
+		{
+			dev_err(self->dev, "Failed to init %s ctrl",
+				ctrl_config_list[custom_index].name);
+			continue;
+		}
+
+		if (ctrl_config_list[custom_index].type == V4L2_CTRL_TYPE_STRING &&
+		    ctrl_config_list[custom_index].flags & V4L2_CTRL_FLAG_READ_ONLY)
+		{
+			/* @todo should use imx390_kzalloc */
+			ctrl->p_new.p_char = devm_kzalloc(
+				self->dev,
+				ctrl_config_list[custom_index].max + 1, GFP_KERNEL);
+			if (!ctrl->p_new.p_char) {
+				err = -ENOMEM;
+				goto error;
+			}
+		}
+		self->ctrls[ctrl_index++] = ctrl;
+	}
+
+	BUG_ON(ctrl_index != NUM_CONTROLS);
+
+	self->subdev->ctrl_handler = &self->ctrl_handler;
+	if (self->ctrl_handler.error) {
+		dev_err(self->dev, "Error %d adding controls",
+			self->ctrl_handler.error);
+		err = self->ctrl_handler.error;
+		goto error;
+	}
+
+	if ((err = v4l2_ctrl_handler_setup(&self->ctrl_handler))) {
+		dev_err(self->dev, "Error %d setting default controls", err);
+		goto error;
+	}
+
+	return 0;
+
+error:
+	v4l2_ctrl_handler_free(&self->ctrl_handler);
+	return err;
+}
+
+
+/**
+ * Called when the device is opened. For example this is called when
+ * you execute `media-ctl -p` from userspace.
+ *
+ * @param sd sub device
+ * @param fh
+ *
+ * @return 0, always
+ */
+static int imx390_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	dev_dbg(&client->dev, "open");
+	return 0;
+}
+
+
+static const struct v4l2_subdev_internal_ops imx390_subdev_internal_ops = {
+	.open = imx390_open,
+};
+
+
+static const struct media_entity_operations imx390_media_ops = {
+	.link_validate = v4l2_subdev_link_validate,
+};
+
+
+static int imx390_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct imx390 *self =
+		container_of(ctrl->handler, struct imx390, ctrl_handler);
+
+	switch (ctrl->id)
+	{
+	default:
+		dev_err(self->dev, "%s: unknown ctrl id", __func__);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+
+/**
+ * Puts the sensor in (or takes out of) register group hold. This
+ * means that you can make changes to the sensor through multiple
+ * registers and have all of the changes activate at the same time.
+ *
+ * @param self driver instance
+ * @param val boolean enable or disable
+ *
+ * @return 0 on success
+ */
+static int imx390_group_hold_enable(struct imx390 *self, s32 val)
+{
+	/* dev_dbg(self->dev, "group hold: %d", val); */
+	return regmap_write(self->map, IMX390_REG_REG_HOLD, val ? 1:0);
+}
+
+
+static int imx390_is_hdr(struct imx390 *self)
+{
+	int mode_ix = self->s_data->sensor_mode_id;
+	return imx390_modes_formats[mode_ix].hdr_en;
+}
+
+
+/**
+ * Sets the gain using a raw register value to both SPI1H and SPI1L
+ *
+ * @param self driver instance
+ * @param gain raw register value written to SP1H and SP1L
+ *
+ * @return 0 on success
+ */
+static int imx390_gain_raw_set(struct imx390 *self, u16 gain)
+{
+	int err = 0;
+	/* This register holds an 11 bit value */
+	u16 masked = gain & 0x7ff;
+
+
+	/* This should never be called in HDR mode but we'll put check
+	 * in to be safe. */
+	if (imx390_is_hdr(self)) {
+		return 0;
+	}
+
+	dev_dbg(self->dev, "set gain: val=%#.2x", masked);
+
+	TRY(err, imx390_group_hold_enable(self, 1));
+
+	/* Set the analog gain registers. These are in .3 db steps. */
+	TRY(err, regmap_write(self->map, IMX390_REG_AGAIN_SP1H, masked & 0xff));
+	TRY(err, regmap_write(self->map, IMX390_REG_AGAIN_SP1H +1,
+			      (masked >> 8) & 0xff));
+	TRY(err, regmap_write(self->map, IMX390_REG_AGAIN_SP1L, masked & 0xff));
+	TRY(err, regmap_write(self->map, IMX390_REG_AGAIN_SP1L + 1,
+			      (masked >> 8) & 0xff));
+	TRY(err, imx390_group_hold_enable(self, 0));
+	return 0;
+}
+
+
+/**
+ * Takes fixed point (Q42.22) gain value in decibels and programs the
+ * image sensor.
+ *
+ * @param self driver instance
+ * @param val gain, in decibels, in Q42.22 fixed point format
+ *
+ * @return 0 on success
+ */
+static int imx390_gain_set(struct imx390 *self, s64 val)
+{
+	/* Specifies the gain values from the user mode library. */
+	/* It uses Q42.22 format (42 Bit integer, 22 Bit fraction). * */
+	/* See imx185_set_gain function in imx185.c file. */
+
+	/* imx390 gain is 0 to 30 in .3db steps. */
+	u16 gain = 0;
+
+
+	/* Gain is fixed for HDR mode. Sony recommends fixing exposure
+	 * to 11ms, and having two gains: one for low light conditions
+	 * and one for brighter conditions. We could add another HDR
+	 * mode to accommodate that. */
+	if (imx390_is_hdr(self)) {
+		return 0;
+	}
+
+	gain = val * 10 / 3 / FIXED_POINT_SCALING_FACTOR;
+
+	dev_dbg(self->dev, "gain: val=%#llx reg=%#x", val, gain);
+
+	if (gain > 100) {
+		dev_warn(self->dev, "invalid gain: reg=%#x", gain);
+		gain = 100;
+	}
+	return imx390_gain_raw_set(self, gain);
+}
+
+static int imx390_set_hflip(struct imx390 *self, s32 val)
+{
+	struct camera_common_power_rail *pw = &self->power;
+	self->hflip = val;
+	if (pw->state == SWITCH_ON)
+		return imx390_set_hflip_raw(self, val);
+	return 0;
+}
+
+
+static int imx390_set_vflip(struct imx390 *self, s32 val)
+{
+	struct camera_common_power_rail *pw = &self->power;
+	self->vflip = val;
+	if (pw->state == SWITCH_ON)
+		return imx390_set_vflip_raw(self, val);
+	return 0;
+}
+
+
+/**
+ * Sets the exposure time using a raw register value
+ *
+ * @param self driver instance
+ * @param exp exposure time register value
+ *
+ * @return 0 on success
+ */
+static int imx390_exposure_raw_set(struct imx390 *self, u32 exp)
+{
+	struct reg_sequence writes[6] = {0};
+	int err = 0;
+
+	/* This should never be called in HDR mode but we'll put check
+	 * in to be safe. */
+	if (imx390_is_hdr(self)) {
+		return 0;
+	}
+
+	dev_dbg(self->dev, "set exposure: reg=%#x", exp);
+	TRY(err, imx390_group_hold_enable(self, 1));
+
+	/* 20 bit value */
+	writes[0].def = exp & 0xff;
+	writes[1].def = (exp & 0xff00) >> 8;
+	writes[2].def = (exp & 0xf0000) >> 16;
+
+	/* 0xc, 0xd, 0xe */
+	writes[0].reg = IMX390_REG_SHS1;
+	writes[1].reg = IMX390_REG_SHS1 + 1;
+	writes[2].reg = IMX390_REG_SHS1 + 2;
+
+	/* 20 bit value */
+	writes[3].def = exp & 0xff;
+	writes[4].def = (exp & 0xff00) >> 8;
+	writes[5].def = (exp & 0xf0000) >> 16;
+
+	/* 0x10, 0x11, 0x12 */
+	writes[3].reg = IMX390_REG_SHS2;
+	writes[4].reg = IMX390_REG_SHS2 + 1;
+	writes[5].reg = IMX390_REG_SHS2 + 2;
+
+
+	/* True means to print the register values. This is a small
+	 * table so it's OK. */
+	TRY(err, regmap_multi_reg_write(self->map, writes, ARRAY_SIZE(writes)));
+	TRY(err, imx390_group_hold_enable(self, 0));
+	return 0;
+}
+
+
+/**
+ * Sets the exposure time using a fixed point time setting in Q42.22
+ * format.
+ *
+ * @param self driver instance
+ * @param val exposure time in seconds (see description)
+ *
+ * @return 0 on success
+ */
+static int imx390_exposure_set(struct imx390 *self, s64 val)
+{
+	u32 coarse_time;
+	u32 reg;
+	struct camera_common_data *s_data = self->s_data;
+	const struct sensor_mode_properties *mode =
+		&s_data->sensor_props.sensor_modes[s_data->mode];
+
+	/* Exposure is fixed at 11ms for HDR. */
+	if (imx390_is_hdr(self))
+		return 0;
+
+	/* This is figuring out how many lines are output for the
+	 * desired exposure time. */
+	/* pixel clock * TIME / line_length */
+	coarse_time = mode->signal_properties.pixel_clock.val *
+		val / mode->image_properties.line_length /
+		FIXED_POINT_SCALING_FACTOR;
+
+	/* The 390 is configured such that the SHS registers are the
+	 * difference between VMAX and the exposure time expressed as
+	 * lines.  */
+	/* FRAME_LENGTH is VMAX */
+	/* VMAX=1125 */
+	reg =  1125 - coarse_time;
+	/* The data sheet says values of 0 and 1 are prohibited...and
+	 * also says that the default value is 1... */
+	if (reg < 2) {
+		dev_warn(self->dev, "exposure out of range, setting to 2");
+		reg = 2;
+	}
+	else if (reg >= 0x100000) {
+		dev_warn(self->dev, "exposure out of range, setting to max");
+		reg = 0x100000 -1;
+	}
+
+	dev_dbg(self->dev,
+		"pixel clock=%lld"
+		", line-length=%d"
+		", frame-length=%d"
+		", coarse_time=%d"
+		", val=%lld"
+		", reg=%#x"
+		", sf=%lld"
+		,
+		mode->signal_properties.pixel_clock.val,
+		mode->image_properties.line_length,
+		1125,
+		coarse_time,
+		val,
+		reg,
+		FIXED_POINT_SCALING_FACTOR);
+
+	return imx390_exposure_raw_set(self, reg);
+}
+
+
+/**
+ * v4l2 control handler
+ *
+ * @param ctrl the v4l2 control
+ *
+ * @return 0 on success
+ */
+static int imx390_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct imx390 *self =
+		container_of(ctrl->handler, struct imx390, ctrl_handler);
+	int err = 0;
+
+	switch (ctrl->id) {
+	case TEGRA_CAMERA_CID_SENSOR_MODE_ID:
+		/* @todo we can't really change modes until we reset
+		 * the image sensor. The only way I can find to do
+		 * that is the xclr pin. While this isn't impossible
+		 * in a serdes configration it isn't easy right now. */
+		self->s_data->sensor_mode_id = *ctrl->p_new.p_s64;
+		return 0;
+	case V4L2_CID_HFLIP:
+		TRY(err, imx390_set_hflip(self, ctrl->val));
+		break;
+	case V4L2_CID_VFLIP:
+		TRY(err, imx390_set_vflip(self, ctrl->val));
+		break;
+	case TEGRA_CAMERA_CID_GAIN:
+		TRY(err, imx390_gain_set(self, *ctrl->p_new.p_s64));
+		break;
+	case TEGRA_CAMERA_CID_FRAME_RATE:
+		/* @todo do we need to implement this? */
+		return 0;
+		break;
+	case TEGRA_CAMERA_CID_EXPOSURE:
+		TRY(err, imx390_exposure_set(self, *ctrl->p_new.p_s64));
+		break;
+	case TEGRA_CAMERA_CID_GROUP_HOLD:
+		TRY(err, imx390_group_hold_enable(self, ctrl->val));
+		break;
+	case TEGRA_CAMERA_CID_HDR_EN:
+		break;
+	default:
+		dev_err(self->dev, "unknown ctrl id=%d", ctrl->id);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+
+/**
+ * Helper function that allocated device managed memory.
+ *
+ * @param dev device driver
+ * @param len desired amount of memory
+ * @param out where to store pointer
+ *
+ * @return 0 on success
+ */
+static int imx390_kzalloc(struct device *dev, size_t len, void *out)
+{
+	void **real_out = out;
+	if (!(*real_out = devm_kzalloc(dev, len, GFP_KERNEL))) {
+		dev_err(dev, "memory allocation failure");
+		return -ENOMEM;
+	}
+	return 0;
+}
+
+
+/**
+ * Allocates a device managed register map.
+ *
+ * @param client which i2c client to use
+ * @param cfg register map configuration
+ * @param out_map where to store instance
+ *
+ * @return 0 on success
+ */
+static int imx390_regmap_init(struct i2c_client *client,
+                              struct regmap_config *cfg,
+                              struct regmap **out_map)
+{
+	if (!(*out_map = devm_regmap_init_i2c(client, cfg))) {
+		dev_err(&client->dev, "regmap_init failed");
+		return -EINVAL;
+	}
+	return 0;
+}
+
+
+/**
+ * Prints the silicon revision
+ *
+ * @return 0 on success
+ */
+static int imx390_revision_report(struct imx390 *self)
+{
+	int err = 0;
+	/* It's time to make this a loop... */
+	u8 rev1 = 0xff;
+	u8 rev2 = 0xff;
+	u8 rev3 = 0xff;
+	int tries;
+
+	for (tries = 50; --tries >= 0; ) {
+		err = imx390_reg_read(self, IMX390_REG_REV1, &rev1);
+		if (err) {
+			usleep_range(10 * 1000, 10 * 1000);
+			continue;
+		}
+		err = imx390_reg_read(self, IMX390_REG_REV2, &rev2);
+		if (err) {
+			usleep_range(10 * 1000, 10 * 1000);
+			continue;
+		}
+		err = imx390_reg_read(self, IMX390_REG_REV3, &rev3);
+		if (err) {
+			usleep_range(10 * 1000, 10 * 1000);
+			continue;
+		}
+
+		dev_info(self->dev,
+			 "revision %#.2x = %#.2x, %#.2x = %#.2x %#.2x = %#.2x",
+			 IMX390_REG_REV1, rev1,
+			 IMX390_REG_REV2, rev2,
+			 IMX390_REG_REV3, rev3);
+		return 0;
+	}
+
+	return err;
+}
+
+
+static int imx390_deserializer_parse(struct imx390 *self,
+				     struct i2c_client **out)
+{
+	struct device_node *node = self->client->dev.of_node;
+	struct device_node *deserializer_node;
+	struct i2c_client *deserializer_client;
+
+	deserializer_node = of_parse_phandle(node, "deserializer", 0);
+	if (!deserializer_node) {
+		dev_dbg(self->dev, "could not find deserializer node");
+		return -ENOENT;
+	}
+
+	deserializer_client = of_find_i2c_device_by_node(deserializer_node);
+	of_node_put(deserializer_node);
+	deserializer_node = NULL;
+
+	if (!deserializer_client) {
+		dev_dbg(self->dev, "missing deserializer client");
+		return -ENOENT;
+	}
+
+	*out = deserializer_client;
+	return 0;
+}
+
+/**
+ * Pull parameters from device tree.
+ *
+ * @param s_data camera common data (for Nvidia layers)
+ *
+ * @return 0 on success
+ */
+static struct camera_common_pdata *imx390_parse_dt(
+	struct imx390 *self,
+	struct camera_common_data *s_data)
+{
+	struct device_node *node = self->client->dev.of_node;
+	struct camera_common_pdata *board_priv_pdata;
+	const struct of_device_id *match;
+	int err;
+
+	if (!node) {
+		dev_err(self->dev, "no OF node");
+		return NULL;
+	}
+
+	match = of_match_device(imx390_of_match, self->dev);
+	if (!match) {
+		dev_err(self->dev, "Failed to find matching dt id");
+		return NULL;
+	}
+
+	board_priv_pdata = devm_kzalloc(self->dev,
+					sizeof(*board_priv_pdata), GFP_KERNEL);
+
+	err = of_property_read_string(node, "mclk",
+				      &board_priv_pdata->mclk_name);
+	if (err)
+		dev_warn(self->dev, "mclk not in DT");
+
+	if (imx390_deserializer_parse(self, &self->deserializer) == 0) {
+		dev_dbg(self->dev, "deserializer present");
+	}
+	else {
+		self->deserializer = NULL;
+	}
+
+	return board_priv_pdata;
+}
+
+
+/**
+ * Initializes media controller
+ *
+ * @param self driver instance
+ *
+ * @return 0 on success
+ */
+static int imx390_media_init(struct imx390 *self)
+{
+	int err = 0;
+#if defined(CONFIG_MEDIA_CONTROLLER)
+	self->pad.flags = MEDIA_PAD_FL_SOURCE;
+	self->subdev->entity.ops = &imx390_media_ops;
+	/* The media controller code is slightly different on Tx2
+	 * (kernel 4.4) vs. on Xavier (kernel 4.9) */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 9, 0)
+	self->subdev->entity.type = MEDIA_ENT_T_V4L2_SUBDEV_SENSOR;
+	err = media_entity_init(&self->subdev->entity, 1, &self->pad, 0);
+#else
+	err = tegra_media_entity_init(&self->subdev->entity, 1,
+				      &self->pad, true, true);
+#endif	/* LINUX_VERSION */
+	if (err < 0) {
+		dev_err(self->dev, "unable to init media entity");
+		return err;
+	}
+#endif	/* CONFIG_MEDIA_CONTROLLER */
+	return 0;
+}
+
+
+/**
+ * This is called by the kernel when a new instance of the driver is
+ * instantiated.
+ *
+ * @param client i2c client device
+ * @param id
+ *
+ * @return 0 on success
+ */
+static int imx390_probe(struct i2c_client *client,
+                        const struct i2c_device_id *id)
+{
+	int err = 0;
+	struct camera_common_data *common_data;
+	struct device_node *node = client->dev.of_node;
+	struct imx390 *self = NULL;
+
+	dev_dbg(&client->dev, "probe");
+
+	if (!IS_ENABLED(CONFIG_OF) || !node) {
+		return -EINVAL;
+	}
+
+	TRY(err, imx390_kzalloc(&client->dev,
+				sizeof(*common_data),
+				&common_data));
+
+	TRY(err, imx390_kzalloc(&client->dev,
+				sizeof(*self) + sizeof(struct v4l2_ctrl *) *
+				NUM_CONTROLS,
+				&self));
+	self->client = client;
+	self->dev = &client->dev;
+
+	common_data->priv = self;
+	common_data->ops = &imx390_common_ops;
+	common_data->ctrl_handler = &self->ctrl_handler;
+	common_data->dev = &client->dev;
+	common_data->frmfmt = &imx390_modes_formats[0];
+	common_data->colorfmt =
+		camera_common_find_datafmt(MEDIA_BUS_FMT_SRGGB12_1X12);
+
+	/* struct dentry				*debugdir; */
+	/* common_data->debugdir = ; */
+	common_data->power = &self->power;
+	/* struct v4l2_subdev			subdev; */
+	/* common_data->subdev = ; */
+	common_data->ctrls = self->ctrls;
+	/* struct sensor_properties		sensor_props; */
+	/* common_data->sensor_props = ; */
+
+	common_data->priv = self;
+	common_data->numctrls = NUM_CONTROLS;
+	/* handled by camera_common_initialize */
+	/* common_data->csi_port = ; */
+	/* common_data->numlanes = ; */
+
+	/* handled in camera_common_try_fmt */
+	/* common_data->mode = ; */
+	/* common_data->mode_prop_idx; */
+
+	common_data->numfmts = imx390_modes_formats_len;
+	dev_dbg(self->dev, "num fmts %d", common_data->numfmts);
+	common_data->def_mode = IMX390_MODE_DEFAULT;
+	common_data->def_width =
+		common_data->frmfmt[IMX390_MODE_DEFAULT].size.width;
+	common_data->def_height =
+		common_data->frmfmt[IMX390_MODE_DEFAULT].size.height;
+	/* I'm assuming this is the default pixel clock */
+	common_data->def_clk_freq = 1485000;
+	common_data->fmt_width = common_data->def_width;
+	common_data->fmt_height = common_data->def_height;
+
+	self->s_data = common_data;
+	self->subdev = &common_data->subdev;
+	self->subdev->dev = self->dev;
+	self->s_data->dev = self->dev;
+	self->s_data->mode = IMX390_MODE_DEFAULT;
+
+	self->pdata = imx390_parse_dt(self, common_data);
+	if (!self->pdata)
+		return -EFAULT;
+
+	TRY(err, imx390_regmap_init(self->client,
+				    &imx390_regmap_cfg,
+				    &self->map));
+	TRY(err, imx390_revision_report(self));
+
+	TRY(err, camera_common_initialize(common_data, "imx390"));
+
+	v4l2_i2c_subdev_init(self->subdev, client, &imx390_subdev_ops);
+	TRY(err, imx390_ctrls_init(self));
+
+	self->subdev->internal_ops = &imx390_subdev_internal_ops;
+	self->subdev->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE |
+		V4L2_SUBDEV_FL_HAS_EVENTS;
+
+	TRY(err, imx390_media_init(self));
+	TRY(err, v4l2_async_register_subdev(self->subdev));
+
+	TRY(err, regmap_write(self->map, IMX390_REG_STANDBY, 1));
+	dev_dbg(self->dev, "probe success");
+	return 0;
+}
+
+
+/**
+ * Linux driver data
+ */
+static struct i2c_driver imx390_driver = {
+	.driver = {
+		.name = "imx390",
+		.owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(imx390_of_match),
+	},
+	.probe = imx390_probe,
+	.remove = imx390_remove,
+	.id_table = imx390_id,
+};
+module_i2c_driver(imx390_driver);
+
+MODULE_DESCRIPTION("Driver for D3's Sony IMX390 camera for Nvidia Jetson");
+MODULE_VERSION(D3_JETSON_BSP_VERSION);
+MODULE_AUTHOR("Greg Rowe <growe@d3engineering.com>");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/d3/imx390/imx390-mode-1936x1100-HDR.c b/drivers/d3/imx390/imx390-mode-1936x1100-HDR.c
new file mode 100644
index 000000000000..1cb677626182
--- /dev/null
+++ b/drivers/d3/imx390/imx390-mode-1936x1100-HDR.c
@@ -0,0 +1,4492 @@
+/**
+ * @author Greg Rowe <growe@d3engineering.com>
+ *
+ * imx390 v4l2 driver for Nvidia Jetson
+ *
+ * Copyright (c) 2018-2019, D3 Engineering.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+#include "imx390-mode-1936x1100-HDR.h"
+
+/**
+ * This configuration was supplied by Sony for HDR. The only real
+ * modification we (D3) made was to disable the rear embedded data
+ * line.
+ */
+const struct reg_sequence imx390_mode_1936x1100HDR[] = {
+	{0x2E18, 0x00},		/* disable rear embedded data line */
+	{0x000C,0x7F},
+	{0x000D,0x01},
+	{0x000E,0x00},
+	{0x0010,0x7F},
+	{0x0011,0x01},
+	{0x0012,0x00},
+	{0x0018,0x1C},              /* SPI1H Analog Gain: 30dB would be 24
+				     * bpp depth, 8.4 dB would be 20 bpp
+				     * of dynamic depth. */
+	{0x0019,0x00},
+	{0x001A,0x0C},              /* SPIL Analog Gain */
+	{0x001B,0x00},
+	{0x0038,0x00},		/* set to 1 to disable clamp */
+	{0x003C,0x00},
+	{0x003D,0x00},
+	{0x003E,0x00},
+	{0x0040,0x00},
+	{0x0041,0x00},
+	{0x0042,0x00},
+	{0x0044,0x00},
+	{0x0045,0x00},
+	{0x0046,0x00},
+	{0x0048,0x00},
+	{0x0049,0x00},
+	{0x004A,0x00},
+	{0x004C,0x00},
+	{0x004D,0x00},
+	{0x004E,0x00},
+	{0x0050,0x00},
+	{0x0051,0x00},
+	{0x0052,0x00},
+	{0x0054,0x00},
+	{0x0055,0x00},
+	{0x0056,0x00},
+	{0x0058,0x00},
+	{0x0059,0x00},
+	{0x005A,0x00},
+	{0x005C,0x00},
+	{0x005D,0x00},
+	{0x005E,0x00},
+	{0x0060,0x00},
+	{0x0061,0x00},
+	{0x0062,0x00},
+	{0x0064,0x00},
+	{0x0065,0x00},
+	{0x0066,0x00},
+	{0x0068,0x00},
+	{0x0069,0x00},
+	{0x006A,0x00},
+	{0x0078,0x00},
+	{0x007C,0x00},
+	{0x007D,0x00},
+	{0x0080,0x00},
+	{0x0081,0x00},
+	{0x0090,0x00},
+	{0x00F4,0x1C},
+	{0x00F5,0xF8},
+	{0x00F6,0x01},
+	{0x00F8,0x03},
+	{0x00F9,0x01},
+	{0x00FA,0x00},
+	{0x00FB,0x02},
+	{0x0114,0x00},
+	{0x0115,0x01},
+	{0x0118,0x20},
+	{0x0119,0x03},
+	{0x011A,0x00},
+	{0x011B,0x41},
+	{0x011C,0x80},
+	{0x011D,0x00},
+	{0x0120,0x20},
+	{0x0121,0x00},
+	{0x0122,0x00},
+	{0x0123,0x44},
+	{0x0124,0x00},
+	{0x0125,0x01},
+	{0x0128,0xAC},
+	{0x0129,0x0D},
+	{0x012A,0x00},
+	{0x012B,0xA4},
+	{0x012C,0x00},
+	{0x012D,0x01},
+	{0x0130,0xC4},
+	{0x0131,0x09},
+	{0x0132,0x00},
+	{0x0133,0xDA},
+	{0x013A,0x00},
+	{0x013B,0x00},
+	{0x013C,0x00},
+	{0x013D,0x00},
+	{0x013E,0x00},
+	{0x0140,0x00},
+	{0x0141,0x00},
+	{0x0142,0x00},
+	/* {0x0144,0x80},		/\* cp1_x 0x180 (384)*\/ */
+	/* {0x0145,0x01}, */
+	/* {0x0146,0x00}, */
+	/* {0x0148,0x80},		/\* cp1_y 0x180 (384) *\/ */
+	/* {0x0149,0x01}, */
+	/* {0x014A,0x00}, */
+	/* {0x014C,0x40},		/\* cp2_x 0x640 (1600) *\/ */
+	/* {0x014D,0x06}, */
+	/* {0x014E,0x00}, */
+	/* {0x0150,0x15},		/\* cp2_y 0x315 (789) *\/ */
+	/* {0x0151,0x03}, */
+	/* {0x0152,0x00}, */
+	/* {0x0154,0x74},		/\* cp3_x  0xe74 (3700)*\/ */
+	/* {0x0155,0x0E}, */
+	/* {0x0156,0x00}, */
+	/* {0x0158,0xFE},		/\* cp3_y 0x3fe (1022) *\/ */
+	/* {0x0159,0x03}, */
+	/* {0x015A,0x00}, */
+	/* {0x015C,0xC0},		/\* cp4_x 0x5dc0 (2400) *\/ */
+	/* {0x015D,0x5D}, */
+	/* {0x015E,0x00}, */
+	/* {0x0160,0xFE},		/\* cp4_y 0x4fe (1278) *\/ */
+	/* {0x0161,0x04}, */
+	/* {0x0162,0x00}, */
+	/* {0x0164,0x28},		/\* cp5_x 0x11d28 (73000)*\/ */
+	/* {0x0165,0x1D}, */
+	/* {0x0166,0x01}, */
+	/* {0x0168,0x32},		/\* cp5_y 0x632 (1586) *\/ */
+	/* {0x0169,0x06}, */
+	/* {0x016A,0x00}, */
+	/* {0x016C,0xD8},		/\* cp6_x 0x335d8 (210392) *\/ */
+	/* {0x016D,0x35}, */
+	/* {0x016E,0x03}, */
+	/* {0x0170,0xE3},		/\* cp6_y 0x7e3 (2019)*\/ */
+	/* {0x0171,0x07}, */
+	/* {0x0172,0x00}, */
+	/* {0x0174,0x60},		/\* cp7_x 0x16e360 (1500000) *\/ */
+	/* {0x0175,0xE3}, */
+	/* {0x0176,0x16}, */
+	/* {0x0178,0x6F},		/\* cp7_y 0x96f (2415) *\/ */
+	/* {0x0179,0x09}, */
+	/* {0x017A,0x00}, */
+	/* {0x017C,0x40},		/\* cp8_x 0x4c4b40 (5000000)*\/ */
+	/* {0x017D,0x4B}, */
+	/* {0x017E,0x4C}, */
+	/* {0x0180,0x87},		/\* cp8_y 0xb87 (2951) *\/ */
+	/* {0x0181,0x0B}, */
+	/* {0x0182,0x00}, */
+	/* {0x0184,0xFF},		/\* cp9_x 0xffffff (16777215) *\/ */
+	/* {0x0185,0xFF}, */
+	/* {0x0186,0xFF}, */
+	/* {0x0188,0x0E},		/\* cp9_y 0xf0e (3854) *\/ */
+	/* {0x0189,0x0F}, */
+	/* {0x018A,0x00}, */
+	/* {0x018C,0xFF},		/\* cp10_x 0xffffff (16777215) *\/ */
+	/* {0x018D,0xFF}, */
+	/* {0x018E,0xFF}, */
+	/* {0x0190,0x0E},		/\* cp10_y 0xf0e (3854) *\/ */
+	/* {0x0191,0x0F}, */
+	/* {0x0192,0x00}, */
+
+        {0x0144,0xda},		/* cp1_x 0x1da (474)*/
+	{0x0145,0x01},
+	{0x0146,0x00},
+	{0x0148,0xda},		/* cp1_y 0x1da (474) */
+	{0x0149,0x01},
+	{0x014A,0x00},
+	{0x014C,0x4f},		/* cp2_x 0x54f (1359) */
+	{0x014D,0x05},
+	{0x014E,0x00},
+	{0x0150,0x94},		/* cp2_y 0x394 (916) */
+	{0x0151,0x03},
+	{0x0152,0x00},
+	{0x0154,0x6a},		/* cp3_x  0x146a (5226)*/
+	{0x0155,0x14},
+	{0x0156,0x00},
+	{0x0158,0xd8},		/* cp3_y 0x6d8 (1752) */
+	{0x0159,0x06},
+	{0x015A,0x00},
+	{0x015C,0xfe},		/* cp4_x 0x2afe (11006) */
+	{0x015D,0x2a},
+	{0x015E,0x00},
+	{0x0160,0xFE},		/* cp4_y 0x8f2 (2290) */
+	{0x0161,0x04},
+	{0x0162,0x00},
+	{0x0164,0x3a},		/* cp5_x 0x483a (18490)*/
+	{0x0165,0x48},
+	{0x0166,0x00},
+	{0x0168,0x0e},		/* cp5_y 0xa0e (2574) */
+	{0x0169,0x0a},
+	{0x016A,0x00},
+	{0x016C,0x7e},		/* cp6_x 0x1157e (71038) */
+	{0x016D,0x15},
+	{0x016E,0x01},
+	{0x0170,0xcf},		/* cp6_y 0xacf (2767)*/
+	{0x0171,0x0a},
+	{0x0172,0x00},
+	{0x0174,0xa1},		/* cp7_x 0x6aa1 (272927) */
+	{0x0175,0x6a},
+	{0x0176,0x00},
+	{0x0178,0x44},		/* cp7_y 0xc44 (3140) */
+	{0x0179,0x0c},
+	{0x017A,0x00},
+	{0x017C,0xff},		/* cp8_x 0xffffff (1048575)*/
+	{0x017D,0xff},
+	{0x017E,0x0f},
+	{0x0180,0x0f},		/* cp8_y 0xf0e (3855) */
+	{0x0181,0x0f},
+	{0x0182,0x00},
+	{0x0184,0xFF},		/* cp9_x 0xffffff (16777215) */
+	{0x0185,0xFF},
+	{0x0186,0x0f},
+	{0x0188,0x0f},		/* cp9_y 0xf0e (3854) */
+	{0x0189,0x0F},
+	{0x018A,0x00},
+	{0x018C,0xFF},		/* cp10_x 0xffffff (16777215) */
+	{0x018D,0xFF},
+	{0x018E,0xFF},
+	{0x0190,0x0f},		/* cp10_y 0xf0e (3854) */
+	{0x0191,0x0F},
+	{0x0192,0x00},
+	{0x0194,0x0E},
+	{0x0195,0x0F},
+	{0x0196,0x00},
+	{0x0198,0x00},
+	{0x0199,0x00},
+	{0x019A,0x00},
+	{0x019B,0x01},
+	{0x019C,0x55},
+	{0x019D,0x55},
+	{0x019E,0x55},
+	{0x019F,0x00},
+	{0x01A0,0xC7},
+	{0x01A1,0x71},
+	{0x01A2,0x1C},
+	{0x01A3,0x00},
+	{0x01A4,0x75},
+	{0x01A5,0x39},
+	{0x01A6,0x03},
+	{0x01A7,0x00},
+	{0x01A8,0xBA},
+	{0x01A9,0x9C},
+	{0x01AA,0x01},
+	{0x01AB,0x00},
+	{0x01AC,0x5D},
+	{0x01AD,0xCE},
+	{0x01AE,0x00},
+	{0x01AF,0x00},
+	{0x01B0,0x19},
+	{0x01B1,0x14},
+	{0x01B2,0x00},
+	{0x01B3,0x00},
+	{0x01B4,0x0C},
+	{0x01B5,0x0A},
+	{0x01B6,0x00},
+	{0x01B7,0x00},
+	{0x01B8,0x06},
+	{0x01B9,0x05},
+	{0x01BA,0x00},
+	{0x01BB,0x00},
+	{0x01BC,0x00},
+	{0x01BD,0x00},
+	{0x01BE,0x00},
+	{0x01BF,0x00},
+	{0x01C0,0x00},
+	{0x01C1,0x00},
+	{0x01C2,0x00},
+	{0x01C3,0x00},
+	{0x01C4,0x00},
+	{0x01C5,0x00},
+	{0x01CC,0x01},
+	{0x01D0,0x09},
+	{0x01D4,0x01},
+	{0x0232,0x13},
+	{0x0233,0x01},
+	{0x0390,0x00},
+	{0x0391,0x00},
+	{0x0392,0x00},
+	{0x03C0,0x00},
+	{0x2000,0x55},
+	{0x2001,0x55},
+	{0x2002,0x55},
+	{0x2003,0x05},
+	{0x2004,0x02},
+	{0x2008,0x65},
+	{0x2009,0x04},
+	{0x200A,0x00},
+	/* line length of 2200 is 60 fps */
+	{0x200C,0x98},
+	{0x200D,0x08},
+
+	/* line length of 4400 is 30 fps */
+	/* {0x200C,0x30}, */
+	/* {0x200D,0x11}, */
+
+	{0x2010,0x04},
+	{0x2014,0x00},
+	{0x2018,0x02},
+	{0x2019,0x04},
+	{0x201A,0x00},
+	{0x201C,0x21},
+	{0x201D,0x11},
+	{0x201E,0x00},
+	{0x201F,0x00},
+	{0x2020,0xBC},
+	{0x2021,0x00},
+	{0x2022,0x7F},
+	{0x2023,0x00},
+	{0x2024,0xBA},
+	{0x2025,0x00},
+	{0x2026,0x81},
+	{0x2027,0x00},
+	{0x2028,0x7D},
+	{0x2029,0x90},
+	{0x202A,0x05},
+	{0x202C,0xFC},
+	{0x202D,0x02},
+	{0x202E,0x25},
+	{0x202F,0x03},
+	{0x2030,0x05},
+	{0x2031,0x02},
+	{0x2032,0xCA},
+	{0x2033,0x02},
+	{0x2034,0xFC},
+	{0x2035,0x02},
+	{0x2036,0x25},
+	{0x2037,0x03},
+	{0x2038,0xF8},
+	{0x2039,0xE4},
+	{0x203A,0xE3},
+	{0x203B,0x01},
+	{0x203C,0xF5},
+	{0x203D,0x8E},
+	{0x203E,0x0C},
+	{0x203F,0x2D},
+	{0x2040,0x69},
+	{0x2041,0x01},
+	{0x2042,0x8E},
+	{0x2043,0x01},
+	{0x2044,0x0C},
+	{0x2045,0x02},
+	{0x2046,0x31},
+	{0x2047,0x02},
+	{0x2048,0x6A},
+	{0x2049,0x01},
+	{0x204A,0x8E},
+	{0x204B,0x01},
+	{0x204C,0x0D},
+	{0x204D,0x02},
+	{0x204E,0x31},
+	{0x204F,0x02},
+	{0x2050,0x7B},
+	{0x2051,0x00},
+	{0x2052,0x7D},
+	{0x2053,0x00},
+	{0x2054,0x95},
+	{0x2055,0x00},
+	{0x2056,0x97},
+	{0x2057,0x00},
+	{0x2058,0xAD},
+	{0x2059,0x00},
+	{0x205A,0xAF},
+	{0x205B,0x00},
+	{0x205C,0x92},
+	{0x205D,0x00},
+	{0x205E,0x94},
+	{0x205F,0x00},
+	{0x2060,0x8E},
+	{0x2061,0x00},
+	{0x2062,0x90},
+	{0x2063,0x00},
+	{0x2064,0xB1},
+	{0x2065,0x00},
+	{0x2066,0xB3},
+	{0x2067,0x00},
+	{0x2068,0x08},
+	{0x2069,0x00},
+	{0x206A,0x04},
+	{0x206B,0x00},
+	{0x206C,0x84},
+	{0x206D,0x00},
+	{0x206E,0x80},
+	{0x206F,0x00},
+	{0x2070,0x04},
+	{0x2071,0x00},
+	{0x2072,0x46},
+	{0x2073,0x00},
+	{0x2074,0xE9},
+	{0x2075,0x01},
+	{0x2076,0x74},
+	{0x2077,0x02},
+	{0x2078,0x80},
+	{0x2079,0x00},
+	{0x207A,0xC1},
+	{0x207B,0x00},
+	{0x207C,0xFF},
+	{0x207D,0x03},
+	{0x207E,0xFF},
+	{0x207F,0x03},
+	{0x2080,0x78},
+	{0x2081,0x00},
+	{0x2082,0x6A},
+	{0x2083,0x01},
+	{0x2084,0xE4},
+	{0x2085,0x01},
+	{0x2086,0x2B},
+	{0x2087,0x03},
+	{0x2088,0x00},
+	{0x2089,0x00},
+	{0x208A,0xFF},
+	{0x208B,0x03},
+	{0x208C,0xFF},
+	{0x208D,0x03},
+	{0x208E,0xFF},
+	{0x208F,0x03},
+	{0x2090,0x7D},
+	{0x2091,0x00},
+	{0x2092,0x62},
+	{0x2093,0x01},
+	{0x2094,0xE9},
+	{0x2095,0x01},
+	{0x2096,0x00},
+	{0x2097,0x00},
+	{0x2098,0x7C},
+	{0x2099,0x00},
+	{0x209A,0x21},
+	{0x209B,0x03},
+	{0x209C,0xE9},
+	{0x209D,0x01},
+	{0x209E,0x21},
+	{0x209F,0x03},
+	{0x20A0,0xFF},
+	{0x20A1,0x03},
+	{0x20A2,0xFF},
+	{0x20A3,0x03},
+	{0x20A4,0xFF},
+	{0x20A5,0x03},
+	{0x20A6,0xFF},
+	{0x20A7,0x03},
+	{0x20A8,0xFF},
+	{0x20A9,0x03},
+	{0x20AA,0xFF},
+	{0x20AB,0x03},
+	{0x20AC,0xFF},
+	{0x20AD,0x03},
+	{0x20AE,0xFF},
+	{0x20AF,0x03},
+	{0x20B0,0xFF},
+	{0x20B1,0x03},
+	{0x20B2,0xFF},
+	{0x20B3,0x03},
+	{0x20B4,0x87},
+	{0x20B5,0xCC},
+	{0x20B6,0x87},
+	{0x20B7,0x08},
+	{0x20B8,0xF4},
+	{0x20B9,0xA5},
+	{0x20BA,0x07},
+	{0x20BC,0x1F},
+	{0x20BD,0x01},
+	{0x20BE,0xF6},
+	{0x20BF,0x00},
+	{0x20C0,0x90},
+	{0x20C1,0x01},
+	{0x20C2,0x67},
+	{0x20C3,0x01},
+	{0x20C4,0xFF},
+	{0x20C5,0x03},
+	{0x20C6,0xFF},
+	{0x20C7,0x03},
+	{0x20C8,0x33},
+	{0x20C9,0x02},
+	{0x20CA,0x0A},
+	{0x20CB,0x02},
+	{0x20CC,0x7F},
+	{0x20CD,0x00},
+	{0x20CE,0xD2},
+	{0x20CF,0x00},
+	{0x20D0,0x81},
+	{0x20D1,0x00},
+	{0x20D2,0x87},
+	{0x20D3,0x00},
+	{0x20D4,0x09},
+	{0x20D5,0x00},
+	{0x20D8,0x7F},
+	{0x20D9,0x00},
+	{0x20DA,0x62},
+	{0x20DB,0x01},
+	{0x20DC,0x7F},
+	{0x20DD,0x00},
+	{0x20DE,0x62},
+	{0x20DF,0x01},
+	{0x20E0,0x65},
+	{0x20E1,0x00},
+	{0x20E2,0x75},
+	{0x20E3,0x00},
+	{0x20E4,0xE0},
+	{0x20E5,0x00},
+	{0x20E6,0xF0},
+	{0x20E7,0x00},
+	{0x20E8,0x4C},
+	{0x20E9,0x01},
+	{0x20EA,0x5C},
+	{0x20EB,0x01},
+	{0x20EC,0xD1},
+	{0x20ED,0x01},
+	{0x20EE,0xE1},
+	{0x20EF,0x01},
+	{0x20F0,0x93},
+	{0x20F1,0x02},
+	{0x20F2,0xA3},
+	{0x20F3,0x02},
+	{0x20F4,0x0D},
+	{0x20F5,0x03},
+	{0x20F6,0x1D},
+	{0x20F7,0x03},
+	{0x20F8,0x57},
+	{0x20F9,0x00},
+	{0x20FA,0x7B},
+	{0x20FB,0x00},
+	{0x20FC,0xD2},
+	{0x20FD,0x00},
+	{0x20FE,0xF6},
+	{0x20FF,0x00},
+	{0x2100,0x3E},
+	{0x2101,0x01},
+	{0x2102,0x60},
+	{0x2103,0x01},
+	{0x2104,0xC3},
+	{0x2105,0x01},
+	{0x2106,0xE5},
+	{0x2107,0x01},
+	{0x2108,0x85},
+	{0x2109,0x02},
+	{0x210A,0xA9},
+	{0x210B,0x02},
+	{0x210C,0xFF},
+	{0x210D,0x02},
+	{0x210E,0x21},
+	{0x210F,0x03},
+	{0x2110,0xFF},
+	{0x2111,0x03},
+	{0x2112,0x00},
+	{0x2113,0x00},
+	{0x2114,0xFF},
+	{0x2115,0x03},
+	{0x2116,0xFF},
+	{0x2117,0x03},
+	{0x2118,0xFF},
+	{0x2119,0x03},
+	{0x211A,0xFF},
+	{0x211B,0x03},
+	{0x211C,0xFF},
+	{0x211D,0x03},
+	{0x211E,0xFF},
+	{0x211F,0x03},
+	{0x2120,0xFF},
+	{0x2121,0x03},
+	{0x2122,0xFF},
+	{0x2123,0x03},
+	{0x2124,0xFF},
+	{0x2125,0x03},
+	{0x2126,0xFF},
+	{0x2127,0x03},
+	{0x2128,0x7D},
+	{0x2129,0x90},
+	{0x212A,0xD5},
+	{0x212B,0x07},
+	{0x212C,0x64},
+	{0x212D,0x01},
+	{0x2130,0x5F},
+	{0x2131,0x7D},
+	{0x2132,0x05},
+	{0x2134,0x78},
+	{0x2135,0x00},
+	{0x2136,0x76},
+	{0x2137,0x00},
+	{0x2138,0xF3},
+	{0x2139,0x00},
+	{0x213A,0xF1},
+	{0x213B,0x00},
+	{0x213C,0xA6},
+	{0x213D,0x02},
+	{0x213E,0xA4},
+	{0x213F,0x02},
+	{0x2140,0x7D},
+	{0x2141,0x00},
+	{0x2142,0x8D},
+	{0x2143,0x00},
+	{0x2144,0xA1},
+	{0x2145,0x01},
+	{0x2146,0xB1},
+	{0x2147,0x01},
+	{0x2148,0xAB},
+	{0x2149,0x02},
+	{0x214A,0xBB},
+	{0x214B,0x02},
+	{0x214C,0x17},
+	{0x214D,0x5C},
+	{0x214E,0x00},
+	{0x2150,0x00},
+	{0x2151,0x00},
+	{0x2152,0xF8},
+	{0x2153,0x00},
+	{0x2154,0xBE},
+	{0x2155,0x00},
+	{0x2156,0x7D},
+	{0x2157,0x00},
+	{0x2158,0x25},
+	{0x2159,0x00},
+	{0x215A,0x7D},
+	{0x215B,0x00},
+	{0x215C,0x62},
+	{0x215D,0x01},
+	{0x215E,0xFF},
+	{0x215F,0x03},
+	{0x2160,0x26},
+	{0x2161,0x00},
+	{0x2162,0x7D},
+	{0x2163,0x00},
+	{0x2164,0x63},
+	{0x2165,0x01},
+	{0x2166,0xFF},
+	{0x2167,0x03},
+	{0x2168,0xCB},
+	{0x2169,0x02},
+	{0x216A,0xCF},
+	{0x216B,0x02},
+	{0x216C,0xFF},
+	{0x216D,0x03},
+	{0x216E,0xFF},
+	{0x216F,0x03},
+	{0x2170,0xFF},
+	{0x2171,0x03},
+	{0x2172,0xFF},
+	{0x2173,0x03},
+	{0x2174,0xFF},
+	{0x2175,0x03},
+	{0x2176,0xFF},
+	{0x2177,0x03},
+	{0x2178,0x7E},
+	{0x2179,0x00},
+	{0x217A,0xBD},
+	{0x217B,0x00},
+	{0x217C,0xEC},
+	{0x217D,0x01},
+	{0x217E,0x7B},
+	{0x217F,0x02},
+	{0x2180,0xD1},
+	{0x2181,0x02},
+	{0x2182,0x25},
+	{0x2183,0x03},
+	{0x2184,0x7F},
+	{0x2185,0x00},
+	{0x2186,0xBD},
+	{0x2187,0x00},
+	{0x2188,0xED},
+	{0x2189,0x01},
+	{0x218A,0x7B},
+	{0x218B,0x02},
+	{0x218C,0xD2},
+	{0x218D,0x02},
+	{0x218E,0x25},
+	{0x218F,0x03},
+	{0x2190,0xFF},
+	{0x2191,0x03},
+	{0x2192,0xFF},
+	{0x2193,0x03},
+	{0x2194,0xE9},
+	{0x2195,0x01},
+	{0x2196,0x21},
+	{0x2197,0x03},
+	{0x2198,0x17},
+	{0x2199,0xFC},
+	{0x219A,0x7F},
+	{0x219B,0x01},
+	{0x219C,0xFF},
+	{0x219D,0x03},
+	{0x21A0,0x1B},
+	{0x21A1,0x1B},
+	{0x21A2,0x1B},
+	{0x21A3,0x1B},
+	{0x21A4,0x2B},
+	{0x21A5,0x80},
+	{0x21A6,0x00},
+	{0x21A8,0x04},
+	{0x21A9,0x98},
+	{0x21AA,0x60},
+	{0x21AB,0x03},
+	{0x21AC,0x7F},
+	{0x21AD,0x80},
+	{0x21AE,0x09},
+	{0x21B0,0x1C},
+	{0x21B1,0x00},
+	{0x21B2,0xA0},
+	{0x21B3,0x00},
+	{0x21B4,0x0C},
+	{0x21B5,0x00},
+	{0x21B6,0x2D},
+	{0x21B7,0x00},
+	{0x21B8,0x20},
+	{0x21B9,0x00},
+	{0x21BA,0x02},
+	{0x21BB,0x00},
+	{0x21BC,0xCC},
+	{0x21BD,0x00},
+	{0x21BE,0x4A},
+	{0x21BF,0x00},
+	{0x21C0,0xD0},
+	{0x21C1,0x00},
+	{0x21C2,0x44},
+	{0x21C3,0x00},
+	{0x21C4,0x00},
+	{0x21C5,0xE0},
+	{0x21C6,0x00},
+	{0x21C8,0x11},
+	{0x21C9,0x00},
+	{0x21CA,0x02},
+	{0x21CC,0x08},
+	{0x21CD,0xC0},
+	{0x21CE,0x0C},
+	{0x21D0,0x44},
+	{0x21D1,0x00},
+	{0x21D2,0x02},
+	{0x21D4,0x02},
+	{0x21D5,0x20},
+	{0x21D6,0x2C},
+	{0x21D8,0xFE},
+	{0x21D9,0x9D},
+	{0x21DA,0xDF},
+	{0x21DB,0x03},
+	{0x21DC,0x62},
+	{0x21DD,0x01},
+	{0x21DE,0x7F},
+	{0x21DF,0x00},
+	{0x21E0,0xB7},
+	{0x21E1,0x01},
+	{0x21E2,0xB5},
+	{0x21E3,0x01},
+	{0x21E4,0xC1},
+	{0x21E5,0x02},
+	{0x21E6,0xBF},
+	{0x21E7,0x02},
+	{0x21E8,0xB3},
+	{0x21E9,0x0D},
+	{0x21EA,0x00},
+	{0x21EB,0x04},
+	{0x21EC,0x90},
+	{0x21ED,0x07},
+	{0x21EE,0x58},
+	{0x21EF,0x04},
+	{0x21F0,0x54},
+	{0x21F1,0x04},
+	{0x21F4,0x02},
+	{0x21F5,0x00},
+	{0x21F6,0x00},
+	{0x21F8,0x3C},
+	{0x21F9,0x00},
+	{0x21FC,0x28},
+	{0x21FD,0x00},
+	{0x21FE,0x3C},
+	{0x21FF,0x00},
+	{0x2200,0x00},
+	{0x2204,0x4C},
+	{0x2205,0x04},
+	{0x2206,0x65},
+	{0x2207,0x04},
+	{0x2208,0x0A},
+	{0x2209,0x00},
+	{0x220C,0x57},
+	{0x220D,0x00},
+	{0x220E,0x37},
+	{0x220F,0x00},
+	{0x2210,0x1F},
+	{0x2211,0x00},
+	{0x2212,0x1F},
+	{0x2213,0x00},
+	{0x2214,0x1F},
+	{0x2215,0x00},
+	{0x2216,0x77},
+	{0x2217,0x00},
+	{0x2218,0x1F},
+	{0x2219,0x00},
+	{0x221A,0x17},
+	{0x221B,0x00},
+	{0x221C,0x03},
+	{0x2220,0x24},
+	{0x2221,0x00},
+	{0x2222,0x00},
+	{0x2223,0x00},
+	{0x2224,0xA7},
+	{0x2225,0xAA},
+	{0x2226,0x80},
+	{0x2227,0x08},
+	{0x2228,0x01},
+	{0x2260,0xFF},
+	{0x2261,0x1F},
+	{0x2262,0x00},
+	{0x2263,0x00},
+	{0x2264,0x00},
+	{0x2265,0x00},
+	{0x2266,0xFF},
+	{0x2267,0x1F},
+	{0x2268,0x00},
+	{0x2269,0x00},
+	{0x226A,0xFF},
+	{0x226B,0x1F},
+	{0x226C,0x00},
+	{0x226D,0x00},
+	{0x226E,0xFF},
+	{0x226F,0x1F},
+	{0x227C,0xB2},
+	{0x227D,0x0C},
+	{0x227E,0x6A},
+	{0x227F,0x09},
+	{0x2280,0xD2},
+	{0x2281,0x0C},
+	{0x2282,0x5A},
+	{0x2283,0x09},
+	{0x2284,0xC4},
+	{0x2285,0x0C},
+	{0x2286,0x54},
+	{0x2287,0x09},
+	{0x22B2,0x92},
+	{0x22B4,0x20},
+	{0x22B5,0x00},
+	{0x22B6,0x20},
+	{0x22B7,0x00},
+	{0x22B8,0x20},
+	{0x22B9,0x00},
+	{0x22BA,0x20},
+	{0x22BB,0x00},
+	{0x22BC,0x20},
+	{0x22BD,0x00},
+	{0x22BE,0x20},
+	{0x22BF,0x00},
+	{0x22C0,0x20},
+	{0x22C1,0x00},
+	{0x22C2,0x20},
+	{0x22C3,0x00},
+	{0x22C4,0x20},
+	{0x22C5,0x00},
+	{0x22C6,0x20},
+	{0x22C7,0x00},
+	{0x22C8,0x20},
+	{0x22C9,0x00},
+	{0x22CA,0x20},
+	{0x22CB,0x00},
+	{0x22CC,0x20},
+	{0x22CD,0x00},
+	{0x22CE,0x20},
+	{0x22CF,0x00},
+	{0x22DA,0x00},
+	{0x22EF,0x82},
+	{0x2308,0x01},
+	{0x2311,0x09},
+	{0x2318,0x40},
+	{0x2319,0xCD},
+	{0x231A,0x54},
+	{0x2324,0x20},
+	{0x2325,0x00},
+	{0x2328,0x00},
+	{0x234A,0x9F},
+	{0x234B,0x07},
+	{0x2354,0x0C},
+	{0x23C0,0x5D},
+	{0x244C,0xFF},
+	{0x244D,0x03},
+	{0x244E,0xFF},
+	{0x244F,0x03},
+	{0x24A0,0x00},
+	{0x24A4,0x16},
+	{0x24A5,0x01},
+	{0x24A6,0xA6},
+	{0x24A7,0x02},
+	{0x24A8,0xD5},
+	{0x24A9,0x02},
+	{0x24BC,0x17},
+	{0x24BD,0x01},
+	{0x24BE,0xA7},
+	{0x24BF,0x02},
+	{0x24C0,0xD5},
+	{0x24C1,0x02},
+	{0x24DA,0x6F},
+	{0x24DB,0x00},
+	{0x24DC,0x62},
+	{0x24DD,0x01},
+	{0x24EA,0x32},
+	{0x24EB,0x00},
+	{0x24EC,0xDC},
+	{0x24ED,0x00},
+	{0x24FA,0x32},
+	{0x24FB,0x00},
+	{0x24FC,0xDD},
+	{0x24FD,0x00},
+	{0x254A,0x15},
+	{0x254B,0x01},
+	{0x255A,0x15},
+	{0x255B,0x01},
+	{0x2560,0x01},
+	{0x2561,0x00},
+	{0x2562,0x2A},
+	{0x2563,0x00},
+	{0x2564,0xF8},
+	{0x2565,0x00},
+	{0x2566,0x15},
+	{0x2567,0x01},
+	{0x2568,0x0C},
+	{0x2569,0x02},
+	{0x256A,0x31},
+	{0x256B,0x02},
+	{0x2578,0x90},
+	{0x2579,0x01},
+	{0x257A,0x92},
+	{0x257B,0x01},
+	{0x257C,0xB8},
+	{0x257D,0x02},
+	{0x257E,0xBA},
+	{0x257F,0x02},
+	{0x2584,0x90},
+	{0x2585,0x01},
+	{0x2586,0x92},
+	{0x2587,0x01},
+	{0x2588,0xB8},
+	{0x2589,0x02},
+	{0x258A,0xBA},
+	{0x258B,0x02},
+	{0x267A,0xF8},
+	{0x267B,0x00},
+	{0x267C,0x16},
+	{0x267D,0x01},
+	{0x267E,0xA6},
+	{0x267F,0x02},
+	{0x2680,0xD5},
+	{0x2681,0x02},
+	{0x2690,0xF8},
+	{0x2691,0x00},
+	{0x2694,0xA6},
+	{0x2695,0x02},
+	{0x2696,0x16},
+	{0x2697,0x01},
+	{0x269A,0xD5},
+	{0x269B,0x02},
+	{0x26B8,0x10},
+	{0x26B9,0x00},
+	{0x26BA,0x33},
+	{0x26BB,0x00},
+	{0x26BC,0x89},
+	{0x26BD,0x00},
+	{0x26BE,0xB0},
+	{0x26BF,0x00},
+	{0x26C4,0x4E},
+	{0x26C5,0x00},
+	{0x26C8,0xC9},
+	{0x26C9,0x00},
+	{0x26CC,0x35},
+	{0x26CD,0x01},
+	{0x26D0,0xBA},
+	{0x26D1,0x01},
+	{0x26D4,0x7C},
+	{0x26D5,0x02},
+	{0x26D8,0xF6},
+	{0x26D9,0x02},
+	{0x26DE,0x51},
+	{0x26DF,0x00},
+	{0x26E0,0x7F},
+	{0x26E1,0x00},
+	{0x26E2,0xCC},
+	{0x26E3,0x00},
+	{0x26E4,0xF8},
+	{0x26E5,0x00},
+	{0x26E6,0x38},
+	{0x26E7,0x01},
+	{0x26E8,0x65},
+	{0x26E9,0x01},
+	{0x26EA,0xBD},
+	{0x26EB,0x01},
+	{0x26EE,0x7F},
+	{0x26EF,0x02},
+	{0x26F0,0xAB},
+	{0x26F1,0x02},
+	{0x26F2,0xF9},
+	{0x26F3,0x02},
+	{0x2722,0x59},
+	{0x2723,0x02},
+	{0x2938,0x55},
+	{0x2939,0x00},
+	{0x293A,0x17},
+	{0x293B,0x00},
+	{0x293C,0xD0},
+	{0x293D,0x00},
+	{0x293E,0x91},
+	{0x293F,0x00},
+	{0x2940,0x3C},
+	{0x2941,0x01},
+	{0x2942,0x0C},
+	{0x2943,0x01},
+	{0x2944,0xC1},
+	{0x2945,0x01},
+	{0x2946,0x76},
+	{0x2947,0x01},
+	{0x2948,0x83},
+	{0x2949,0x02},
+	{0x294A,0xFB},
+	{0x294B,0x01},
+	{0x294C,0xFD},
+	{0x294D,0x02},
+	{0x294E,0xBF},
+	{0x294F,0x02},
+	{0x2A06,0x25},
+	{0x2A07,0x03},
+	{0x2A20,0x00},
+	{0x2A21,0x00},
+	{0x2A22,0x7D},
+	{0x2A23,0x00},
+	{0x2B11,0x1A},
+	{0x2B13,0x11},
+	{0x2B14,0x11},
+	{0x2B15,0x11},
+	{0x2B16,0x11},
+	{0x2B17,0x10},
+	{0x2B18,0x0F},
+	{0x2B19,0x0E},
+	{0x2B1A,0x0D},
+	{0x2B1B,0x0C},
+	{0x2B1C,0x0B},
+	{0x2B1D,0x0B},
+	{0x2B1E,0x0A},
+	{0x2B1F,0x09},
+	{0x2B20,0x08},
+	{0x2B21,0x07},
+	{0x2B22,0x06},
+	{0x2B23,0x05},
+	{0x2B24,0x04},
+	{0x2B25,0x03},
+	{0x2B26,0x03},
+	{0x2B38,0x01},
+	{0x2B45,0xE3},
+	{0x2B50,0x01},
+	{0x2B51,0x00},
+	{0x2B62,0x66},
+	{0x2B6D,0x47},
+	{0x2B70,0x03},
+	{0x2B71,0x02},
+	{0x2B72,0x02},
+	{0x2B7B,0x42},
+	{0x2B7F,0x7F},
+	{0x2B80,0x94},
+	{0x2B81,0x06},
+	{0x2B87,0x1B},
+	{0x2B88,0x1A},
+	{0x2B89,0x17},
+	{0x2B8A,0x17},
+	{0x2B8B,0x12},
+	{0x2B8D,0x2B},
+	{0x2B8E,0x2B},
+	{0x2B8F,0x2B},
+	{0x2B90,0x7F},
+	{0x2B91,0x0F},
+	{0x2B92,0x31},
+	{0x2B93,0x07},
+	{0x2B94,0xFE},
+	{0x2B95,0x26},
+	{0x2B98,0xFE},
+	{0x2B99,0x56},
+	{0x2B9B,0x2A},
+	{0x2BA8,0xBC},
+	{0x2BA9,0x62},
+	{0x2BC1,0x70},
+	{0x2BC5,0x80},
+	{0x2BD5,0x30},
+	{0x2BD6,0xF0},
+	{0x2BD8,0xDB},
+	{0x2BD9,0xF6},
+	{0x2BDA,0x21},
+	{0x2BDB,0x06},
+	{0x2BDC,0x57},
+	{0x2C98,0xE1},
+	{0x2C99,0x2E},
+	{0x2C9B,0x80},
+	{0x2CA9,0x80},
+	{0x2CAA,0x01},
+	{0x2CBF,0x08},
+	{0x2D39,0x0E},
+	{0x2D50,0x80},
+	{0x2D54,0x00},
+	{0x2D5B,0x58},
+	{0x2DFD,0x01},
+	{0x3000,0x00},
+	{0x3001,0x00},
+	{0x3002,0x23},
+	{0x3003,0xA1},
+	{0x3004,0x00},
+	{0x3005,0x20},
+	{0x3006,0x58},
+	{0x3007,0x00},
+	{0x3008,0x06},
+	{0x3009,0xB4},
+	{0x300A,0x1F},
+	{0x300B,0x00},
+	{0x300C,0x00},
+	{0x300D,0x1B},
+	{0x300E,0x90},
+	{0x300F,0x97},
+	{0x3010,0x00},
+	{0x3011,0x00},
+	{0x3012,0x20},
+	{0x3013,0x21},
+	{0x3014,0x00},
+	{0x3015,0x20},
+	{0x3016,0x84},
+	{0x3017,0x00},
+	{0x3018,0x30},
+	{0x3019,0x09},
+	{0x301A,0x46},
+	{0x301B,0x00},
+	{0x3066,},
+	{0x3070,0xC1},
+	{0x3071,0x81},
+	{0x3072,0x29},
+	{0x3073,0x81},
+	{0x3080,0xC4},
+	{0x3081,0x0C},
+	{0x3082,0xD2},
+	{0x3083,0x0C},
+	{0x3084,0x5C},
+	{0x3085,0x00},
+	{0x3086,0x90},
+	{0x3087,0x00},
+	{0x3088,0x07},
+	{0x3089,0x0A},
+	{0x308A,0x52},
+	{0x308B,0x09},
+	{0x308C,0x44},
+	{0x308D,0x03},
+	{0x308E,0x70},
+	{0x308F,0x03},
+	{0x3090,0x54},
+	{0x3091,0x09},
+	{0x3092,0x5A},
+	{0x3093,0x09},
+	{0x3094,0x1C},
+	{0x3095,0x00},
+	{0x3096,0x10},
+	{0x3097,0x00},
+	{0x3098,0x70},
+	{0x3099,0x03},
+	{0x309A,0xF8},
+	{0x309B,0x04},
+	{0x309C,0x74},
+	{0x309D,0x01},
+	{0x309E,0x60},
+	{0x309F,0x01},
+	{0x30A0,},
+	{0x30A1,},
+	{0x30A2,},
+	{0x30A3,},
+	{0x30A4,},
+	{0x30A5,},
+	{0x30A6,},
+	{0x30A7,},
+	{0x30A8,},
+	{0x30A9,},
+	{0x30AA,},
+	{0x30AB,},
+	{0x30AC,},
+	{0x30AD,},
+	{0x30AE,},
+	{0x30AF,},
+	{0x30B0,},
+	{0x30B1,},
+	{0x30B2,},
+	{0x30B3,},
+	{0x30B4,},
+	{0x30B5,},
+	{0x30B6,},
+	{0x30B7,},
+	{0x30B8,},
+	{0x30B9,},
+	{0x30BA,},
+	{0x30BB,},
+	{0x30BC,},
+	{0x30BD,},
+	{0x30BE,},
+	{0x30BF,},
+	{0x3370,0x01},
+	{0x3374,0xF0},
+	{0x3375,0x00},
+	{0x3376,0x01},
+	{0x3377,0x00},
+	{0x3410,0x90},
+	{0x3411,0x07},
+	{0x3418,0x48},
+	{0x3419,0x04},
+	{0x34BE,0x6A},
+	{0x34BF,0x01},
+	{0x34C0,},
+	{0x34C1,},
+	{0x34C2,},
+	{0x34C3,},
+	{0x34C4,},
+	{0x34C5,},
+	{0x34C6,},
+	{0x34C7,},
+	{0x34C8,},
+	{0x34C9,},
+	{0x34CA,},
+	{0x34CB,},
+	{0x34CC,},
+	{0x34CD,},
+	{0x34CE,},
+	{0x34CF,},
+	{0x3584,0x00},
+	{0x3586,0x00},
+	{0x3587,0x01},
+	{0x3588,0xE6},
+	{0x3589,0x00},
+	{0x3590,0x00},
+	{0x3591,0x00},
+	{0x3594,0x40},
+	{0x3598,0x03},
+	{0x3599,0x00},
+	{0x359A,0x80},
+	{0x359B,0x00},
+	{0x359C,0x00},
+	{0x359D,0x01},
+	{0x359E,0x00},
+	{0x359F,0x02},
+	{0x35A0,0x00},
+	{0x35A1,0x04},
+	{0x35A2,0x20},
+	{0x35A3,0x00},
+	{0x35A4,0x40},
+	{0x35A5,0x00},
+	{0x35A6,0x80},
+	{0x35A7,0x00},
+	{0x35A8,0x00},
+	{0x35A9,0x01},
+	{0x35AA,0x3A},
+	{0x35AB,0x00},
+	{0x35AC,0x80},
+	{0x35AD,0x00},
+	{0x35AE,0x00},
+	{0x35AF,0x01},
+	{0x35B0,0x00},
+	{0x35B1,0x02},
+	{0x35B2,0x00},
+	{0x35B3,0x04},
+	{0x35B4,0x02},
+	{0x35B5,0x00},
+	{0x35B6,0x04},
+	{0x35B7,0x00},
+	{0x35B8,0x08},
+	{0x35B9,0x00},
+	{0x35BA,0x10},
+	{0x35BB,0x00},
+	{0x35BC,0x03},
+	{0x35BD,0x00},
+	{0x35C8,0x00},
+	{0x35C9,0x01},
+	{0x35CA,0x00},
+	{0x35CB,0x04},
+	{0x35CC,0x00},
+	{0x35CD,0x10},
+	{0x35CE,0x00},
+	{0x35CF,0x40},
+	{0x35D0,0x00},
+	{0x35D1,0x0C},
+	{0x35D2,0x00},
+	{0x35D3,0x0C},
+	{0x35D4,0x00},
+	{0x35D5,0x0C},
+	{0x35D6,0x00},
+	{0x35D7,0x0C},
+	{0x35D8,0x00},
+	{0x35D9,0x00},
+	{0x35DA,0x08},
+	{0x35DB,0x00},
+	{0x35DC,0xD8},
+	{0x35DD,0x0E},
+	{0x35F0,0x00},
+	{0x35F1,0x10},
+	{0x35F2,0x00},
+	{0x35F3,0x10},
+	{0x35F4,0x00},
+	{0x35F5,0x10},
+	{0x35F6,0x00},
+	{0x35F7,0x03},
+	{0x35F8,0x00},
+	{0x35F9,0x02},
+	{0x35FA,0x38},
+	{0x35FB,0x00},
+	{0x35FC,0xB3},
+	{0x35FD,0x01},
+	{0x35FE,0x00},
+	{0x35FF,0x00},
+	{0x3600,0x05},
+	{0x3601,0x06},
+	{0x3604,0x03},
+	{0x3605,0x00},
+	{0x3608,0x03},
+	{0x3609,0x00},
+	{0x360C,0x00},
+	{0x360D,0x00},
+	{0x3610,0x10},
+	{0x3611,0x01},
+	{0x3612,0x00},
+	{0x3613,0x00},
+	{0x3614,0x00},
+	{0x3615,0x00},
+	{0x361C,0x00},
+	{0x361D,0x01},
+	{0x361E,0x00},
+	{0x361F,0x01},
+	{0x3620,0x01},
+	{0x3621,0x00},
+	{0x3622,0xB0},
+	{0x3623,0x04},
+	{0x3624,0xDC},
+	{0x3625,0x05},
+	{0x3626,0x00},
+	{0x3627,0x01},
+	{0x3628,0xFF},
+	{0x3629,0x0F},
+	{0x362A,0x00},
+	{0x362B,0x10},
+	{0x362C,0x00},
+	{0x362D,0x01},
+	{0x3630,0x41},
+	{0x3631,0x00},
+	{0x3632,0x41},
+	{0x3633,0x00},
+	{0x3634,0x41},
+	{0x3635,0x00},
+	{0x3636,0x41},
+	{0x3637,0x00},
+	{0x3638,0x44},
+	{0x3639,0x00},
+	{0x363A,0x47},
+	{0x363B,0x00},
+	{0x363C,0x47},
+	{0x363D,0x00},
+	{0x363E,0x44},
+	{0x363F,0x00},
+	{0x36C4,0xFF},
+	{0x36C5,0x0F},
+	{0x36C6,0xFF},
+	{0x36C7,0x0F},
+	{0x36C8,0xFF},
+	{0x36C9,0x0F},
+	{0x36CC,0x00},
+	{0x36CD,0x00},
+	{0x36CE,0x00},
+	{0x36CF,0x00},
+	{0x36D0,0x00},
+	{0x36D1,0x00},
+	{0x36D4,0xFF},
+	{0x36D5,0x0F},
+	{0x36D6,0xFF},
+	{0x36D7,0x0F},
+	{0x36D8,0xFF},
+	{0x36D9,0x0F},
+	{0x36DC,0xFF},
+	{0x36DD,0x0F},
+	{0x36DE,0xFF},
+	{0x36DF,0x0F},
+	{0x36E0,0xFF},
+	{0x36E1,0x0F},
+	{0x36E4,0xFF},
+	{0x36E5,0x0F},
+	{0x36E6,0xFF},
+	{0x36E7,0x0F},
+	{0x36E8,0xFF},
+	{0x36E9,0x0F},
+	{0x36EE,0x00},
+	{0x36EF,0x00},
+	{0x36F0,0x00},
+	{0x36F1,0x80},
+	{0x36F8,0x01},
+	{0x3700,0x03},
+	{0x3701,0x05},
+	{0x3702,0x03},
+	{0x3703,0x04},
+	{0x3704,0x08},
+	{0x3705,0x03},
+	{0x3706,0x03},
+	{0x3707,0x03},
+	{0x3708,0x03},
+	{0x3709,0x03},
+	{0x370A,0x03},
+	{0x370B,0x03},
+	{0x370C,0x03},
+	{0x370D,0x03},
+	{0x370E,0x0E},
+	{0x3718,0x64},
+	{0x3719,0x47},
+	{0x371A,0x36},
+	{0x371B,0x1E},
+	{0x371C,0x50},
+	{0x371D,0x41},
+	{0x371E,0x2F},
+	{0x371F,0x1A},
+	{0x3720,0x95},
+	{0x3721,0x9D},
+	{0x3722,0xA5},
+	{0x3723,0xAD},
+	{0x3748,0xA8},
+	{0x3749,0x9E},
+	{0x374A,0x94},
+	{0x374B,0x80},
+	{0x37C0,0x00},
+	{0x37C1,0x00},
+	{0x37C2,0x00},
+	{0x37C4,0x00},
+	{0x37C5,0x00},
+	{0x37C6,0x00},
+	{0x37C8,0x00},
+	{0x37C9,0x00},
+	{0x37CA,0x00},
+	{0x37CC,0x00},
+	{0x37CD,0x00},
+	{0x37CE,0x00},
+	{0x37D0,0x00},
+	{0x37D1,0x00},
+	{0x37D2,0x00},
+	{0x37D4,0x00},
+	{0x37D5,0x00},
+	{0x37D6,0x00},
+	{0x37D8,0x00},
+	{0x37D9,0x00},
+	{0x37DA,0x00},
+	{0x37DC,0x00},
+	{0x37DD,0x00},
+	{0x37DE,0x00},
+	{0x37E0,0x00},
+	{0x37E1,0x00},
+	{0x37E2,0x00},
+	{0x37E4,0x00},
+	{0x37E5,0x00},
+	{0x37E6,0x00},
+	{0x37E8,0x00},
+	{0x37E9,0x00},
+	{0x37EA,0x00},
+	{0x37EC,0x00},
+	{0x37ED,0x00},
+	{0x37EE,0x00},
+	{0x37F0,0x00},
+	{0x37F4,0x00},
+	{0x37F5,0x1E},
+	{0x37F6,0x34},
+	{0x37F7,0x00},
+	{0x37F8,0xFF},
+	{0x37F9,0xFF},
+	{0x37FA,0x03},
+	{0x37FC,0x00},
+	{0x37FD,0x00},
+	{0x37FE,0x04},
+	{0x3800,0xFF},
+	{0x3801,0xFF},
+	{0x3802,0x03},
+	{0x3804,0x00},
+	{0x3805,0x00},
+	{0x3806,0x04},
+	{0x3808,0x00},
+	{0x3809,0x00},
+	{0x380A,0x00},
+	{0x380C,0x00},
+	{0x380D,0x00},
+	{0x380E,0x00},
+	{0x3810,0x00},
+	{0x3811,0x00},
+	{0x3812,0x00},
+	{0x3814,0x00},
+	{0x3815,0x00},
+	{0x3816,0x00},
+	{0x3818,0x00},
+	{0x3819,0x00},
+	{0x381A,0x00},
+	{0x381C,0x00},
+	{0x381D,0x00},
+	{0x381E,0x00},
+	{0x3820,0x00},
+	{0x3821,0x00},
+	{0x3822,0x00},
+	{0x3824,0x00},
+	{0x3825,0x00},
+	{0x3826,0x00},
+	{0x3828,0x00},
+	{0x3829,0x00},
+	{0x382A,0x00},
+	{0x382C,0x00},
+	{0x382D,0x00},
+	{0x382E,0x00},
+	{0x3830,0x00},
+	{0x3831,0x00},
+	{0x3832,0x00},
+	{0x3834,0x00},
+	{0x3835,0x00},
+	{0x3836,0x00},
+	{0x3838,0x47},
+	{0x3839,0x00},
+	{0x383A,0x34},
+	{0x383B,0x00},
+	{0x383C,0x48},
+	{0x383D,0x00},
+	{0x383E,0x39},
+	{0x383F,0x00},
+	{0x3840,0x13},
+	{0x3841,0x00},
+	{0x3842,0x13},
+	{0x3843,0x00},
+	{0x3844,0x1D},
+	{0x3845,0x00},
+	{0x3846,0x1D},
+	{0x3847,0x00},
+	{0x3848,0x08},
+	{0x3849,0x00},
+	{0x384A,0x07},
+	{0x384B,0x00},
+	{0x384C,0x05},
+	{0x384D,0x00},
+	{0x384E,0x00},
+	{0x384F,0x00},
+	{0x3850,0xFF},
+	{0x3851,0x0F},
+	{0x3852,0x00},
+	{0x3853,0x10},
+	{0x3854,0xFF},
+	{0x3855,0x0F},
+	{0x3856,0x00},
+	{0x3857,0x10},
+	{0x3858,0xFF},
+	{0x3859,0x0F},
+	{0x385A,0x00},
+	{0x385B,0x10},
+	{0x385C,0x02},
+	{0x385D,0x00},
+	{0x385E,0x06},
+	{0x385F,0x00},
+	{0x3860,0x06},
+	{0x3861,0x00},
+	{0x3862,0x08},
+	{0x3863,0x00},
+	{0x3864,0x02},
+	{0x3865,0x00},
+	{0x3870,0x00},
+	{0x3871,0x01},
+	{0x38A0,0x01},
+	{0x38A1,0x01},
+	{0x38A2,0x00},
+	{0x38A3,0x01},
+	{0x38A4,0x07},
+	{0x38A5,0x00},
+	{0x38A6,0x04},
+	{0x38A7,0x04},
+	{0x38A8,0x00},
+	{0x38A9,0x00},
+	{0x38AC,0x00},
+	{0x38AD,0x00},
+	{0x38AE,0x01},
+	{0x38B0,0x02},
+	{0x38B2,0x43},
+	{0x38B3,0x00},
+	{0x38B4,0x10},
+	{0x38B5,0x00},
+	{0x38B6,0x09},
+	{0x38B7,0x00},
+	{0x38B8,0x09},
+	{0x38B9,0x00},
+	{0x38BA,0x47},
+	{0x38BB,0x00},
+	{0x38BC,0x16},
+	{0x38BD,0x00},
+	{0x38BE,0x0E},
+	{0x38BF,0x00},
+	{0x38C0,0x0B},
+	{0x38C1,0x00},
+	{0x38C2,0x4A},
+	{0x38C3,0x00},
+	{0x38C4,0x1C},
+	{0x38C5,0x00},
+	{0x38C6,0x12},
+	{0x38C7,0x00},
+	{0x38C8,0x0D},
+	{0x38C9,0x00},
+	{0x38CA,0x51},
+	{0x38CB,0x00},
+	{0x38CC,0x24},
+	{0x38CD,0x00},
+	{0x38CE,0x19},
+	{0x38CF,0x00},
+	{0x38D0,0x10},
+	{0x38D1,0x00},
+	{0x38D2,0x5D},
+	{0x38D3,0x00},
+	{0x38D4,0x30},
+	{0x38D5,0x00},
+	{0x38D6,0x23},
+	{0x38D7,0x00},
+	{0x38D8,0x17},
+	{0x38D9,0x00},
+	{0x38DA,0x72},
+	{0x38DB,0x00},
+	{0x38DC,0x43},
+	{0x38DD,0x00},
+	{0x38DE,0x31},
+	{0x38DF,0x00},
+	{0x38E0,0x20},
+	{0x38E1,0x00},
+	{0x38E2,0x96},
+	{0x38E3,0x00},
+	{0x38E4,0x5E},
+	{0x38E5,0x00},
+	{0x38E6,0x46},
+	{0x38E7,0x00},
+	{0x38E8,0x2E},
+	{0x38E9,0x00},
+	{0x38EA,0xD4},
+	{0x38EB,0x00},
+	{0x38EC,0x87},
+	{0x38ED,0x00},
+	{0x38EE,0x65},
+	{0x38EF,0x00},
+	{0x38F0,0x43},
+	{0x38F1,0x00},
+	{0x38F2,0x3F},
+	{0x38F3,0x01},
+	{0x38F4,0xC4},
+	{0x38F5,0x00},
+	{0x38F6,0x94},
+	{0x38F7,0x00},
+	{0x38F8,0x64},
+	{0x38F9,0x00},
+	{0x38FA,0x00},
+	{0x38FB,0x01},
+	{0x38FC,0x00},
+	{0x38FD,0x01},
+	{0x38FE,0x00},
+	{0x38FF,0x01},
+	{0x3900,0x00},
+	{0x3901,0x01},
+	{0x3902,0x60},
+	{0x3903,0x00},
+	{0x3904,0x25},
+	{0x3905,0x00},
+	{0x3906,0x18},
+	{0x3907,0x00},
+	{0x3908,0x10},
+	{0x3909,0x00},
+	{0x390A,0xE6},
+	{0x390B,0x00},
+	{0x390C,0xD5},
+	{0x390D,0x00},
+	{0x390E,0xAA},
+	{0x390F,0x00},
+	{0x3910,0x85},
+	{0x3911,0x00},
+	{0x3912,0xE6},
+	{0x3913,0x00},
+	{0x3914,0xD5},
+	{0x3915,0x00},
+	{0x3916,0xAA},
+	{0x3917,0x00},
+	{0x3918,0x85},
+	{0x3919,0x00},
+	{0x391A,0xE6},
+	{0x391B,0x00},
+	{0x391C,0xD5},
+	{0x391D,0x00},
+	{0x391E,0xAA},
+	{0x391F,0x00},
+	{0x3920,0x85},
+	{0x3921,0x00},
+	{0x3922,0x40},
+	{0x3923,0x00},
+	{0x3924,0x40},
+	{0x3925,0x00},
+	{0x3926,0x40},
+	{0x3927,0x00},
+	{0x3928,0x40},
+	{0x3929,0x00},
+	{0x392A,0x80},
+	{0x392B,0x00},
+	{0x392C,0x80},
+	{0x392D,0x00},
+	{0x392E,0x80},
+	{0x392F,0x00},
+	{0x3930,0x80},
+	{0x3931,0x00},
+	{0x3932,0x4C},
+	{0x3933,0x4C},
+	{0x3934,0x4C},
+	{0x3940,0x01},
+	{0x3941,0x01},
+	{0x3942,0x00},
+	{0x3943,0x01},
+	{0x3944,0x07},
+	{0x3945,0x00},
+	{0x3946,0x04},
+	{0x3947,0x04},
+	{0x3948,0x00},
+	{0x3949,0x00},
+	{0x394C,0x00},
+	{0x394D,0x00},
+	{0x394E,0x01},
+	{0x3950,0x03},
+	{0x3952,0x1B},
+	{0x3953,0x00},
+	{0x3954,0x0C},
+	{0x3955,0x00},
+	{0x3956,0x09},
+	{0x3957,0x00},
+	{0x3958,0x07},
+	{0x3959,0x00},
+	{0x395A,0x1D},
+	{0x395B,0x00},
+	{0x395C,0x0E},
+	{0x395D,0x00},
+	{0x395E,0x0B},
+	{0x395F,0x00},
+	{0x3960,0x08},
+	{0x3961,0x00},
+	{0x3962,0x1E},
+	{0x3963,0x00},
+	{0x3964,0x10},
+	{0x3965,0x00},
+	{0x3966,0x0C},
+	{0x3967,0x00},
+	{0x3968,0x09},
+	{0x3969,0x00},
+	{0x396A,0x21},
+	{0x396B,0x00},
+	{0x396C,0x13},
+	{0x396D,0x00},
+	{0x396E,0x0E},
+	{0x396F,0x00},
+	{0x3970,0x0A},
+	{0x3971,0x00},
+	{0x3972,0x25},
+	{0x3973,0x00},
+	{0x3974,0x19},
+	{0x3975,0x00},
+	{0x3976,0x12},
+	{0x3977,0x00},
+	{0x3978,0x0D},
+	{0x3979,0x00},
+	{0x397A,0x2E},
+	{0x397B,0x00},
+	{0x397C,0x21},
+	{0x397D,0x00},
+	{0x397E,0x19},
+	{0x397F,0x00},
+	{0x3980,0x11},
+	{0x3981,0x00},
+	{0x3982,0x3C},
+	{0x3983,0x00},
+	{0x3984,0x2F},
+	{0x3985,0x00},
+	{0x3986,0x23},
+	{0x3987,0x00},
+	{0x3988,0x19},
+	{0x3989,0x00},
+	{0x398A,0x56},
+	{0x398B,0x00},
+	{0x398C,0x44},
+	{0x398D,0x00},
+	{0x398E,0x35},
+	{0x398F,0x00},
+	{0x3990,0x27},
+	{0x3991,0x00},
+	{0x3992,0x84},
+	{0x3993,0x00},
+	{0x3994,0x68},
+	{0x3995,0x00},
+	{0x3996,0x53},
+	{0x3997,0x00},
+	{0x3998,0x40},
+	{0x3999,0x00},
+	{0x399A,0x00},
+	{0x399B,0x01},
+	{0x399C,0x00},
+	{0x399D,0x01},
+	{0x399E,0x00},
+	{0x399F,0x01},
+	{0x39A0,0x00},
+	{0x39A1,0x01},
+	{0x39A2,0x60},
+	{0x39A3,0x00},
+	{0x39A4,0x20},
+	{0x39A5,0x00},
+	{0x39A6,0x15},
+	{0x39A7,0x00},
+	{0x39A8,0x10},
+	{0x39A9,0x00},
+	{0x39AA,0xE6},
+	{0x39AB,0x00},
+	{0x39AC,0xD5},
+	{0x39AD,0x00},
+	{0x39AE,0xAA},
+	{0x39AF,0x00},
+	{0x39B0,0x85},
+	{0x39B1,0x00},
+	{0x39B2,0xE6},
+	{0x39B3,0x00},
+	{0x39B4,0xD5},
+	{0x39B5,0x00},
+	{0x39B6,0xAA},
+	{0x39B7,0x00},
+	{0x39B8,0x85},
+	{0x39B9,0x00},
+	{0x39BA,0xE6},
+	{0x39BB,0x00},
+	{0x39BC,0xD5},
+	{0x39BD,0x00},
+	{0x39BE,0xAA},
+	{0x39BF,0x00},
+	{0x39C0,0x85},
+	{0x39C1,0x00},
+	{0x39C2,0x40},
+	{0x39C3,0x00},
+	{0x39C4,0x40},
+	{0x39C5,0x00},
+	{0x39C6,0x40},
+	{0x39C7,0x00},
+	{0x39C8,0x40},
+	{0x39C9,0x00},
+	{0x39CA,0x80},
+	{0x39CB,0x00},
+	{0x39CC,0x80},
+	{0x39CD,0x00},
+	{0x39CE,0x80},
+	{0x39CF,0x00},
+	{0x39D0,0x80},
+	{0x39D1,0x00},
+	{0x39D2,0x4C},
+	{0x39D3,0x4C},
+	{0x39D4,0x4C},
+	{0x39E0,0x01},
+	{0x39E1,0x00},
+	{0x39E4,0x40},
+	{0x39E5,0x01},
+	{0x39E6,0x01},
+	{0x39E8,0x00},
+	{0x39E9,0x01},
+	{0x39EA,0x00},
+	{0x39EB,0x00},
+	{0x39EC,0x01},
+	{0x39ED,0x00},
+	{0x39EE,0x01},
+	{0x39F0,0x03},
+	{0x39F1,0x04},
+	{0x39F2,0x0E},
+	{0x39F4,0x19},
+	{0x39F5,0x00},
+	{0x39F6,0x12},
+	{0x39F7,0x00},
+	{0x39F8,0x0D},
+	{0x39F9,0x00},
+	{0x39FA,0x07},
+	{0x39FB,0x00},
+	{0x39FC,0x2B},
+	{0x39FD,0x00},
+	{0x39FE,0x1B},
+	{0x39FF,0x00},
+	{0x3A00,0x11},
+	{0x3A01,0x00},
+	{0x3A02,0x08},
+	{0x3A03,0x00},
+	{0x3A04,0x37},
+	{0x3A05,0x00},
+	{0x3A06,0x21},
+	{0x3A07,0x00},
+	{0x3A08,0x14},
+	{0x3A09,0x00},
+	{0x3A0A,0x09},
+	{0x3A0B,0x00},
+	{0x3A0C,0x4A},
+	{0x3A0D,0x00},
+	{0x3A0E,0x2C},
+	{0x3A0F,0x00},
+	{0x3A10,0x18},
+	{0x3A11,0x00},
+	{0x3A12,0x0B},
+	{0x3A13,0x00},
+	{0x3A14,0x66},
+	{0x3A15,0x00},
+	{0x3A16,0x3B},
+	{0x3A17,0x00},
+	{0x3A18,0x20},
+	{0x3A19,0x00},
+	{0x3A1A,0x0F},
+	{0x3A1B,0x00},
+	{0x3A1C,0x8E},
+	{0x3A1D,0x00},
+	{0x3A1E,0x51},
+	{0x3A1F,0x00},
+	{0x3A20,0x2B},
+	{0x3A21,0x00},
+	{0x3A22,0x14},
+	{0x3A23,0x00},
+	{0x3A24,0xC8},
+	{0x3A25,0x00},
+	{0x3A26,0x72},
+	{0x3A27,0x00},
+	{0x3A28,0x3C},
+	{0x3A29,0x00},
+	{0x3A2A,0x1B},
+	{0x3A2B,0x00},
+	{0x3A2C,0x19},
+	{0x3A2D,0x01},
+	{0x3A2E,0xA0},
+	{0x3A2F,0x00},
+	{0x3A30,0x54},
+	{0x3A31,0x00},
+	{0x3A32,0x25},
+	{0x3A33,0x00},
+	{0x3A34,0x8D},
+	{0x3A35,0x01},
+	{0x3A36,0xE1},
+	{0x3A37,0x00},
+	{0x3A38,0x76},
+	{0x3A39,0x00},
+	{0x3A3A,0x35},
+	{0x3A3B,0x00},
+	{0x3A3C,0x00},
+	{0x3A3D,0x01},
+	{0x3A3E,0x00},
+	{0x3A3F,0x01},
+	{0x3A40,0x00},
+	{0x3A41,0x01},
+	{0x3A42,0x00},
+	{0x3A43,0x01},
+	{0x3A44,0x70},
+	{0x3A45,0x00},
+	{0x3A46,0x25},
+	{0x3A47,0x00},
+	{0x3A48,0x18},
+	{0x3A49,0x00},
+	{0x3A4A,0x10},
+	{0x3A4B,0x00},
+	{0x3A4C,0xE6},
+	{0x3A4D,0x00},
+	{0x3A4E,0xD5},
+	{0x3A4F,0x00},
+	{0x3A50,0xAA},
+	{0x3A51,0x00},
+	{0x3A52,0x85},
+	{0x3A53,0x00},
+	{0x3A54,0xE6},
+	{0x3A55,0x00},
+	{0x3A56,0xD5},
+	{0x3A57,0x00},
+	{0x3A58,0xAA},
+	{0x3A59,0x00},
+	{0x3A5A,0x85},
+	{0x3A5B,0x00},
+	{0x3A5C,0xE6},
+	{0x3A5D,0x00},
+	{0x3A5E,0xD5},
+	{0x3A5F,0x00},
+	{0x3A60,0xAA},
+	{0x3A61,0x00},
+	{0x3A62,0x85},
+	{0x3A63,0x00},
+	{0x3A64,0x19},
+	{0x3A65,0x00},
+	{0x3A66,0x12},
+	{0x3A67,0x00},
+	{0x3A68,0x0D},
+	{0x3A69,0x00},
+	{0x3A6A,0x07},
+	{0x3A6B,0x00},
+	{0x3A6C,0x0C},
+	{0x3A6D,0x00},
+	{0x3A6E,0x07},
+	{0x3A6F,0x00},
+	{0x3A70,0x05},
+	{0x3A71,0x00},
+	{0x3A72,0x04},
+	{0x3A73,0x00},
+	{0x3A74,0x1B},
+	{0x3A75,0x00},
+	{0x3A76,0x15},
+	{0x3A77,0x00},
+	{0x3A78,0x0C},
+	{0x3A79,0x00},
+	{0x3A7A,0x08},
+	{0x3A7B,0x00},
+	{0x3A7C,0x80},
+	{0x3A7D,0x00},
+	{0x3A7E,0x80},
+	{0x3A7F,0x00},
+	{0x3A80,0x80},
+	{0x3A81,0x00},
+	{0x3A82,0x80},
+	{0x3A83,0x00},
+	{0x3A84,0x09},
+	{0x3A85,0x00},
+	{0x3A86,0x06},
+	{0x3A87,0x00},
+	{0x3A88,0x04},
+	{0x3A89,0x00},
+	{0x3A8A,0x03},
+	{0x3A8B,0x00},
+	{0x3A8C,0xFA},
+	{0x3A8D,0x00},
+	{0x3A8E,0xC8},
+	{0x3A8F,0x00},
+	{0x3A90,0x96},
+	{0x3A91,0x00},
+	{0x3A92,0x64},
+	{0x3A93,0x00},
+	{0x3A94,0xE1},
+	{0x3A95,0x00},
+	{0x3A96,0xC8},
+	{0x3A97,0x00},
+	{0x3A98,0x96},
+	{0x3A99,0x00},
+	{0x3A9A,0x64},
+	{0x3A9B,0x00},
+	{0x3A9C,0x08},
+	{0x3A9D,0x10},
+	{0x3A9E,0x4C},
+	{0x3A9F,0x4C},
+	{0x3AA0,0x4C},
+	{0x3AA1,0x04},
+	{0x3AA2,0x04},
+	{0x3AC0,0x01},
+	{0x3AC4,0x81},
+	{0x3AC5,0x00},
+	{0x3AC6,0x00},
+	{0x3AC7,0x00},
+	{0x3AC8,0x00},
+	{0x3AC9,0x00},
+	{0x3ACA,0x00},
+	{0x3ACB,0x00},
+	{0x3ACC,0x02},
+	{0x3ACD,0x00},
+	{0x3ACE,0x81},
+	{0x3ACF,0x00},
+	{0x3AD0,0x00},
+	{0x3AD1,0x00},
+	{0x3AD2,0xFD},
+	{0x3AD3,0x03},
+	{0x3AD4,0x02},
+	{0x3AD5,0x00},
+	{0x3AD6,0x00},
+	{0x3AD7,0x00},
+	{0x3AD8,0x81},
+	{0x3AD9,0x00},
+	{0x3ADA,0xFD},
+	{0x3ADB,0x03},
+	{0x3ADC,0xFF},
+	{0x3ADD,0x03},
+	{0x3ADE,0x01},
+	{0x3ADF,0x00},
+	{0x3AE0,0x01},
+	{0x3AE1,0x00},
+	{0x3AE2,0x7E},
+	{0x3AE3,0x00},
+	{0x3AF4,0x00},
+	{0x3AF6,0x40},
+	{0x3AF7,0x1E},
+	{0x3AF8,0x00},
+	{0x3AFA,0x00},
+	{0x3AFB,0x00},
+	{0x3AFC,0x00},
+	{0x3AFD,0x00},
+	{0x3AFE,0x00},
+	{0x3AFF,0x00},
+	{0x3B00,0x00},
+	{0x3B01,0x00},
+	{0x3B02,0x00},
+	{0x3B03,0x00},
+	{0x3B04,0x00},
+	{0x3B05,0x00},
+	{0x3B06,0x00},
+	{0x3B07,0x00},
+	{0x3B08,0x00},
+	{0x3B09,0x00},
+	{0x3B0A,0x00},
+	{0x3B0B,0x00},
+	{0x3B0C,0x00},
+	{0x3B0D,0x00},
+	{0x3B0E,0x00},
+	{0x3B0F,0x00},
+	{0x3B10,0x00},
+	{0x3B11,0x00},
+	{0x3B12,0x00},
+	{0x3B13,0x00},
+	{0x3B14,0x00},
+	{0x3B15,0x00},
+	{0x3B16,0x00},
+	{0x3B17,0x00},
+	{0x3B18,0x00},
+	{0x3B19,0x00},
+	{0x3B1A,0x00},
+	{0x3B1B,0x00},
+	{0x3B1C,0x00},
+	{0x3B1D,0x00},
+	{0x3B1E,0x00},
+	{0x3B1F,0x00},
+	{0x3B20,0x00},
+	{0x3B21,0x00},
+	{0x3B22,0x00},
+	{0x3B23,0x00},
+	{0x3B24,0x00},
+	{0x3B25,0x00},
+	{0x3B26,0x00},
+	{0x3B27,0x00},
+	{0x3B28,0x00},
+	{0x3B29,0x00},
+	{0x3B2A,0x00},
+	{0x3B2C,0x00},
+	{0x3B2E,0x00},
+	{0x3B30,0x00},
+	{0x3B32,0x0C},
+	{0x4000,0xAF},
+	{0x4001,0xA7},
+	{0x4002,0xA8},
+	{0x4003,0xA5},
+	{0x4004,0x98},
+	{0x4005,0x93},
+	{0x4006,0x94},
+	{0x4007,0x93},
+	{0x4008,0x8E},
+	{0x4009,0x8C},
+	{0x400A,0x8C},
+	{0x400B,0x8C},
+	{0x400C,0x89},
+	{0x400D,0x88},
+	{0x400E,0x89},
+	{0x400F,0x89},
+	{0x4010,0x87},
+	{0x4011,0x87},
+	{0x4012,0x87},
+	{0x4013,0x86},
+	{0x4014,0x88},
+	{0x4015,0x87},
+	{0x4016,0x87},
+	{0x4017,0x87},
+	{0x4018,0x8B},
+	{0x4019,0x89},
+	{0x401A,0x89},
+	{0x401B,0x8A},
+	{0x401C,0x92},
+	{0x401D,0x8F},
+	{0x401E,0x8F},
+	{0x401F,0x8F},
+	{0x4020,0xA2},
+	{0x4021,0x9C},
+	{0x4022,0x9B},
+	{0x4023,0x9C},
+	{0x4024,0xA1},
+	{0x4025,0x9A},
+	{0x4026,0x9B},
+	{0x4027,0x99},
+	{0x4028,0x94},
+	{0x4029,0x90},
+	{0x402A,0x90},
+	{0x402B,0x90},
+	{0x402C,0x8B},
+	{0x402D,0x89},
+	{0x402E,0x89},
+	{0x402F,0x89},
+	{0x4030,0x86},
+	{0x4031,0x85},
+	{0x4032,0x86},
+	{0x4033,0x85},
+	{0x4034,0x84},
+	{0x4035,0x84},
+	{0x4036,0x84},
+	{0x4037,0x84},
+	{0x4038,0x85},
+	{0x4039,0x85},
+	{0x403A,0x85},
+	{0x403B,0x85},
+	{0x403C,0x88},
+	{0x403D,0x87},
+	{0x403E,0x87},
+	{0x403F,0x87},
+	{0x4040,0x8E},
+	{0x4041,0x8C},
+	{0x4042,0x8C},
+	{0x4043,0x8C},
+	{0x4044,0x98},
+	{0x4045,0x93},
+	{0x4046,0x93},
+	{0x4047,0x94},
+	{0x4048,0x9D},
+	{0x4049,0x96},
+	{0x404A,0x97},
+	{0x404B,0x96},
+	{0x404C,0x91},
+	{0x404D,0x8C},
+	{0x404E,0x8D},
+	{0x404F,0x8C},
+	{0x4050,0x89},
+	{0x4051,0x86},
+	{0x4052,0x87},
+	{0x4053,0x86},
+	{0x4054,0x83},
+	{0x4055,0x82},
+	{0x4056,0x82},
+	{0x4057,0x82},
+	{0x4058,0x80},
+	{0x4059,0x80},
+	{0x405A,0x80},
+	{0x405B,0x80},
+	{0x405C,0x82},
+	{0x405D,0x82},
+	{0x405E,0x82},
+	{0x405F,0x82},
+	{0x4060,0x86},
+	{0x4061,0x85},
+	{0x4062,0x85},
+	{0x4063,0x85},
+	{0x4064,0x8B},
+	{0x4065,0x8A},
+	{0x4066,0x89},
+	{0x4067,0x89},
+	{0x4068,0x94},
+	{0x4069,0x91},
+	{0x406A,0x90},
+	{0x406B,0x91},
+	{0x406C,0x9E},
+	{0x406D,0x95},
+	{0x406E,0x96},
+	{0x406F,0x95},
+	{0x4070,0x91},
+	{0x4071,0x8C},
+	{0x4072,0x8C},
+	{0x4073,0x8C},
+	{0x4074,0x89},
+	{0x4075,0x86},
+	{0x4076,0x86},
+	{0x4077,0x86},
+	{0x4078,0x83},
+	{0x4079,0x82},
+	{0x407A,0x82},
+	{0x407B,0x82},
+	{0x407C,0x80},
+	{0x407D,0x80},
+	{0x407E,0x80},
+	{0x407F,0x80},
+	{0x4080,0x82},
+	{0x4081,0x81},
+	{0x4082,0x81},
+	{0x4083,0x81},
+	{0x4084,0x85},
+	{0x4085,0x85},
+	{0x4086,0x85},
+	{0x4087,0x84},
+	{0x4088,0x8B},
+	{0x4089,0x8A},
+	{0x408A,0x89},
+	{0x408B,0x89},
+	{0x408C,0x93},
+	{0x408D,0x90},
+	{0x408E,0x8F},
+	{0x408F,0x8F},
+	{0x4090,0xA3},
+	{0x4091,0x99},
+	{0x4092,0x9A},
+	{0x4093,0x99},
+	{0x4094,0x95},
+	{0x4095,0x8F},
+	{0x4096,0x8F},
+	{0x4097,0x8F},
+	{0x4098,0x8B},
+	{0x4099,0x87},
+	{0x409A,0x87},
+	{0x409B,0x87},
+	{0x409C,0x86},
+	{0x409D,0x84},
+	{0x409E,0x84},
+	{0x409F,0x84},
+	{0x40A0,0x84},
+	{0x40A1,0x83},
+	{0x40A2,0x83},
+	{0x40A3,0x82},
+	{0x40A4,0x84},
+	{0x40A5,0x84},
+	{0x40A6,0x83},
+	{0x40A7,0x83},
+	{0x40A8,0x88},
+	{0x40A9,0x87},
+	{0x40AA,0x86},
+	{0x40AB,0x86},
+	{0x40AC,0x8E},
+	{0x40AD,0x8C},
+	{0x40AE,0x8C},
+	{0x40AF,0x8B},
+	{0x40B0,0x9A},
+	{0x40B1,0x96},
+	{0x40B2,0x96},
+	{0x40B3,0x95},
+	{0x40B4,0xBA},
+	{0x40B5,0xAC},
+	{0x40B6,0xAD},
+	{0x40B7,0xAC},
+	{0x40B8,0x99},
+	{0x40B9,0x90},
+	{0x40BA,0x91},
+	{0x40BB,0x90},
+	{0x40BC,0x90},
+	{0x40BD,0x8A},
+	{0x40BE,0x8A},
+	{0x40BF,0x8A},
+	{0x40C0,0x89},
+	{0x40C1,0x86},
+	{0x40C2,0x86},
+	{0x40C3,0x87},
+	{0x40C4,0x87},
+	{0x40C5,0x85},
+	{0x40C6,0x85},
+	{0x40C7,0x85},
+	{0x40C8,0x87},
+	{0x40C9,0x86},
+	{0x40CA,0x85},
+	{0x40CB,0x85},
+	{0x40CC,0x8A},
+	{0x40CD,0x88},
+	{0x40CE,0x88},
+	{0x40CF,0x87},
+	{0x40D0,0x92},
+	{0x40D1,0x8F},
+	{0x40D2,0x8E},
+	{0x40D3,0x8E},
+	{0x40D4,0xA2},
+	{0x40D5,0x9D},
+	{0x40D6,0x9D},
+	{0x40D7,0x9B},
+	{0x4100,0x80},
+	{0x4101,0x80},
+	{0x4102,0x80},
+	{0x4103,0x80},
+	{0x4104,0x80},
+	{0x4105,0x80},
+	{0x4106,0x80},
+	{0x4107,0x80},
+	{0x4108,0x80},
+	{0x4109,0x80},
+	{0x410A,0x80},
+	{0x410B,0x80},
+	{0x410C,0x80},
+	{0x410D,0x80},
+	{0x410E,0x80},
+	{0x410F,0x80},
+	{0x4110,0x80},
+	{0x4111,0x80},
+	{0x4112,0x80},
+	{0x4113,0x80},
+	{0x4114,0x80},
+	{0x4115,0x80},
+	{0x4116,0x80},
+	{0x4117,0x80},
+	{0x4118,0x80},
+	{0x4119,0x80},
+	{0x411A,0x80},
+	{0x411B,0x80},
+	{0x411C,0x80},
+	{0x411D,0x80},
+	{0x411E,0x80},
+	{0x411F,0x80},
+	{0x4120,0x80},
+	{0x4121,0x80},
+	{0x4122,0x80},
+	{0x4123,0x80},
+	{0x4124,0x80},
+	{0x4125,0x80},
+	{0x4126,0x80},
+	{0x4127,0x80},
+	{0x4128,0x80},
+	{0x4129,0x80},
+	{0x412A,0x80},
+	{0x412B,0x80},
+	{0x412C,0x80},
+	{0x412D,0x80},
+	{0x412E,0x80},
+	{0x412F,0x80},
+	{0x4130,0x80},
+	{0x4131,0x80},
+	{0x4132,0x80},
+	{0x4133,0x80},
+	{0x4134,0x80},
+	{0x4135,0x80},
+	{0x4136,0x80},
+	{0x4137,0x80},
+	{0x4138,0x80},
+	{0x4139,0x80},
+	{0x413A,0x80},
+	{0x413B,0x80},
+	{0x413C,0x80},
+	{0x413D,0x80},
+	{0x413E,0x80},
+	{0x413F,0x80},
+	{0x4140,0x80},
+	{0x4141,0x80},
+	{0x4142,0x80},
+	{0x4143,0x80},
+	{0x4144,0x80},
+	{0x4145,0x80},
+	{0x4146,0x80},
+	{0x4147,0x80},
+	{0x4148,0x80},
+	{0x4149,0x80},
+	{0x414A,0x80},
+	{0x414B,0x80},
+	{0x414C,0x80},
+	{0x414D,0x80},
+	{0x414E,0x80},
+	{0x414F,0x80},
+	{0x4150,0x80},
+	{0x4151,0x80},
+	{0x4152,0x80},
+	{0x4153,0x80},
+	{0x4154,0x80},
+	{0x4155,0x80},
+	{0x4156,0x80},
+	{0x4157,0x80},
+	{0x4158,0x80},
+	{0x4159,0x80},
+	{0x415A,0x80},
+	{0x415B,0x80},
+	{0x415C,0x80},
+	{0x415D,0x80},
+	{0x415E,0x80},
+	{0x415F,0x80},
+	{0x4160,0x80},
+	{0x4161,0x80},
+	{0x4162,0x80},
+	{0x4163,0x80},
+	{0x4164,0x80},
+	{0x4165,0x80},
+	{0x4166,0x80},
+	{0x4167,0x80},
+	{0x4168,0x80},
+	{0x4169,0x80},
+	{0x416A,0x80},
+	{0x416B,0x80},
+	{0x416C,0x80},
+	{0x416D,0x80},
+	{0x416E,0x80},
+	{0x416F,0x80},
+	{0x4170,0x80},
+	{0x4171,0x80},
+	{0x4172,0x80},
+	{0x4173,0x80},
+	{0x4174,0x80},
+	{0x4175,0x80},
+	{0x4176,0x80},
+	{0x4177,0x80},
+	{0x4178,0x80},
+	{0x4179,0x80},
+	{0x417A,0x80},
+	{0x417B,0x80},
+	{0x417C,0x80},
+	{0x417D,0x80},
+	{0x417E,0x80},
+	{0x417F,0x80},
+	{0x4180,0x80},
+	{0x4181,0x80},
+	{0x4182,0x80},
+	{0x4183,0x80},
+	{0x4184,0x80},
+	{0x4185,0x80},
+	{0x4186,0x80},
+	{0x4187,0x80},
+	{0x4188,0x80},
+	{0x4189,0x80},
+	{0x418A,0x80},
+	{0x418B,0x80},
+	{0x418C,0x80},
+	{0x418D,0x80},
+	{0x418E,0x80},
+	{0x418F,0x80},
+	{0x4190,0x80},
+	{0x4191,0x80},
+	{0x4192,0x80},
+	{0x4193,0x80},
+	{0x4194,0x80},
+	{0x4195,0x80},
+	{0x4196,0x80},
+	{0x4197,0x80},
+	{0x4198,0x80},
+	{0x4199,0x80},
+	{0x419A,0x80},
+	{0x419B,0x80},
+	{0x419C,0x80},
+	{0x419D,0x80},
+	{0x419E,0x80},
+	{0x419F,0x80},
+	{0x41A0,0x80},
+	{0x41A1,0x80},
+	{0x41A2,0x80},
+	{0x41A3,0x80},
+	{0x41A4,0x80},
+	{0x41A5,0x80},
+	{0x41A6,0x80},
+	{0x41A7,0x80},
+	{0x41A8,0x80},
+	{0x41A9,0x80},
+	{0x41AA,0x80},
+	{0x41AB,0x80},
+	{0x41AC,0x80},
+	{0x41AD,0x80},
+	{0x41AE,0x80},
+	{0x41AF,0x80},
+	{0x41B0,0x80},
+	{0x41B1,0x80},
+	{0x41B2,0x80},
+	{0x41B3,0x80},
+	{0x41B4,0x80},
+	{0x41B5,0x80},
+	{0x41B6,0x80},
+	{0x41B7,0x80},
+	{0x41B8,0x80},
+	{0x41B9,0x80},
+	{0x41BA,0x80},
+	{0x41BB,0x80},
+	{0x41BC,0x80},
+	{0x41BD,0x80},
+	{0x41BE,0x80},
+	{0x41BF,0x80},
+	{0x41C0,0x80},
+	{0x41C1,0x80},
+	{0x41C2,0x80},
+	{0x41C3,0x80},
+	{0x41C4,0x80},
+	{0x41C5,0x80},
+	{0x41C6,0x80},
+	{0x41C7,0x80},
+	{0x41C8,0x80},
+	{0x41C9,0x80},
+	{0x41CA,0x80},
+	{0x41CB,0x80},
+	{0x41CC,0x80},
+	{0x41CD,0x80},
+	{0x41CE,0x80},
+	{0x41CF,0x80},
+	{0x41D0,0x80},
+	{0x41D1,0x80},
+	{0x41D2,0x80},
+	{0x41D3,0x80},
+	{0x41D4,0x80},
+	{0x41D5,0x80},
+	{0x41D6,0x80},
+	{0x41D7,0x80},
+	{0x4200,0x80},
+	{0x4201,0x80},
+	{0x4202,0x80},
+	{0x4203,0x80},
+	{0x4204,0x80},
+	{0x4205,0x80},
+	{0x4206,0x80},
+	{0x4207,0x80},
+	{0x4208,0x80},
+	{0x4209,0x80},
+	{0x420A,0x80},
+	{0x420B,0x80},
+	{0x420C,0x80},
+	{0x420D,0x80},
+	{0x420E,0x80},
+	{0x420F,0x80},
+	{0x4210,0x80},
+	{0x4211,0x80},
+	{0x4212,0x80},
+	{0x4213,0x80},
+	{0x4214,0x80},
+	{0x4215,0x80},
+	{0x4216,0x80},
+	{0x4217,0x80},
+	{0x4218,0x80},
+	{0x4219,0x80},
+	{0x421A,0x80},
+	{0x421B,0x80},
+	{0x421C,0x80},
+	{0x421D,0x80},
+	{0x421E,0x80},
+	{0x421F,0x80},
+	{0x4220,0x80},
+	{0x4221,0x80},
+	{0x4222,0x80},
+	{0x4223,0x80},
+	{0x4224,0x80},
+	{0x4225,0x80},
+	{0x4226,0x80},
+	{0x4227,0x80},
+	{0x4228,0x80},
+	{0x4229,0x80},
+	{0x422A,0x80},
+	{0x422B,0x80},
+	{0x422C,0x80},
+	{0x422D,0x80},
+	{0x422E,0x80},
+	{0x422F,0x80},
+	{0x4230,0x80},
+	{0x4231,0x80},
+	{0x4232,0x80},
+	{0x4233,0x80},
+	{0x4234,0x80},
+	{0x4235,0x80},
+	{0x4236,0x80},
+	{0x4237,0x80},
+	{0x4238,0x80},
+	{0x4239,0x80},
+	{0x423A,0x80},
+	{0x423B,0x80},
+	{0x423C,0x80},
+	{0x423D,0x80},
+	{0x423E,0x80},
+	{0x423F,0x80},
+	{0x4240,0x80},
+	{0x4241,0x80},
+	{0x4242,0x80},
+	{0x4243,0x80},
+	{0x4244,0x80},
+	{0x4245,0x80},
+	{0x4246,0x80},
+	{0x4247,0x80},
+	{0x4248,0x80},
+	{0x4249,0x80},
+	{0x424A,0x80},
+	{0x424B,0x80},
+	{0x424C,0x80},
+	{0x424D,0x80},
+	{0x424E,0x80},
+	{0x424F,0x80},
+	{0x4250,0x80},
+	{0x4251,0x80},
+	{0x4252,0x80},
+	{0x4253,0x80},
+	{0x4254,0x80},
+	{0x4255,0x80},
+	{0x4256,0x80},
+	{0x4257,0x80},
+	{0x4258,0x80},
+	{0x4259,0x80},
+	{0x425A,0x80},
+	{0x425B,0x80},
+	{0x425C,0x80},
+	{0x425D,0x80},
+	{0x425E,0x80},
+	{0x425F,0x80},
+	{0x4260,0x80},
+	{0x4261,0x80},
+	{0x4262,0x80},
+	{0x4263,0x80},
+	{0x4264,0x80},
+	{0x4265,0x80},
+	{0x4266,0x80},
+	{0x4267,0x80},
+	{0x4268,0x80},
+	{0x4269,0x80},
+	{0x426A,0x80},
+	{0x426B,0x80},
+	{0x426C,0x80},
+	{0x426D,0x80},
+	{0x426E,0x80},
+	{0x426F,0x80},
+	{0x4270,0x80},
+	{0x4271,0x80},
+	{0x4272,0x80},
+	{0x4273,0x80},
+	{0x4274,0x80},
+	{0x4275,0x80},
+	{0x4276,0x80},
+	{0x4277,0x80},
+	{0x4278,0x80},
+	{0x4279,0x80},
+	{0x427A,0x80},
+	{0x427B,0x80},
+	{0x427C,0x80},
+	{0x427D,0x80},
+	{0x427E,0x80},
+	{0x427F,0x80},
+	{0x4280,0x80},
+	{0x4281,0x80},
+	{0x4282,0x80},
+	{0x4283,0x80},
+	{0x4284,0x80},
+	{0x4285,0x80},
+	{0x4286,0x80},
+	{0x4287,0x80},
+	{0x4288,0x80},
+	{0x4289,0x80},
+	{0x428A,0x80},
+	{0x428B,0x80},
+	{0x428C,0x80},
+	{0x428D,0x80},
+	{0x428E,0x80},
+	{0x428F,0x80},
+	{0x4290,0x80},
+	{0x4291,0x80},
+	{0x4292,0x80},
+	{0x4293,0x80},
+	{0x4294,0x80},
+	{0x4295,0x80},
+	{0x4296,0x80},
+	{0x4297,0x80},
+	{0x4298,0x80},
+	{0x4299,0x80},
+	{0x429A,0x80},
+	{0x429B,0x80},
+	{0x429C,0x80},
+	{0x429D,0x80},
+	{0x429E,0x80},
+	{0x429F,0x80},
+	{0x42A0,0x80},
+	{0x42A1,0x80},
+	{0x42A2,0x80},
+	{0x42A3,0x80},
+	{0x42A4,0x80},
+	{0x42A5,0x80},
+	{0x42A6,0x80},
+	{0x42A7,0x80},
+	{0x42A8,0x80},
+	{0x42A9,0x80},
+	{0x42AA,0x80},
+	{0x42AB,0x80},
+	{0x42AC,0x80},
+	{0x42AD,0x80},
+	{0x42AE,0x80},
+	{0x42AF,0x80},
+	{0x42B0,0x80},
+	{0x42B1,0x80},
+	{0x42B2,0x80},
+	{0x42B3,0x80},
+	{0x42B4,0x80},
+	{0x42B5,0x80},
+	{0x42B6,0x80},
+	{0x42B7,0x80},
+	{0x42B8,0x80},
+	{0x42B9,0x80},
+	{0x42BA,0x80},
+	{0x42BB,0x80},
+	{0x42BC,0x80},
+	{0x42BD,0x80},
+	{0x42BE,0x80},
+	{0x42BF,0x80},
+	{0x42C0,0x80},
+	{0x42C1,0x80},
+	{0x42C2,0x80},
+	{0x42C3,0x80},
+	{0x42C4,0x80},
+	{0x42C5,0x80},
+	{0x42C6,0x80},
+	{0x42C7,0x80},
+	{0x42C8,0x80},
+	{0x42C9,0x80},
+	{0x42CA,0x80},
+	{0x42CB,0x80},
+	{0x42CC,0x80},
+	{0x42CD,0x80},
+	{0x42CE,0x80},
+	{0x42CF,0x80},
+	{0x42D0,0x80},
+	{0x42D1,0x80},
+	{0x42D2,0x80},
+	{0x42D3,0x80},
+	{0x42D4,0x80},
+	{0x42D5,0x80},
+	{0x42D6,0x80},
+	{0x42D7,0x80},
+	{0x42D8,0x00},
+	{0x42D9,0x00},
+	{0x4300,0xA2},
+	{0x4301,0xAA},
+	{0x4302,0xA7},
+	{0x4303,0xAD},
+	{0x4304,0x8E},
+	{0x4305,0x92},
+	{0x4306,0x90},
+	{0x4307,0x93},
+	{0x4308,0x86},
+	{0x4309,0x89},
+	{0x430A,0x87},
+	{0x430B,0x88},
+	{0x430C,0x82},
+	{0x430D,0x84},
+	{0x430E,0x83},
+	{0x430F,0x84},
+	{0x4310,0x80},
+	{0x4311,0x82},
+	{0x4312,0x82},
+	{0x4313,0x82},
+	{0x4314,0x83},
+	{0x4315,0x85},
+	{0x4316,0x84},
+	{0x4317,0x85},
+	{0x4318,0x8D},
+	{0x4319,0x8D},
+	{0x431A,0x8D},
+	{0x431B,0x8D},
+	{0x431C,0x99},
+	{0x431D,0x9A},
+	{0x431E,0x9A},
+	{0x431F,0x9A},
+	{0x4320,0xAE},
+	{0x4321,0xB4},
+	{0x4322,0xB4},
+	{0x4323,0xB5},
+	{0x4324,0x9A},
+	{0x4325,0x9D},
+	{0x4326,0x9B},
+	{0x4327,0x9E},
+	{0x4328,0x8C},
+	{0x4329,0x8F},
+	{0x432A,0x8D},
+	{0x432B,0x8F},
+	{0x432C,0x83},
+	{0x432D,0x85},
+	{0x432E,0x85},
+	{0x432F,0x85},
+	{0x4330,0x80},
+	{0x4331,0x81},
+	{0x4332,0x81},
+	{0x4333,0x81},
+	{0x4334,0x80},
+	{0x4335,0x80},
+	{0x4336,0x80},
+	{0x4337,0x81},
+	{0x4338,0x83},
+	{0x4339,0x83},
+	{0x433A,0x83},
+	{0x433B,0x83},
+	{0x433C,0x88},
+	{0x433D,0x88},
+	{0x433E,0x88},
+	{0x433F,0x88},
+	{0x4340,0x93},
+	{0x4341,0x93},
+	{0x4342,0x93},
+	{0x4343,0x93},
+	{0x4344,0xA2},
+	{0x4345,0xA4},
+	{0x4346,0xA4},
+	{0x4347,0xA4},
+	{0x4348,0x97},
+	{0x4349,0x99},
+	{0x434A,0x97},
+	{0x434B,0x97},
+	{0x434C,0x89},
+	{0x434D,0x8C},
+	{0x434E,0x8B},
+	{0x434F,0x8A},
+	{0x4350,0x81},
+	{0x4351,0x83},
+	{0x4352,0x83},
+	{0x4353,0x83},
+	{0x4354,0x7F},
+	{0x4355,0x80},
+	{0x4356,0x80},
+	{0x4357,0x80},
+	{0x4358,0x7F},
+	{0x4359,0x7F},
+	{0x435A,0x7F},
+	{0x435B,0x7F},
+	{0x435C,0x82},
+	{0x435D,0x81},
+	{0x435E,0x81},
+	{0x435F,0x82},
+	{0x4360,0x86},
+	{0x4361,0x86},
+	{0x4362,0x86},
+	{0x4363,0x87},
+	{0x4364,0x8F},
+	{0x4365,0x8F},
+	{0x4366,0x8F},
+	{0x4367,0x90},
+	{0x4368,0x9E},
+	{0x4369,0x9E},
+	{0x436A,0x9E},
+	{0x436B,0x9F},
+	{0x436C,0x99},
+	{0x436D,0x9B},
+	{0x436E,0x9A},
+	{0x436F,0x98},
+	{0x4370,0x8B},
+	{0x4371,0x8D},
+	{0x4372,0x8D},
+	{0x4373,0x8B},
+	{0x4374,0x83},
+	{0x4375,0x84},
+	{0x4376,0x84},
+	{0x4377,0x83},
+	{0x4378,0x80},
+	{0x4379,0x81},
+	{0x437A,0x81},
+	{0x437B,0x80},
+	{0x437C,0x81},
+	{0x437D,0x80},
+	{0x437E,0x80},
+	{0x437F,0x80},
+	{0x4380,0x83},
+	{0x4381,0x83},
+	{0x4382,0x83},
+	{0x4383,0x83},
+	{0x4384,0x88},
+	{0x4385,0x87},
+	{0x4386,0x87},
+	{0x4387,0x88},
+	{0x4388,0x91},
+	{0x4389,0x90},
+	{0x438A,0x90},
+	{0x438B,0x91},
+	{0x438C,0x9E},
+	{0x438D,0x9E},
+	{0x438E,0x9E},
+	{0x438F,0xA0},
+	{0x4390,0xA0},
+	{0x4391,0xA2},
+	{0x4392,0xA2},
+	{0x4393,0xA0},
+	{0x4394,0x92},
+	{0x4395,0x94},
+	{0x4396,0x94},
+	{0x4397,0x91},
+	{0x4398,0x89},
+	{0x4399,0x8A},
+	{0x439A,0x89},
+	{0x439B,0x88},
+	{0x439C,0x85},
+	{0x439D,0x85},
+	{0x439E,0x85},
+	{0x439F,0x84},
+	{0x43A0,0x85},
+	{0x43A1,0x84},
+	{0x43A2,0x84},
+	{0x43A3,0x84},
+	{0x43A4,0x88},
+	{0x43A5,0x86},
+	{0x43A6,0x86},
+	{0x43A7,0x87},
+	{0x43A8,0x8E},
+	{0x43A9,0x8B},
+	{0x43AA,0x8B},
+	{0x43AB,0x8D},
+	{0x43AC,0x97},
+	{0x43AD,0x96},
+	{0x43AE,0x96},
+	{0x43AF,0x98},
+	{0x43B0,0xA5},
+	{0x43B1,0xA5},
+	{0x43B2,0xA5},
+	{0x43B3,0xA9},
+	{0x43B4,0xB7},
+	{0x43B5,0xBB},
+	{0x43B6,0xBB},
+	{0x43B7,0xB8},
+	{0x43B8,0x9C},
+	{0x43B9,0x9C},
+	{0x43BA,0x9C},
+	{0x43BB,0x9A},
+	{0x43BC,0x92},
+	{0x43BD,0x92},
+	{0x43BE,0x92},
+	{0x43BF,0x8F},
+	{0x43C0,0x8B},
+	{0x43C1,0x8B},
+	{0x43C2,0x8B},
+	{0x43C3,0x89},
+	{0x43C4,0x8A},
+	{0x43C5,0x89},
+	{0x43C6,0x89},
+	{0x43C7,0x88},
+	{0x43C8,0x8D},
+	{0x43C9,0x8B},
+	{0x43CA,0x8B},
+	{0x43CB,0x8C},
+	{0x43CC,0x94},
+	{0x43CD,0x91},
+	{0x43CE,0x92},
+	{0x43CF,0x93},
+	{0x43D0,0x9E},
+	{0x43D1,0x9D},
+	{0x43D2,0x9D},
+	{0x43D3,0xA1},
+	{0x43D4,0xB2},
+	{0x43D5,0xB4},
+	{0x43D6,0xB5},
+	{0x43D7,0xBD},
+	{0x4400,0x80},
+	{0x4401,0x80},
+	{0x4402,0x80},
+	{0x4403,0x80},
+	{0x4404,0x80},
+	{0x4405,0x80},
+	{0x4406,0x80},
+	{0x4407,0x80},
+	{0x4408,0x80},
+	{0x4409,0x80},
+	{0x440A,0x80},
+	{0x440B,0x80},
+	{0x440C,0x80},
+	{0x440D,0x80},
+	{0x440E,0x80},
+	{0x440F,0x80},
+	{0x4410,0x80},
+	{0x4411,0x80},
+	{0x4412,0x80},
+	{0x4413,0x80},
+	{0x4414,0x80},
+	{0x4415,0x80},
+	{0x4416,0x80},
+	{0x4417,0x80},
+	{0x4418,0x80},
+	{0x4419,0x80},
+	{0x441A,0x80},
+	{0x441B,0x80},
+	{0x441C,0x80},
+	{0x441D,0x80},
+	{0x441E,0x80},
+	{0x441F,0x80},
+	{0x4420,0x80},
+	{0x4421,0x80},
+	{0x4422,0x80},
+	{0x4423,0x80},
+	{0x4424,0x80},
+	{0x4425,0x80},
+	{0x4426,0x80},
+	{0x4427,0x80},
+	{0x4428,0x80},
+	{0x4429,0x80},
+	{0x442A,0x80},
+	{0x442B,0x80},
+	{0x442C,0x80},
+	{0x442D,0x80},
+	{0x442E,0x80},
+	{0x442F,0x80},
+	{0x4430,0x80},
+	{0x4431,0x80},
+	{0x4432,0x80},
+	{0x4433,0x80},
+	{0x4434,0x80},
+	{0x4435,0x80},
+	{0x4436,0x80},
+	{0x4437,0x80},
+	{0x4438,0x80},
+	{0x4439,0x80},
+	{0x443A,0x80},
+	{0x443B,0x80},
+	{0x443C,0x80},
+	{0x443D,0x80},
+	{0x443E,0x80},
+	{0x443F,0x80},
+	{0x4440,0x80},
+	{0x4441,0x80},
+	{0x4442,0x80},
+	{0x4443,0x80},
+	{0x4444,0x80},
+	{0x4445,0x80},
+	{0x4446,0x80},
+	{0x4447,0x80},
+	{0x4448,0x80},
+	{0x4449,0x80},
+	{0x444A,0x80},
+	{0x444B,0x80},
+	{0x444C,0x80},
+	{0x444D,0x80},
+	{0x444E,0x80},
+	{0x444F,0x80},
+	{0x4450,0x80},
+	{0x4451,0x80},
+	{0x4452,0x80},
+	{0x4453,0x80},
+	{0x4454,0x80},
+	{0x4455,0x80},
+	{0x4456,0x80},
+	{0x4457,0x80},
+	{0x4458,0x80},
+	{0x4459,0x80},
+	{0x445A,0x80},
+	{0x445B,0x80},
+	{0x445C,0x80},
+	{0x445D,0x80},
+	{0x445E,0x80},
+	{0x445F,0x80},
+	{0x4460,0x80},
+	{0x4461,0x80},
+	{0x4462,0x80},
+	{0x4463,0x80},
+	{0x4464,0x80},
+	{0x4465,0x80},
+	{0x4466,0x80},
+	{0x4467,0x80},
+	{0x4468,0x80},
+	{0x4469,0x80},
+	{0x446A,0x80},
+	{0x446B,0x80},
+	{0x446C,0x80},
+	{0x446D,0x80},
+	{0x446E,0x80},
+	{0x446F,0x80},
+	{0x4470,0x80},
+	{0x4471,0x80},
+	{0x4472,0x80},
+	{0x4473,0x80},
+	{0x4474,0x80},
+	{0x4475,0x80},
+	{0x4476,0x80},
+	{0x4477,0x80},
+	{0x4478,0x80},
+	{0x4479,0x80},
+	{0x447A,0x80},
+	{0x447B,0x80},
+	{0x447C,0x80},
+	{0x447D,0x80},
+	{0x447E,0x80},
+	{0x447F,0x80},
+	{0x4480,0x80},
+	{0x4481,0x80},
+	{0x4482,0x80},
+	{0x4483,0x80},
+	{0x4484,0x80},
+	{0x4485,0x80},
+	{0x4486,0x80},
+	{0x4487,0x80},
+	{0x4488,0x80},
+	{0x4489,0x80},
+	{0x448A,0x80},
+	{0x448B,0x80},
+	{0x448C,0x80},
+	{0x448D,0x80},
+	{0x448E,0x80},
+	{0x448F,0x80},
+	{0x4490,0x80},
+	{0x4491,0x80},
+	{0x4492,0x80},
+	{0x4493,0x80},
+	{0x4494,0x80},
+	{0x4495,0x80},
+	{0x4496,0x80},
+	{0x4497,0x80},
+	{0x4498,0x80},
+	{0x4499,0x80},
+	{0x449A,0x80},
+	{0x449B,0x80},
+	{0x449C,0x80},
+	{0x449D,0x80},
+	{0x449E,0x80},
+	{0x449F,0x80},
+	{0x44A0,0x80},
+	{0x44A1,0x80},
+	{0x44A2,0x80},
+	{0x44A3,0x80},
+	{0x44A4,0x80},
+	{0x44A5,0x80},
+	{0x44A6,0x80},
+	{0x44A7,0x80},
+	{0x44A8,0x80},
+	{0x44A9,0x80},
+	{0x44AA,0x80},
+	{0x44AB,0x80},
+	{0x44AC,0x80},
+	{0x44AD,0x80},
+	{0x44AE,0x80},
+	{0x44AF,0x80},
+	{0x44B0,0x80},
+	{0x44B1,0x80},
+	{0x44B2,0x80},
+	{0x44B3,0x80},
+	{0x44B4,0x80},
+	{0x44B5,0x80},
+	{0x44B6,0x80},
+	{0x44B7,0x80},
+	{0x44B8,0x80},
+	{0x44B9,0x80},
+	{0x44BA,0x80},
+	{0x44BB,0x80},
+	{0x44BC,0x80},
+	{0x44BD,0x80},
+	{0x44BE,0x80},
+	{0x44BF,0x80},
+	{0x44C0,0x80},
+	{0x44C1,0x80},
+	{0x44C2,0x80},
+	{0x44C3,0x80},
+	{0x44C4,0x80},
+	{0x44C5,0x80},
+	{0x44C6,0x80},
+	{0x44C7,0x80},
+	{0x44C8,0x80},
+	{0x44C9,0x80},
+	{0x44CA,0x80},
+	{0x44CB,0x80},
+	{0x44CC,0x80},
+	{0x44CD,0x80},
+	{0x44CE,0x80},
+	{0x44CF,0x80},
+	{0x44D0,0x80},
+	{0x44D1,0x80},
+	{0x44D2,0x80},
+	{0x44D3,0x80},
+	{0x44D4,0x80},
+	{0x44D5,0x80},
+	{0x44D6,0x80},
+	{0x44D7,0x80},
+	{0x4500,0x80},
+	{0x4501,0x80},
+	{0x4502,0x80},
+	{0x4503,0x80},
+	{0x4504,0x80},
+	{0x4505,0x80},
+	{0x4506,0x80},
+	{0x4507,0x80},
+	{0x4508,0x80},
+	{0x4509,0x80},
+	{0x450A,0x80},
+	{0x450B,0x80},
+	{0x450C,0x80},
+	{0x450D,0x80},
+	{0x450E,0x80},
+	{0x450F,0x80},
+	{0x4510,0x80},
+	{0x4511,0x80},
+	{0x4512,0x80},
+	{0x4513,0x80},
+	{0x4514,0x80},
+	{0x4515,0x80},
+	{0x4516,0x80},
+	{0x4517,0x80},
+	{0x4518,0x80},
+	{0x4519,0x80},
+	{0x451A,0x80},
+	{0x451B,0x80},
+	{0x451C,0x80},
+	{0x451D,0x80},
+	{0x451E,0x80},
+	{0x451F,0x80},
+	{0x4520,0x80},
+	{0x4521,0x80},
+	{0x4522,0x80},
+	{0x4523,0x80},
+	{0x4524,0x80},
+	{0x4525,0x80},
+	{0x4526,0x80},
+	{0x4527,0x80},
+	{0x4528,0x80},
+	{0x4529,0x80},
+	{0x452A,0x80},
+	{0x452B,0x80},
+	{0x452C,0x80},
+	{0x452D,0x80},
+	{0x452E,0x80},
+	{0x452F,0x80},
+	{0x4530,0x80},
+	{0x4531,0x80},
+	{0x4532,0x80},
+	{0x4533,0x80},
+	{0x4534,0x80},
+	{0x4535,0x80},
+	{0x4536,0x80},
+	{0x4537,0x80},
+	{0x4538,0x80},
+	{0x4539,0x80},
+	{0x453A,0x80},
+	{0x453B,0x80},
+	{0x453C,0x80},
+	{0x453D,0x80},
+	{0x453E,0x80},
+	{0x453F,0x80},
+	{0x4540,0x80},
+	{0x4541,0x80},
+	{0x4542,0x80},
+	{0x4543,0x80},
+	{0x4544,0x80},
+	{0x4545,0x80},
+	{0x4546,0x80},
+	{0x4547,0x80},
+	{0x4548,0x80},
+	{0x4549,0x80},
+	{0x454A,0x80},
+	{0x454B,0x80},
+	{0x454C,0x80},
+	{0x454D,0x80},
+	{0x454E,0x80},
+	{0x454F,0x80},
+	{0x4550,0x80},
+	{0x4551,0x80},
+	{0x4552,0x80},
+	{0x4553,0x80},
+	{0x4554,0x80},
+	{0x4555,0x80},
+	{0x4556,0x80},
+	{0x4557,0x80},
+	{0x4558,0x80},
+	{0x4559,0x80},
+	{0x455A,0x80},
+	{0x455B,0x80},
+	{0x455C,0x80},
+	{0x455D,0x80},
+	{0x455E,0x80},
+	{0x455F,0x80},
+	{0x4560,0x80},
+	{0x4561,0x80},
+	{0x4562,0x80},
+	{0x4563,0x80},
+	{0x4564,0x80},
+	{0x4565,0x80},
+	{0x4566,0x80},
+	{0x4567,0x80},
+	{0x4568,0x80},
+	{0x4569,0x80},
+	{0x456A,0x80},
+	{0x456B,0x80},
+	{0x456C,0x80},
+	{0x456D,0x80},
+	{0x456E,0x80},
+	{0x456F,0x80},
+	{0x4570,0x80},
+	{0x4571,0x80},
+	{0x4572,0x80},
+	{0x4573,0x80},
+	{0x4574,0x80},
+	{0x4575,0x80},
+	{0x4576,0x80},
+	{0x4577,0x80},
+	{0x4578,0x80},
+	{0x4579,0x80},
+	{0x457A,0x80},
+	{0x457B,0x80},
+	{0x457C,0x80},
+	{0x457D,0x80},
+	{0x457E,0x80},
+	{0x457F,0x80},
+	{0x4580,0x80},
+	{0x4581,0x80},
+	{0x4582,0x80},
+	{0x4583,0x80},
+	{0x4584,0x80},
+	{0x4585,0x80},
+	{0x4586,0x80},
+	{0x4587,0x80},
+	{0x4588,0x80},
+	{0x4589,0x80},
+	{0x458A,0x80},
+	{0x458B,0x80},
+	{0x458C,0x80},
+	{0x458D,0x80},
+	{0x458E,0x80},
+	{0x458F,0x80},
+	{0x4590,0x80},
+	{0x4591,0x80},
+	{0x4592,0x80},
+	{0x4593,0x80},
+	{0x4594,0x80},
+	{0x4595,0x80},
+	{0x4596,0x80},
+	{0x4597,0x80},
+	{0x4598,0x80},
+	{0x4599,0x80},
+	{0x459A,0x80},
+	{0x459B,0x80},
+	{0x459C,0x80},
+	{0x459D,0x80},
+	{0x459E,0x80},
+	{0x459F,0x80},
+	{0x45A0,0x80},
+	{0x45A1,0x80},
+	{0x45A2,0x80},
+	{0x45A3,0x80},
+	{0x45A4,0x80},
+	{0x45A5,0x80},
+	{0x45A6,0x80},
+	{0x45A7,0x80},
+	{0x45A8,0x80},
+	{0x45A9,0x80},
+	{0x45AA,0x80},
+	{0x45AB,0x80},
+	{0x45AC,0x80},
+	{0x45AD,0x80},
+	{0x45AE,0x80},
+	{0x45AF,0x80},
+	{0x45B0,0x80},
+	{0x45B1,0x80},
+	{0x45B2,0x80},
+	{0x45B3,0x80},
+	{0x45B4,0x80},
+	{0x45B5,0x80},
+	{0x45B6,0x80},
+	{0x45B7,0x80},
+	{0x45B8,0x80},
+	{0x45B9,0x80},
+	{0x45BA,0x80},
+	{0x45BB,0x80},
+	{0x45BC,0x80},
+	{0x45BD,0x80},
+	{0x45BE,0x80},
+	{0x45BF,0x80},
+	{0x45C0,0x80},
+	{0x45C1,0x80},
+	{0x45C2,0x80},
+	{0x45C3,0x80},
+	{0x45C4,0x80},
+	{0x45C5,0x80},
+	{0x45C6,0x80},
+	{0x45C7,0x80},
+	{0x45C8,0x80},
+	{0x45C9,0x80},
+	{0x45CA,0x80},
+	{0x45CB,0x80},
+	{0x45CC,0x80},
+	{0x45CD,0x80},
+	{0x45CE,0x80},
+	{0x45CF,0x80},
+	{0x45D0,0x80},
+	{0x45D1,0x80},
+	{0x45D2,0x80},
+	{0x45D3,0x80},
+	{0x45D4,0x80},
+	{0x45D5,0x80},
+	{0x45D6,0x80},
+	{0x45D7,0x80},
+	{0x7000,0xAB},
+	{0x7001,0xBA},
+	{0x7002,0x40},
+	{0x7003,0x02},
+	{0x7004,0x00},
+	{0x7005,0x00},
+	{0x7006,0x00},
+	{0x7007,0x00},
+	{0x7008,0x00},
+	{0x7009,0x00},
+	{0x700A,0x00},
+	{0x700B,0x00},
+	{0x700C,0x00},
+	{0x700D,0x00},
+	{0x700E,0x00},
+	{0x700F,0x00},
+	{0x7010,0x55},
+	{0x7011,0x88},
+	{0x7012,0x40},
+	{0x7013,0x01},
+	{0x7014,0x72},
+	{0x7015,0xF1},
+	{0x7016,0x02},
+	{0x7017,0xF8},
+	{0x7018,0x00},
+	{0x7019,0x00},
+	{0x701A,0x00},
+	{0x701B,0x00},
+	{0x701C,0x00},
+	{0x701D,0x00},
+	{0x701E,0x00},
+	{0x701F,0x00},
+	{0x7020,0x00},
+	{0x7021,0x00},
+	{0x7022,0x00},
+	{0x7023,0x00},
+	{0x7024,0x00},
+	{0x7025,0x00},
+	{0x7026,0x00},
+	{0x7027,0x00},
+	{0x7028,0x00},
+	{0x7029,0x00},
+	{0x702A,0x00},
+	{0x702B,0x00},
+	{0x702C,0x00},
+	{0x702D,0x00},
+	{0x702E,0x00},
+	{0x702F,0x00},
+	{0x7030,0x00},
+	{0x7031,0x00},
+	{0x7032,0x00},
+	{0x7033,0x00},
+	{0x7034,0x00},
+	{0x7035,0x00},
+	{0x7036,0x00},
+	{0x7037,0x00},
+	{0x7038,0x00},
+	{0x7039,0x00},
+	{0x703A,0x00},
+	{0x703B,0x00},
+	{0x703C,0x00},
+	{0x703D,0x00},
+	{0x703E,0x00},
+	{0x703F,0x00},
+	{0x7040,0x00},
+	{0x7041,0x00},
+	{0x7042,0x00},
+	{0x7043,0x00},
+	{0x7044,0x00},
+	{0x7045,0x00},
+	{0x7046,0x00},
+	{0x7047,0x00},
+	{0x7048,0x00},
+	{0x7049,0x00},
+	{0x704A,0x00},
+	{0x704B,0x00},
+	{0x704C,0x00},
+	{0x704D,0x00},
+	{0x704E,0x00},
+	{0x704F,0x00},
+	{0x7050,0x00},
+	{0x7051,0x00},
+	{0x7052,0x00},
+	{0x7053,0x00},
+	{0x7054,0x00},
+	{0x7055,0x00},
+	{0x7056,0x00},
+	{0x7057,0x00},
+	{0x7058,0x00},
+	{0x7059,0x00},
+	{0x705A,0x00},
+	{0x705B,0x00},
+	{0x705C,0x00},
+	{0x705D,0x00},
+	{0x705E,0x00},
+	{0x705F,0x00},
+	{0x7060,0x00},
+	{0x7061,0x00},
+	{0x7062,0x00},
+	{0x7063,0x00},
+	{0x7064,0x00},
+	{0x7065,0x00},
+	{0x7066,0x00},
+	{0x7067,0x00},
+	{0x7068,0x00},
+	{0x7069,0x00},
+	{0x706A,0x00},
+	{0x706B,0x00},
+	{0x706C,0x00},
+	{0x706D,0x00},
+	{0x706E,0x00},
+	{0x706F,0x00},
+	{0x7070,0x00},
+	{0x7071,0x00},
+	{0x7072,0x00},
+	{0x7073,0x00},
+	{0x7074,0x00},
+	{0x7075,0x00},
+	{0x7076,0x00},
+	{0x7077,0x00},
+	{0x7078,0x00},
+	{0x7079,0x00},
+	{0x707A,0x00},
+	{0x707B,0x00},
+	{0x707C,0x00},
+	{0x707D,0x00},
+	{0x707E,0x00},
+	{0x707F,0x00},
+	{0x7080,0x00},
+	{0x7081,0x00},
+	{0x7082,0x00},
+	{0x7083,0x00},
+	{0x7084,0x00},
+	{0x7085,0x00},
+	{0x7086,0x00},
+	{0x7087,0x00},
+	{0x7088,0x00},
+	{0x7089,0x00},
+	{0x708A,0x00},
+	{0x708B,0x00},
+	{0x708C,0x00},
+	{0x708D,0x00},
+	{0x708E,0x00},
+	{0x708F,0x00},
+	{0x7090,0x00},
+	{0x7091,0xF0},
+	{0x7092,0x02},
+	{0x7093,0xF8},
+	{0x7094,0x8D},
+	{0x7095,0xF6},
+	{0x7096,0xFA},
+	{0x7097,0xFF},
+	{0x7098,0xF0},
+	{0x7099,0xB5},
+	{0x709A,0x04},
+	{0x709B,0x46},
+	{0x709C,0x8F},
+	{0x709D,0xB0},
+	{0x709E,0x5F},
+	{0x709F,0x48},
+	{0x70A0,0x0C},
+	{0x70A1,0x90},
+	{0x70A2,0x5F},
+	{0x70A3,0x48},
+	{0x70A4,0x06},
+	{0x70A5,0x90},
+	{0x70A6,0x20},
+	{0x70A7,0x46},
+	{0x70A8,0x34},
+	{0x70A9,0x30},
+	{0x70AA,0x0B},
+	{0x70AB,0x90},
+	{0x70AC,0x5B},
+	{0x70AD,0x48},
+	{0x70AE,0x5A},
+	{0x70AF,0x49},
+	{0x70B0,0x26},
+	{0x70B1,0x46},
+	{0x70B2,0x66},
+	{0x70B3,0x30},
+	{0x70B4,0x3A},
+	{0x70B5,0x31},
+	{0x70B6,0x3C},
+	{0x70B7,0x36},
+	{0x70B8,0x05},
+	{0x70B9,0x90},
+	{0x70BA,0x0A},
+	{0x70BB,0x30},
+	{0x70BC,0x04},
+	{0x70BD,0x90},
+	{0x70BE,0x59},
+	{0x70BF,0x48},
+	{0x70C0,0x55},
+	{0x70C1,0x4A},
+	{0x70C2,0x40},
+	{0x70C3,0x6E},
+	{0x70C4,0xC0},
+	{0x70C5,0x07},
+	{0x70C6,0x7D},
+	{0x70C7,0xD1},
+	{0x70C8,0x17},
+	{0x70C9,0x88},
+	{0x70CA,0x0A},
+	{0x70CB,0x5E},
+	{0x70CC,0x0D},
+	{0x70CD,0x92},
+	{0x70CE,0x53},
+	{0x70CF,0x49},
+	{0x70D0,0x55},
+	{0x70D1,0x48},
+	{0x70D2,0x94},
+	{0x70D3,0x31},
+	{0x70D4,0x89},
+	{0x70D5,0x6B},
+	{0x70D6,0x80},
+	{0x70D7,0x68},
+	{0x70D8,0x09},
+	{0x70D9,0x02},
+	{0x70DA,0x00},
+	{0x70DB,0x03},
+	{0x70DC,0x09},
+	{0x70DD,0x0E},
+	{0x70DE,0x00},
+	{0x70DF,0x0B},
+	{0x70E0,0x49},
+	{0x70E1,0x1C},
+	{0x70E2,0x48},
+	{0x70E3,0x43},
+	{0x70E4,0x4D},
+	{0x70E5,0x49},
+	{0x70E6,0x6C},
+	{0x70E7,0x39},
+	{0x70E8,0x8A},
+	{0x70E9,0x6A},
+	{0x70EA,0x07},
+	{0x70EB,0x92},
+	{0x70EC,0xCA},
+	{0x70ED,0x6A},
+	{0x70EE,0x00},
+	{0x70EF,0x21},
+	{0x70F0,0xC9},
+	{0x70F1,0x43},
+	{0x70F2,0x03},
+	{0x70F3,0x92},
+	{0x70F4,0x00},
+	{0x70F5,0x22},
+	{0x70F6,0x00},
+	{0x70F7,0x91},
+	{0x70F8,0x01},
+	{0x70F9,0x92},
+	{0x70FA,0x39},
+	{0x70FB,0x46},
+	{0x70FC,0x8F},
+	{0x70FD,0xF6},
+	{0x70FE,0xCE},
+	{0x70FF,0xFB},
+	{0x7100,0x01},
+	{0x7101,0x22},
+	{0x7102,0x00},
+	{0x7103,0x23},
+	{0x7104,0x8C},
+	{0x7105,0xF6},
+	{0x7106,0x02},
+	{0x7107,0xFA},
+	{0x7108,0x00},
+	{0x7109,0x21},
+	{0x710A,0x05},
+	{0x710B,0x46},
+	{0x710C,0x01},
+	{0x710D,0x91},
+	{0x710E,0x00},
+	{0x710F,0x90},
+	{0x7110,0x39},
+	{0x7111,0x46},
+	{0x7112,0x07},
+	{0x7113,0x98},
+	{0x7114,0x8F},
+	{0x7115,0xF6},
+	{0x7116,0xC2},
+	{0x7117,0xFB},
+	{0x7118,0x0D},
+	{0x7119,0x9A},
+	{0x711A,0xD3},
+	{0x711B,0x17},
+	{0x711C,0x80},
+	{0x711D,0x18},
+	{0x711E,0x59},
+	{0x711F,0x41},
+	{0x7120,0x01},
+	{0x7121,0x22},
+	{0x7122,0x00},
+	{0x7123,0x23},
+	{0x7124,0x8C},
+	{0x7125,0xF6},
+	{0x7126,0xCD},
+	{0x7127,0xF9},
+	{0x7128,0x07},
+	{0x7129,0x90},
+	{0x712A,0x00},
+	{0x712B,0x20},
+	{0x712C,0x01},
+	{0x712D,0x90},
+	{0x712E,0x00},
+	{0x712F,0x95},
+	{0x7130,0x39},
+	{0x7131,0x46},
+	{0x7132,0x03},
+	{0x7133,0x98},
+	{0x7134,0x8F},
+	{0x7135,0xF6},
+	{0x7136,0xB2},
+	{0x7137,0xFB},
+	{0x7138,0x01},
+	{0x7139,0x22},
+	{0x713A,0x00},
+	{0x713B,0x23},
+	{0x713C,0x8C},
+	{0x713D,0xF6},
+	{0x713E,0xE6},
+	{0x713F,0xF9},
+	{0x7140,0x02},
+	{0x7141,0x46},
+	{0x7142,0x07},
+	{0x7143,0x98},
+	{0x7144,0x00},
+	{0x7145,0x23},
+	{0x7146,0x81},
+	{0x7147,0x0B},
+	{0x7148,0x80},
+	{0x7149,0x04},
+	{0x714A,0x7A},
+	{0x714B,0xF6},
+	{0x714C,0x54},
+	{0x714D,0xF8},
+	{0x714E,0x37},
+	{0x714F,0x4A},
+	{0x7150,0x00},
+	{0x7151,0x23},
+	{0x7152,0x00},
+	{0x7153,0x92},
+	{0x7154,0x01},
+	{0x7155,0x93},
+	{0x7156,0x01},
+	{0x7157,0x22},
+	{0x7158,0x8C},
+	{0x7159,0xF6},
+	{0x715A,0xD8},
+	{0x715B,0xF9},
+	{0x715C,0x05},
+	{0x715D,0x46},
+	{0x715E,0x60},
+	{0x715F,0x68},
+	{0x7160,0x00},
+	{0x7161,0x23},
+	{0x7162,0x01},
+	{0x7163,0x0C},
+	{0x7164,0x00},
+	{0x7165,0x04},
+	{0x7166,0xE2},
+	{0x7167,0x68},
+	{0x7168,0x7A},
+	{0x7169,0xF6},
+	{0x716A,0x45},
+	{0x716B,0xF8},
+	{0x716C,0x00},
+	{0x716D,0x22},
+	{0x716E,0xD2},
+	{0x716F,0x43},
+	{0x7170,0x00},
+	{0x7171,0x23},
+	{0x7172,0x00},
+	{0x7173,0x92},
+	{0x7174,0x01},
+	{0x7175,0x93},
+	{0x7176,0x1A},
+	{0x7177,0x46},
+	{0x7178,0x8C},
+	{0x7179,0xF6},
+	{0x717A,0xC8},
+	{0x717B,0xF9},
+	{0x717C,0x29},
+	{0x717D,0x46},
+	{0x717E,0x8F},
+	{0x717F,0xF6},
+	{0x7180,0x8D},
+	{0x7181,0xFB},
+	{0x7182,0x8A},
+	{0x7183,0x03},
+	{0x7184,0x80},
+	{0x7185,0x0C},
+	{0x7186,0x10},
+	{0x7187,0x43},
+	{0x7188,0x00},
+	{0x7189,0x22},
+	{0x718A,0xD2},
+	{0x718B,0x43},
+	{0x718C,0x00},
+	{0x718D,0x23},
+	{0x718E,0x00},
+	{0x718F,0x92},
+	{0x7190,0x89},
+	{0x7191,0x0C},
+	{0x7192,0x01},
+	{0x7193,0x93},
+	{0x7194,0x1A},
+	{0x7195,0x46},
+	{0x7196,0x8C},
+	{0x7197,0xF6},
+	{0x7198,0xB9},
+	{0x7199,0xF9},
+	{0x719A,0x00},
+	{0x719B,0x24},
+	{0x719C,0x03},
+	{0x719D,0x90},
+	{0x719E,0x0C},
+	{0x719F,0x98},
+	{0x71A0,0x61},
+	{0x71A1,0x00},
+	{0x71A2,0x45},
+	{0x71A3,0x5A},
+	{0x71A4,0x06},
+	{0x71A5,0x98},
+	{0x71A6,0x22},
+	{0x71A7,0x4A},
+	{0x71A8,0x40},
+	{0x71A9,0x5A},
+	{0x71AA,0x00},
+	{0x71AB,0x21},
+	{0x71AC,0x8C},
+	{0x71AD,0xF6},
+	{0x71AE,0xBE},
+	{0x71AF,0xF9},
+	{0x71B0,0x07},
+	{0x71B1,0x46},
+	{0x71B2,0x28},
+	{0x71B3,0x46},
+	{0x71B4,0x03},
+	{0x71B5,0x99},
+	{0x71B6,0x8F},
+	{0x71B7,0xF6},
+	{0x71B8,0x71},
+	{0x71B9,0xFB},
+	{0x71BA,0x3A},
+	{0x71BB,0x46},
+	{0x71BC,0x00},
+	{0x71BD,0x23},
+	{0x71BE,0x79},
+	{0x71BF,0xF6},
+	{0x71C0,0xCA},
+	{0x71C1,0xFF},
+	{0x71C2,0x00},
+	{0x71C3,0xE0},
+	{0x71C4,0x0F},
+	{0x71C5,0xE0},
+	{0x71C6,0x8A},
+	{0x71C7,0x02},
+	{0x71C8,0x80},
+	{0x71C9,0x0D},
+	{0x71CA,0x10},
+	{0x71CB,0x43},
+	{0x71CC,0x19},
+	{0x71CD,0x4A},
+	{0x71CE,0x00},
+	{0x71CF,0x23},
+	{0x71D0,0x00},
+	{0x71D1,0x92},
+	{0x71D2,0x89},
+	{0x71D3,0x0D},
+	{0x71D4,0x01},
+	{0x71D5,0x93},
+	{0x71D6,0x40},
+	{0x71D7,0x22},
+	{0x71D8,0x8C},
+	{0x71D9,0xF6},
+	{0x71DA,0x98},
+	{0x71DB,0xF9},
+	{0x71DC,0xA1},
+	{0x71DD,0x00},
+	{0x71DE,0x64},
+	{0x71DF,0x1C},
+	{0x71E0,0x70},
+	{0x71E1,0x50},
+	{0x71E2,0x04},
+	{0x71E3,0x2C},
+	{0x71E4,0xDB},
+	{0x71E5,0xD3},
+	{0x71E6,0x14},
+	{0x71E7,0x4D},
+	{0x71E8,0x00},
+	{0x71E9,0x24},
+	{0x71EA,0x0B},
+	{0x71EB,0x98},
+	{0x71EC,0x67},
+	{0x71ED,0x00},
+	{0x71EE,0xC0},
+	{0x71EF,0x5B},
+	{0x71F0,0x2A},
+	{0x71F1,0x46},
+	{0x71F2,0x40},
+	{0x71F3,0x21},
+	{0x71F4,0x8C},
+	{0x71F5,0xF6},
+	{0x71F6,0x9A},
+	{0x71F7,0xF9},
+	{0x71F8,0x05},
+	{0x71F9,0x99},
+	{0x71FA,0x0E},
+	{0x71FB,0x4A},
+	{0x71FC,0xC8},
+	{0x71FD,0x53},
+	{0x71FE,0xA7},
+	{0x71FF,0x00},
+	{0x7200,0xF0},
+	{0x7201,0x59},
+	{0x7202,0x40},
+	{0x7203,0x21},
+	{0x7204,0x8C},
+	{0x7205,0xF6},
+	{0x7206,0x7B},
+	{0x7207,0xF9},
+	{0x7208,0x04},
+	{0x7209,0x99},
+	{0x720A,0x64},
+	{0x720B,0x1C},
+	{0x720C,0xC8},
+	{0x720D,0x51},
+	{0x720E,0x04},
+	{0x720F,0x2C},
+	{0x7210,0xEB},
+	{0x7211,0xD3},
+	{0x7212,0x0F},
+	{0x7213,0xB0},
+	{0x7214,0xF0},
+	{0x7215,0xBD},
+	{0x7216,0x00},
+	{0x7217,0x00},
+	{0x7218,0x76},
+	{0x7219,0x69},
+	{0x721A,0x18},
+	{0x721B,0x00},
+	{0x721C,0xEC},
+	{0x721D,0x58},
+	{0x721E,0x18},
+	{0x721F,0x00},
+	{0x7220,0x38},
+	{0x7221,0x36},
+	{0x7222,0x18},
+	{0x7223,0x00},
+	{0x7224,0x00},
+	{0x7225,0x35},
+	{0x7226,0x18},
+	{0x7227,0x00},
+	{0x7228,0x00},
+	{0x7229,0x20},
+	{0x722A,0x18},
+	{0x722B,0x00},
+	{0x722C,0xFF},
+	{0x722D,0xFF},
+	{0x722E,0xFF},
+	{0x722F,0x3F},
+	{0x7230,0xFF},
+	{0x7231,0x07},
+	{0x7232,0x00},
+	{0x7233,0x00},
+	{0x7234,0xFF},
+	{0x7235,0xFF},
+	{0x7236,0x07},
+	{0x7237,0x00},
+	{0x7238,0xFF},
+	{0x7239,0x1F},
+	{0x723A,0x00},
+	{0x723B,0x00},
+	{0x723C,0x01},
+	{0x723D,0xF6},
+	{0x723E,0x45},
+	{0x723F,0x12},
+
+	/* @todo break this out for different lenses and add dts
+	 * parameter to select lens...might need plugin manager
+	 * addition...or utilize model... */
+	/* DSL945 lens gain */
+	{0x3630,0x042},
+	{0x3632,0x045},
+	{0x3634,0x044},
+	{0x3636,0x044},
+	{0x3638,0x046},
+	{0x363A,0x04D},
+	{0x363C,0x04B},
+	{0x363E,0x049},
+	{0x34C0,0x00E2},
+	{0x34C2,0x00E6},
+	{0x34C4,0x00E4},
+	{0x34C6,0x00E4},
+	{0x34C8,0x2D90},
+	{0x34CA,0x2CEA},
+	{0x34CC,0x2C9E},
+	{0x34CE,0x29D9},
+	{0x3838,0x000C},
+	{0x383A,0x0012},
+	{0x383C,0xFFCC},
+	{0x383E,0xFFEA},
+	{0x3840,0xFFAC},
+	{0x3842,0xFFB5},
+	{0x3844,0xFFC4},
+	{0x3846,0xFFC6},
+	{0x3848,0xFFB9},
+	{0x384A,0xFFC2},
+	{0x384C,0xFFCA},
+	{0x384E,0xFFC8},
+
+	/* @todo break this out for different lenses and add dts
+	 * parameter to select lens...might need plugin manager
+	 * addition...or utilize model... */
+	/* DSL945 lens SHD */
+	{0x01D0, 0x0},
+	{0x3AF6, 0x1},
+	{0x4000, 0x81},
+	{0x4001, 0x6F},
+	{0x4002, 0x6F},
+	{0x4003, 0x6B},
+	{0x4004, 0x68},
+	{0x4005, 0x5D},
+	{0x4006, 0x5D},
+	{0x4007, 0x5A},
+	{0x4008, 0x58},
+	{0x4009, 0x51},
+	{0x400A, 0x51},
+	{0x400B, 0x50},
+	{0x400C, 0x4E},
+	{0x400D, 0x4A},
+	{0x400E, 0x4A},
+	{0x400F, 0x49},
+	{0x4010, 0x4A},
+	{0x4011, 0x48},
+	{0x4012, 0x47},
+	{0x4013, 0x47},
+	{0x4014, 0x4C},
+	{0x4015, 0x49},
+	{0x4016, 0x48},
+	{0x4017, 0x48},
+	{0x4018, 0x53},
+	{0x4019, 0x4E},
+	{0x401A, 0x4E},
+	{0x401B, 0x4C},
+	{0x401C, 0x60},
+	{0x401D, 0x57},
+	{0x401E, 0x57},
+	{0x401F, 0x55},
+	{0x4020, 0x73},
+	{0x4021, 0x65},
+	{0x4022, 0x65},
+	{0x4023, 0x62},
+	{0x4024, 0x76},
+	{0x4025, 0x67},
+	{0x4026, 0x68},
+	{0x4027, 0x64},
+	{0x4028, 0x63},
+	{0x4029, 0x59},
+	{0x402A, 0x59},
+	{0x402B, 0x57},
+	{0x402C, 0x4F},
+	{0x402D, 0x4B},
+	{0x402E, 0x4B},
+	{0x402F, 0x49},
+	{0x4030, 0x46},
+	{0x4031, 0x44},
+	{0x4032, 0x44},
+	{0x4033, 0x44},
+	{0x4034, 0x43},
+	{0x4035, 0x42},
+	{0x4036, 0x42},
+	{0x4037, 0x42},
+	{0x4038, 0x45},
+	{0x4039, 0x43},
+	{0x403A, 0x43},
+	{0x403B, 0x43},
+	{0x403C, 0x4B},
+	{0x403D, 0x48},
+	{0x403E, 0x48},
+	{0x403F, 0x47},
+	{0x4040, 0x5C},
+	{0x4041, 0x54},
+	{0x4042, 0x54},
+	{0x4043, 0x52},
+	{0x4044, 0x6A},
+	{0x4045, 0x5F},
+	{0x4046, 0x5E},
+	{0x4047, 0x5C},
+	{0x4048, 0x72},
+	{0x4049, 0x64},
+	{0x404A, 0x65},
+	{0x404B, 0x61},
+	{0x404C, 0x5C},
+	{0x404D, 0x54},
+	{0x404E, 0x54},
+	{0x404F, 0x52},
+	{0x4050, 0x4A},
+	{0x4051, 0x47},
+	{0x4052, 0x47},
+	{0x4053, 0x47},
+	{0x4054, 0x43},
+	{0x4055, 0x42},
+	{0x4056, 0x42},
+	{0x4057, 0x42},
+	{0x4058, 0x40},
+	{0x4059, 0x40},
+	{0x405A, 0x40},
+	{0x405B, 0x40},
+	{0x405C, 0x41},
+	{0x405D, 0x41},
+	{0x405E, 0x41},
+	{0x405F, 0x40},
+	{0x4060, 0x47},
+	{0x4061, 0x45},
+	{0x4062, 0x45},
+	{0x4063, 0x44},
+	{0x4064, 0x55},
+	{0x4065, 0x4F},
+	{0x4066, 0x4F},
+	{0x4067, 0x4E},
+	{0x4068, 0x67},
+	{0x4069, 0x5C},
+	{0x406A, 0x5C},
+	{0x406B, 0x5A},
+	{0x406C, 0x75},
+	{0x406D, 0x66},
+	{0x406E, 0x66},
+	{0x406F, 0x63},
+	{0x4070, 0x5D},
+	{0x4071, 0x55},
+	{0x4072, 0x55},
+	{0x4073, 0x53},
+	{0x4074, 0x4B},
+	{0x4075, 0x48},
+	{0x4076, 0x48},
+	{0x4077, 0x47},
+	{0x4078, 0x43},
+	{0x4079, 0x42},
+	{0x407A, 0x42},
+	{0x407B, 0x42},
+	{0x407C, 0x40},
+	{0x407D, 0x40},
+	{0x407E, 0x40},
+	{0x407F, 0x40},
+	{0x4080, 0x42},
+	{0x4081, 0x41},
+	{0x4082, 0x41},
+	{0x4083, 0x41},
+	{0x4084, 0x48},
+	{0x4085, 0x46},
+	{0x4086, 0x46},
+	{0x4087, 0x45},
+	{0x4088, 0x56},
+	{0x4089, 0x50},
+	{0x408A, 0x50},
+	{0x408B, 0x4F},
+	{0x408C, 0x68},
+	{0x408D, 0x5D},
+	{0x408E, 0x5D},
+	{0x408F, 0x5B},
+	{0x4090, 0x7C},
+	{0x4091, 0x6C},
+	{0x4092, 0x6C},
+	{0x4093, 0x68},
+	{0x4094, 0x69},
+	{0x4095, 0x5D},
+	{0x4096, 0x5E},
+	{0x4097, 0x5B},
+	{0x4098, 0x52},
+	{0x4099, 0x4D},
+	{0x409A, 0x4D},
+	{0x409B, 0x4C},
+	{0x409C, 0x48},
+	{0x409D, 0x46},
+	{0x409E, 0x46},
+	{0x409F, 0x45},
+	{0x40A0, 0x45},
+	{0x40A1, 0x44},
+	{0x40A2, 0x44},
+	{0x40A3, 0x43},
+	{0x40A4, 0x47},
+	{0x40A5, 0x45},
+	{0x40A6, 0x45},
+	{0x40A7, 0x44},
+	{0x40A8, 0x4E},
+	{0x40A9, 0x4A},
+	{0x40AA, 0x4A},
+	{0x40AB, 0x49},
+	{0x40AC, 0x5F},
+	{0x40AD, 0x57},
+	{0x40AE, 0x57},
+	{0x40AF, 0x55},
+	{0x40B0, 0x6E},
+	{0x40B1, 0x62},
+	{0x40B2, 0x62},
+	{0x40B3, 0x60},
+	{0x40B4, 0x8B},
+	{0x40B5, 0x76},
+	{0x40B6, 0x77},
+	{0x40B7, 0x72},
+	{0x40B8, 0x71},
+	{0x40B9, 0x63},
+	{0x40BA, 0x63},
+	{0x40BB, 0x60},
+	{0x40BC, 0x5E},
+	{0x40BD, 0x56},
+	{0x40BE, 0x56},
+	{0x40BF, 0x54},
+	{0x40C0, 0x53},
+	{0x40C1, 0x4D},
+	{0x40C2, 0x4D},
+	{0x40C3, 0x4C},
+	{0x40C4, 0x4F},
+	{0x40C5, 0x4B},
+	{0x40C6, 0x4B},
+	{0x40C7, 0x4A},
+	{0x40C8, 0x51},
+	{0x40C9, 0x4C},
+	{0x40CA, 0x4C},
+	{0x40CB, 0x4B},
+	{0x40CC, 0x58},
+	{0x40CD, 0x52},
+	{0x40CE, 0x52},
+	{0x40CF, 0x50},
+	{0x40D0, 0x66},
+	{0x40D1, 0x5C},
+	{0x40D2, 0x5C},
+	{0x40D3, 0x5A},
+	{0x40D4, 0x7A},
+	{0x40D5, 0x6B},
+	{0x40D6, 0x6B},
+	{0x40D7, 0x68},
+	{0x4300, 0x7D},
+	{0x4301, 0x7F},
+	{0x4302, 0x7C},
+	{0x4303, 0x85},
+	{0x4304, 0x7A},
+	{0x4305, 0x7E},
+	{0x4306, 0x7C},
+	{0x4307, 0x81},
+	{0x4308, 0x7B},
+	{0x4309, 0x7E},
+	{0x430A, 0x7D},
+	{0x430B, 0x80},
+	{0x430C, 0x7D},
+	{0x430D, 0x7F},
+	{0x430E, 0x7F},
+	{0x430F, 0x82},
+	{0x4310, 0x7F},
+	{0x4311, 0x80},
+	{0x4312, 0x80},
+	{0x4313, 0x83},
+	{0x4314, 0x81},
+	{0x4315, 0x83},
+	{0x4316, 0x83},
+	{0x4317, 0x83},
+	{0x4318, 0x83},
+	{0x4319, 0x85},
+	{0x431A, 0x85},
+	{0x431B, 0x86},
+	{0x431C, 0x86},
+	{0x431D, 0x85},
+	{0x431E, 0x84},
+	{0x431F, 0x87},
+	{0x4320, 0x8B},
+	{0x4321, 0x87},
+	{0x4322, 0x86},
+	{0x4323, 0x8D},
+	{0x4324, 0x7C},
+	{0x4325, 0x7E},
+	{0x4326, 0x7C},
+	{0x4327, 0x84},
+	{0x4328, 0x7B},
+	{0x4329, 0x7D},
+	{0x432A, 0x7C},
+	{0x432B, 0x80},
+	{0x432C, 0x7B},
+	{0x432D, 0x7D},
+	{0x432E, 0x7D},
+	{0x432F, 0x7F},
+	{0x4330, 0x7D},
+	{0x4331, 0x7E},
+	{0x4332, 0x7E},
+	{0x4333, 0x7F},
+	{0x4334, 0x7F},
+	{0x4335, 0x7F},
+	{0x4336, 0x7F},
+	{0x4337, 0x80},
+	{0x4338, 0x81},
+	{0x4339, 0x82},
+	{0x433A, 0x82},
+	{0x433B, 0x82},
+	{0x433C, 0x83},
+	{0x433D, 0x83},
+	{0x433E, 0x83},
+	{0x433F, 0x84},
+	{0x4340, 0x86},
+	{0x4341, 0x85},
+	{0x4342, 0x84},
+	{0x4343, 0x87},
+	{0x4344, 0x8A},
+	{0x4345, 0x85},
+	{0x4346, 0x84},
+	{0x4347, 0x8B},
+	{0x4348, 0x7E},
+	{0x4349, 0x7E},
+	{0x434A, 0x7C},
+	{0x434B, 0x84},
+	{0x434C, 0x7B},
+	{0x434D, 0x7E},
+	{0x434E, 0x7C},
+	{0x434F, 0x80},
+	{0x4350, 0x7C},
+	{0x4351, 0x7E},
+	{0x4352, 0x7D},
+	{0x4353, 0x7E},
+	{0x4354, 0x7E},
+	{0x4355, 0x7F},
+	{0x4356, 0x7F},
+	{0x4357, 0x7F},
+	{0x4358, 0x80},
+	{0x4359, 0x80},
+	{0x435A, 0x80},
+	{0x435B, 0x80},
+	{0x435C, 0x81},
+	{0x435D, 0x82},
+	{0x435E, 0x81},
+	{0x435F, 0x81},
+	{0x4360, 0x83},
+	{0x4361, 0x83},
+	{0x4362, 0x83},
+	{0x4363, 0x83},
+	{0x4364, 0x86},
+	{0x4365, 0x85},
+	{0x4366, 0x84},
+	{0x4367, 0x87},
+	{0x4368, 0x8A},
+	{0x4369, 0x88},
+	{0x436A, 0x86},
+	{0x436B, 0x8D},
+	{0x436C, 0x7F},
+	{0x436D, 0x80},
+	{0x436E, 0x7E},
+	{0x436F, 0x85},
+	{0x4370, 0x7D},
+	{0x4371, 0x7F},
+	{0x4372, 0x7E},
+	{0x4373, 0x81},
+	{0x4374, 0x7D},
+	{0x4375, 0x7F},
+	{0x4376, 0x7F},
+	{0x4377, 0x80},
+	{0x4378, 0x7F},
+	{0x4379, 0x80},
+	{0x437A, 0x80},
+	{0x437B, 0x80},
+	{0x437C, 0x81},
+	{0x437D, 0x81},
+	{0x437E, 0x81},
+	{0x437F, 0x81},
+	{0x4380, 0x82},
+	{0x4381, 0x82},
+	{0x4382, 0x82},
+	{0x4383, 0x82},
+	{0x4384, 0x83},
+	{0x4385, 0x84},
+	{0x4386, 0x84},
+	{0x4387, 0x84},
+	{0x4388, 0x86},
+	{0x4389, 0x86},
+	{0x438A, 0x85},
+	{0x438B, 0x88},
+	{0x438C, 0x8B},
+	{0x438D, 0x88},
+	{0x438E, 0x87},
+	{0x438F, 0x8E},
+	{0x4390, 0x81},
+	{0x4391, 0x82},
+	{0x4392, 0x80},
+	{0x4393, 0x87},
+	{0x4394, 0x7F},
+	{0x4395, 0x81},
+	{0x4396, 0x80},
+	{0x4397, 0x83},
+	{0x4398, 0x7F},
+	{0x4399, 0x81},
+	{0x439A, 0x81},
+	{0x439B, 0x82},
+	{0x439C, 0x81},
+	{0x439D, 0x82},
+	{0x439E, 0x82},
+	{0x439F, 0x83},
+	{0x43A0, 0x82},
+	{0x43A1, 0x82},
+	{0x43A2, 0x82},
+	{0x43A3, 0x83},
+	{0x43A4, 0x83},
+	{0x43A5, 0x84},
+	{0x43A6, 0x84},
+	{0x43A7, 0x84},
+	{0x43A8, 0x84},
+	{0x43A9, 0x86},
+	{0x43AA, 0x85},
+	{0x43AB, 0x86},
+	{0x43AC, 0x87},
+	{0x43AD, 0x87},
+	{0x43AE, 0x87},
+	{0x43AF, 0x89},
+	{0x43B0, 0x8C},
+	{0x43B1, 0x8A},
+	{0x43B2, 0x88},
+	{0x43B3, 0x90},
+	{0x43B4, 0x85},
+	{0x43B5, 0x85},
+	{0x43B6, 0x83},
+	{0x43B7, 0x89},
+	{0x43B8, 0x83},
+	{0x43B9, 0x83},
+	{0x43BA, 0x82},
+	{0x43BB, 0x86},
+	{0x43BC, 0x82},
+	{0x43BD, 0x84},
+	{0x43BE, 0x83},
+	{0x43BF, 0x85},
+	{0x43C0, 0x82},
+	{0x43C1, 0x84},
+	{0x43C2, 0x84},
+	{0x43C3, 0x86},
+	{0x43C4, 0x83},
+	{0x43C5, 0x85},
+	{0x43C6, 0x85},
+	{0x43C7, 0x87},
+	{0x43C8, 0x84},
+	{0x43C9, 0x87},
+	{0x43CA, 0x86},
+	{0x43CB, 0x88},
+	{0x43CC, 0x87},
+	{0x43CD, 0x87},
+	{0x43CE, 0x87},
+	{0x43CF, 0x88},
+	{0x43D0, 0x89},
+	{0x43D1, 0x89},
+	{0x43D2, 0x88},
+	{0x43D3, 0x8B},
+	{0x43D4, 0x8E},
+	{0x43D5, 0x8B},
+	{0x43D6, 0x8A},
+	{0x43D7, 0x91},
+	{0x01D0, 0x1},
+
+	/* set post-pedestal to zero (post PWL) */
+	{0x0138, 0x00},
+	{0x0139, 0x00},
+};
+const size_t imx390_mode_1936x1100HDR_len = ARRAY_SIZE(imx390_mode_1936x1100HDR);
diff --git a/drivers/d3/imx390/imx390-mode-1936x1100-HDR.h b/drivers/d3/imx390/imx390-mode-1936x1100-HDR.h
new file mode 100644
index 000000000000..6fde28c88047
--- /dev/null
+++ b/drivers/d3/imx390/imx390-mode-1936x1100-HDR.h
@@ -0,0 +1,28 @@
+/**
+ * @author Greg Rowe <growe@d3engineering.com>
+ *
+ * imx390 v4l2 driver for Nvidia Jetson
+ *
+ * Copyright (c) 2018-2019, D3 Engineering.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+#ifndef _IMX390_MODE_1936X1100HDR_H
+#define _IMX390_MODE_1936X1100HDR_H
+
+#include <linux/regmap.h>
+
+extern const struct reg_sequence imx390_mode_1936x1100HDR[];
+extern const size_t imx390_mode_1936x1100HDR_len;
+
+#endif
diff --git a/drivers/d3/imx390/imx390-mode-1936x1100-SP1H.c b/drivers/d3/imx390/imx390-mode-1936x1100-SP1H.c
new file mode 100644
index 000000000000..dafb51235e40
--- /dev/null
+++ b/drivers/d3/imx390/imx390-mode-1936x1100-SP1H.c
@@ -0,0 +1,3104 @@
+/**
+ * @author Greg Rowe <growe@d3engineering.com>
+ *
+ * imx390 v4l2 driver for Nvidia Jetson
+ *
+ * Copyright (c) 2018-2019, D3 Engineering.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+#include "imx390-mode-1936x1100-SP1H.h"
+
+/**
+ * This configuration was supplied by Sony. The only real modification
+ * we (D3) made was to disable the rear embedded data line.
+ *
+ * This was supplied on 2018-10-24 and is the SPIH table
+ */
+const struct reg_sequence imx390_mode_1936x1100SP1H[] = {
+	{0x2E18, 0x00},             /* disable rear embedded data line */
+	{0x000C, 0xF2},
+	{0x000E, 0x00},
+	{0x0010, 0xF2},
+	{0x0011, 0x02},
+	{0x0012, 0x00},
+	{0x0018, 0x15},
+	{0x0019, 0x00},
+	{0x001A, 0x0C},
+	{0x001B, 0x00},
+	{0x0038, 0x00},
+	{0x003C, 0x00},
+	{0x003D, 0x00},
+	{0x003E, 0x00},
+	{0x0040, 0x00},
+	{0x0041, 0x00},
+	{0x0042, 0x00},
+	{0x0044, 0x00},
+	{0x0045, 0x00},
+	{0x0046, 0x00},
+	{0x0048, 0x00},
+	{0x0049, 0x00},
+	{0x004A, 0x00},
+	{0x004C, 0x00},
+	{0x004D, 0x00},
+	{0x004E, 0x00},
+	{0x0050, 0x00},
+	{0x0051, 0x00},
+	{0x0052, 0x00},
+	{0x0054, 0x00},
+	{0x0055, 0x00},
+	{0x0056, 0x00},
+	{0x0058, 0x00},
+	{0x0059, 0x00},
+	{0x005A, 0x00},
+	{0x005C, 0x00},
+	{0x005D, 0x00},
+	{0x005E, 0x00},
+	{0x0060, 0x00},
+	{0x0061, 0x00},
+	{0x0062, 0x00},
+	{0x0064, 0x00},
+	{0x0065, 0x00},
+	{0x0066, 0x00},
+	{0x0068, 0x00},
+	{0x0069, 0x00},
+	{0x006A, 0x00},
+	{0x0078, 0x00},
+	{0x007C, 0x00},
+	{0x007D, 0x00},
+	{0x0080, 0x00},
+	{0x0081, 0x00},
+	{0x00F4, 0x1C},
+	{0x00F5, 0xF8},
+	{0x00F6, 0x01},
+	{0x00F8, 0x03},
+	{0x00F9, 0x00},
+	{0x00FA, 0x00},
+	{0x00FB, 0x00},
+	{0x0114, 0x00},
+	{0x0115, 0x01},
+	{0x0118, 0x20},
+	{0x0119, 0x03},
+	{0x011A, 0x00},
+	{0x011B, 0x41},
+	{0x011C, 0x80},
+	{0x011D, 0x00},
+	{0x0120, 0x20},
+	{0x0121, 0x00},
+	{0x0122, 0x00},
+	{0x0123, 0x44},
+	{0x0124, 0x00},
+	{0x0125, 0x01},
+	{0x0128, 0xAC},
+	{0x0129, 0x0D},
+	{0x012A, 0x00},
+	{0x012B, 0xA4},
+	{0x012C, 0x00},
+	{0x012D, 0x01},
+	{0x0130, 0xC4},
+	{0x0131, 0x09},
+	{0x0132, 0x00},
+	{0x0133, 0xDA},
+	{0x013B, 0x01},
+	{0x01C4, 0x00},
+	{0x01C5, 0x00},
+	{0x01CC, 0x01},
+	{0x01D0, 0x09},
+	{0x01D4, 0x01},
+	{0x0332, 0x18},
+	{0x0333, 0x00},
+	{0x0390, 0x00},
+	{0x0391, 0x00},
+	{0x0392, 0x00},
+	{0x03C0, 0x00},
+	{0x2000, 0x55},
+	{0x2001, 0x55},
+	{0x2002, 0x55},
+	{0x2003, 0x05},
+	{0x2004, 0x02},
+	{0x2008, 0x65},
+	{0x2009, 0x04},
+	{0x200A, 0x00},
+	{0x200C, 0x30},
+	{0x200D, 0x11},
+	{0x2010, 0x04},
+	{0x2014, 0x01},
+	{0x2018, 0x02},
+	{0x2019, 0x04},
+	{0x201A, 0x00},
+	{0x201C, 0x21},
+	{0x201D, 0x11},
+	{0x201E, 0x00},
+	{0x201F, 0x00},
+	{0x2020, 0xBC},
+	{0x2021, 0x00},
+	{0x2022, 0x7F},
+	{0x2023, 0x00},
+	{0x2024, 0xBA},
+	{0x2025, 0x00},
+	{0x2026, 0x81},
+	{0x2027, 0x00},
+	{0x2028, 0x7D},
+	{0x2029, 0x90},
+	{0x202A, 0x05},
+	{0x202C, 0xFC},
+	{0x202D, 0x02},
+	{0x202E, 0x25},
+	{0x202F, 0x03},
+	{0x2030, 0x05},
+	{0x2031, 0x02},
+	{0x2032, 0xCA},
+	{0x2033, 0x02},
+	{0x2034, 0xFC},
+	{0x2035, 0x02},
+	{0x2036, 0x25},
+	{0x2037, 0x03},
+	{0x2038, 0x25},
+	{0x2039, 0x97},
+	{0x203A, 0xEC},
+	{0x203B, 0x01},
+	{0x203C, 0xF5},
+	{0x203D, 0x8E},
+	{0x203E, 0x0C},
+	{0x203F, 0x2D},
+	{0x2040, 0x69},
+	{0x2041, 0x01},
+	{0x2042, 0x8E},
+	{0x2043, 0x01},
+	{0x2044, 0x0C},
+	{0x2045, 0x02},
+	{0x2046, 0x31},
+	{0x2047, 0x02},
+	{0x2048, 0x6A},
+	{0x2049, 0x01},
+	{0x204A, 0x8E},
+	{0x204B, 0x01},
+	{0x204C, 0x0D},
+	{0x204D, 0x02},
+	{0x204E, 0x31},
+	{0x204F, 0x02},
+	{0x2050, 0x7B},
+	{0x2051, 0x00},
+	{0x2052, 0x7D},
+	{0x2053, 0x00},
+	{0x2054, 0x95},
+	{0x2055, 0x00},
+	{0x2056, 0x97},
+	{0x2057, 0x00},
+	{0x2058, 0xAD},
+	{0x2059, 0x00},
+	{0x205A, 0xAF},
+	{0x205B, 0x00},
+	{0x205C, 0x92},
+	{0x205D, 0x00},
+	{0x205E, 0x94},
+	{0x205F, 0x00},
+	{0x2060, 0x8E},
+	{0x2061, 0x00},
+	{0x2062, 0x90},
+	{0x2063, 0x00},
+	{0x2064, 0xB1},
+	{0x2065, 0x00},
+	{0x2066, 0xB3},
+	{0x2067, 0x00},
+	{0x2068, 0x08},
+	{0x2069, 0x00},
+	{0x206A, 0x04},
+	{0x206B, 0x00},
+	{0x206C, 0x84},
+	{0x206D, 0x00},
+	{0x206E, 0x80},
+	{0x206F, 0x00},
+	{0x2070, 0x04},
+	{0x2071, 0x00},
+	{0x2072, 0x46},
+	{0x2073, 0x00},
+	{0x2074, 0xE9},
+	{0x2075, 0x01},
+	{0x2076, 0x74},
+	{0x2077, 0x02},
+	{0x2078, 0x80},
+	{0x2079, 0x00},
+	{0x207A, 0xC1},
+	{0x207B, 0x00},
+	{0x207C, 0xFF},
+	{0x207D, 0x03},
+	{0x207E, 0xFF},
+	{0x207F, 0x03},
+	{0x2080, 0x78},
+	{0x2081, 0x00},
+	{0x2082, 0x6A},
+	{0x2083, 0x01},
+	{0x2084, 0xE4},
+	{0x2085, 0x01},
+	{0x2086, 0x2B},
+	{0x2087, 0x03},
+	{0x2088, 0x00},
+	{0x2089, 0x00},
+	{0x208A, 0xFF},
+	{0x208B, 0x03},
+	{0x208C, 0xFF},
+	{0x208D, 0x03},
+	{0x208E, 0xFF},
+	{0x208F, 0x03},
+	{0x2090, 0x7D},
+	{0x2091, 0x00},
+	{0x2092, 0x62},
+	{0x2093, 0x01},
+	{0x2094, 0xE9},
+	{0x2095, 0x01},
+	{0x2096, 0x00},
+	{0x2097, 0x00},
+	{0x2098, 0x7C},
+	{0x2099, 0x00},
+	{0x209A, 0x21},
+	{0x209B, 0x03},
+	{0x209C, 0xE9},
+	{0x209D, 0x01},
+	{0x209E, 0x21},
+	{0x209F, 0x03},
+	{0x20A0, 0xFF},
+	{0x20A1, 0x03},
+	{0x20A2, 0xFF},
+	{0x20A3, 0x03},
+	{0x20A4, 0xFF},
+	{0x20A5, 0x03},
+	{0x20A6, 0xFF},
+	{0x20A7, 0x03},
+	{0x20A8, 0xFF},
+	{0x20A9, 0x03},
+	{0x20AA, 0xFF},
+	{0x20AB, 0x03},
+	{0x20AC, 0xFF},
+	{0x20AD, 0x03},
+	{0x20AE, 0xFF},
+	{0x20AF, 0x03},
+	{0x20B0, 0xFF},
+	{0x20B1, 0x03},
+	{0x20B2, 0xFF},
+	{0x20B3, 0x03},
+	{0x20B4, 0x87},
+	{0x20B5, 0xCC},
+	{0x20B6, 0x87},
+	{0x20B7, 0x08},
+	{0x20B8, 0xF4},
+	{0x20B9, 0xA5},
+	{0x20BA, 0x07},
+	{0x20BC, 0x1F},
+	{0x20BD, 0x01},
+	{0x20BE, 0xF6},
+	{0x20BF, 0x00},
+	{0x20C0, 0x90},
+	{0x20C1, 0x01},
+	{0x20C2, 0x67},
+	{0x20C3, 0x01},
+	{0x20C4, 0xFF},
+	{0x20C5, 0x03},
+	{0x20C6, 0xFF},
+	{0x20C7, 0x03},
+	{0x20C8, 0x33},
+	{0x20C9, 0x02},
+	{0x20CA, 0x0A},
+	{0x20CB, 0x02},
+	{0x20CC, 0x7F},
+	{0x20CD, 0x00},
+	{0x20CE, 0xD2},
+	{0x20CF, 0x00},
+	{0x20D0, 0x81},
+	{0x20D1, 0x00},
+	{0x20D2, 0x87},
+	{0x20D3, 0x00},
+	{0x20D4, 0x09},
+	{0x20D5, 0x00},
+	{0x20D8, 0x7F},
+	{0x20D9, 0x00},
+	{0x20DA, 0x62},
+	{0x20DB, 0x01},
+	{0x20DC, 0x7F},
+	{0x20DD, 0x00},
+	{0x20DE, 0x62},
+	{0x20DF, 0x01},
+	{0x20E0, 0x65},
+	{0x20E1, 0x00},
+	{0x20E2, 0x75},
+	{0x20E3, 0x00},
+	{0x20E4, 0xE0},
+	{0x20E5, 0x00},
+	{0x20E6, 0xF0},
+	{0x20E7, 0x00},
+	{0x20E8, 0x4C},
+	{0x20E9, 0x01},
+	{0x20EA, 0x5C},
+	{0x20EB, 0x01},
+	{0x20EC, 0xD1},
+	{0x20ED, 0x01},
+	{0x20EE, 0xE1},
+	{0x20EF, 0x01},
+	{0x20F0, 0x93},
+	{0x20F1, 0x02},
+	{0x20F2, 0xA3},
+	{0x20F3, 0x02},
+	{0x20F4, 0x0D},
+	{0x20F5, 0x03},
+	{0x20F6, 0x1D},
+	{0x20F7, 0x03},
+	{0x20F8, 0x57},
+	{0x20F9, 0x00},
+	{0x20FA, 0x7B},
+	{0x20FB, 0x00},
+	{0x20FC, 0xD2},
+	{0x20FD, 0x00},
+	{0x20FE, 0xF6},
+	{0x20FF, 0x00},
+	{0x2100, 0x3E},
+	{0x2101, 0x01},
+	{0x2102, 0x60},
+	{0x2103, 0x01},
+	{0x2104, 0xC3},
+	{0x2105, 0x01},
+	{0x2106, 0xE5},
+	{0x2107, 0x01},
+	{0x2108, 0x85},
+	{0x2109, 0x02},
+	{0x210A, 0xA9},
+	{0x210B, 0x02},
+	{0x210C, 0xFF},
+	{0x210D, 0x02},
+	{0x210E, 0x21},
+	{0x210F, 0x03},
+	{0x2110, 0xFF},
+	{0x2111, 0x03},
+	{0x2112, 0x00},
+	{0x2113, 0x00},
+	{0x2114, 0xFF},
+	{0x2115, 0x03},
+	{0x2116, 0xFF},
+	{0x2117, 0x03},
+	{0x2118, 0xFF},
+	{0x2119, 0x03},
+	{0x211A, 0xFF},
+	{0x211B, 0x03},
+	{0x211C, 0xFF},
+	{0x211D, 0x03},
+	{0x211E, 0xFF},
+	{0x211F, 0x03},
+	{0x2120, 0xFF},
+	{0x2121, 0x03},
+	{0x2122, 0xFF},
+	{0x2123, 0x03},
+	{0x2124, 0xFF},
+	{0x2125, 0x03},
+	{0x2126, 0xFF},
+	{0x2127, 0x03},
+	{0x2128, 0x7D},
+	{0x2129, 0x90},
+	{0x212A, 0xD5},
+	{0x212B, 0x07},
+	{0x212C, 0x64},
+	{0x212D, 0x01},
+	{0x2130, 0x5F},
+	{0x2131, 0x7D},
+	{0x2132, 0x05},
+	{0x2134, 0x78},
+	{0x2135, 0x00},
+	{0x2136, 0x76},
+	{0x2137, 0x00},
+	{0x2138, 0xF3},
+	{0x2139, 0x00},
+	{0x213A, 0xF1},
+	{0x213B, 0x00},
+	{0x213C, 0xA6},
+	{0x213D, 0x02},
+	{0x213E, 0xA4},
+	{0x213F, 0x02},
+	{0x2140, 0x7D},
+	{0x2141, 0x00},
+	{0x2142, 0x8D},
+	{0x2143, 0x00},
+	{0x2144, 0xA1},
+	{0x2145, 0x01},
+	{0x2146, 0xB1},
+	{0x2147, 0x01},
+	{0x2148, 0xAB},
+	{0x2149, 0x02},
+	{0x214A, 0xBB},
+	{0x214B, 0x02},
+	{0x214C, 0x17},
+	{0x214D, 0x5C},
+	{0x214E, 0x00},
+	{0x2150, 0x00},
+	{0x2151, 0x00},
+	{0x2152, 0xF8},
+	{0x2153, 0x00},
+	{0x2154, 0xBE},
+	{0x2155, 0x00},
+	{0x2156, 0x7D},
+	{0x2157, 0x00},
+	{0x2158, 0x25},
+	{0x2159, 0x00},
+	{0x215A, 0x7D},
+	{0x215B, 0x00},
+	{0x215C, 0x62},
+	{0x215D, 0x01},
+	{0x215E, 0xFF},
+	{0x215F, 0x03},
+	{0x2160, 0x26},
+	{0x2161, 0x00},
+	{0x2162, 0x7D},
+	{0x2163, 0x00},
+	{0x2164, 0x63},
+	{0x2165, 0x01},
+	{0x2166, 0xFF},
+	{0x2167, 0x03},
+	{0x2168, 0xCB},
+	{0x2169, 0x02},
+	{0x216A, 0xCF},
+	{0x216B, 0x02},
+	{0x216C, 0xFF},
+	{0x216D, 0x03},
+	{0x216E, 0xFF},
+	{0x216F, 0x03},
+	{0x2170, 0xFF},
+	{0x2171, 0x03},
+	{0x2172, 0xFF},
+	{0x2173, 0x03},
+	{0x2174, 0xFF},
+	{0x2175, 0x03},
+	{0x2176, 0xFF},
+	{0x2177, 0x03},
+	{0x2178, 0x7E},
+	{0x2179, 0x00},
+	{0x217A, 0xBD},
+	{0x217B, 0x00},
+	{0x217C, 0xEC},
+	{0x217D, 0x01},
+	{0x217E, 0x7B},
+	{0x217F, 0x02},
+	{0x2180, 0xD1},
+	{0x2181, 0x02},
+	{0x2182, 0x25},
+	{0x2183, 0x03},
+	{0x2184, 0x7F},
+	{0x2185, 0x00},
+	{0x2186, 0xBD},
+	{0x2187, 0x00},
+	{0x2188, 0xED},
+	{0x2189, 0x01},
+	{0x218A, 0x7B},
+	{0x218B, 0x02},
+	{0x218C, 0xD2},
+	{0x218D, 0x02},
+	{0x218E, 0x25},
+	{0x218F, 0x03},
+	{0x2190, 0xFF},
+	{0x2191, 0x03},
+	{0x2192, 0xFF},
+	{0x2193, 0x03},
+	{0x2194, 0xE9},
+	{0x2195, 0x01},
+	{0x2196, 0x21},
+	{0x2197, 0x03},
+	{0x2198, 0x17},
+	{0x2199, 0xFC},
+	{0x219A, 0x7F},
+	{0x219B, 0x01},
+	{0x219C, 0xFF},
+	{0x219D, 0x03},
+	{0x21A0, 0x1B},
+	{0x21A1, 0x1B},
+	{0x21A2, 0x1B},
+	{0x21A3, 0x1B},
+	{0x21A4, 0x2E},
+	{0x21A5, 0x80},
+	{0x21A6, 0x00},
+	{0x21A8, 0x04},
+	{0x21A9, 0x98},
+	{0x21AA, 0x60},
+	{0x21AB, 0x03},
+	{0x21AC, 0x7F},
+	{0x21AD, 0x80},
+	{0x21AE, 0x09},
+	{0x21B0, 0x1C},
+	{0x21B1, 0x00},
+	{0x21B2, 0xA0},
+	{0x21B3, 0x00},
+	{0x21B4, 0x0C},
+	{0x21B5, 0x00},
+	{0x21B6, 0x2D},
+	{0x21B7, 0x00},
+	{0x21B8, 0x20},
+	{0x21B9, 0x00},
+	{0x21BA, 0x02},
+	{0x21BB, 0x00},
+	{0x21BC, 0xCC},
+	{0x21BD, 0x00},
+	{0x21BE, 0x4A},
+	{0x21BF, 0x00},
+	{0x21C0, 0xD0},
+	{0x21C1, 0x00},
+	{0x21C2, 0x44},
+	{0x21C3, 0x00},
+	{0x21C4, 0x00},
+	{0x21C5, 0xE0},
+	{0x21C6, 0x00},
+	{0x21C8, 0x11},
+	{0x21C9, 0x00},
+	{0x21CA, 0x02},
+	{0x21CC, 0x08},
+	{0x21CD, 0xC0},
+	{0x21CE, 0x0C},
+	{0x21D0, 0x44},
+	{0x21D1, 0x00},
+	{0x21D2, 0x02},
+	{0x21D4, 0x02},
+	{0x21D5, 0x20},
+	{0x21D6, 0x2C},
+	{0x21D8, 0xFE},
+	{0x21D9, 0x9D},
+	{0x21DA, 0xDF},
+	{0x21DB, 0x03},
+	{0x21DC, 0x62},
+	{0x21DD, 0x01},
+	{0x21DE, 0x7F},
+	{0x21DF, 0x00},
+	{0x21E0, 0xB7},
+	{0x21E1, 0x01},
+	{0x21E2, 0xB5},
+	{0x21E3, 0x01},
+	{0x21E4, 0xC1},
+	{0x21E5, 0x02},
+	{0x21E6, 0xBF},
+	{0x21E7, 0x02},
+	{0x21E8, 0xB3},
+	{0x21E9, 0x0D},
+	{0x21EA, 0x00},
+	{0x21EB, 0x04},
+	{0x21EC, 0x90},
+	{0x21ED, 0x07},
+	{0x21EE, 0x58},
+	{0x21EF, 0x04},
+	{0x21F0, 0x54},
+	{0x21F1, 0x04},
+	{0x21F4, 0x02},
+	{0x21F5, 0x00},
+	{0x21F6, 0x00},
+	{0x21F8, 0x3C},
+	{0x21F9, 0x00},
+	{0x21FC, 0x28},
+	{0x21FD, 0x00},
+	{0x21FE, 0x3C},
+	{0x21FF, 0x00},
+	{0x2200, 0x00},
+	{0x2204, 0x4C},
+	{0x2205, 0x04},
+	{0x2206, 0x65},
+	{0x2207, 0x04},
+	{0x2208, 0x0A},
+	{0x2209, 0x00},
+	{0x220C, 0x47},
+	{0x220D, 0x00},
+	{0x220E, 0x1F},
+	{0x220F, 0x00},
+	{0x2210, 0x17},
+	{0x2211, 0x00},
+	{0x2212, 0x0F},
+	{0x2213, 0x00},
+	{0x2214, 0x17},
+	{0x2215, 0x00},
+	{0x2216, 0x47},
+	{0x2217, 0x00},
+	{0x2218, 0x0F},
+	{0x2219, 0x00},
+	{0x221A, 0x0F},
+	{0x221B, 0x00},
+	{0x221C, 0x03},
+	{0x2220, 0x20},
+	{0x2221, 0x20},
+	{0x2222, 0x22},
+	{0x2223, 0x02},
+	{0x2224, 0xA7},
+	{0x2225, 0xAA},
+	{0x2226, 0x80},
+	{0x2227, 0x08},
+	{0x2228, 0x01},
+	{0x22B2, 0x92},
+	{0x22B4, 0x20},
+	{0x22B5, 0x00},
+	{0x22B6, 0x20},
+	{0x22B7, 0x00},
+	{0x22B8, 0x20},
+	{0x22B9, 0x00},
+	{0x22BA, 0x20},
+	{0x22BB, 0x00},
+	{0x22BC, 0x20},
+	{0x22BD, 0x00},
+	{0x22BE, 0x20},
+	{0x22BF, 0x00},
+	{0x22C0, 0x20},
+	{0x22C1, 0x00},
+	{0x22C2, 0x20},
+	{0x22C3, 0x00},
+	{0x22C4, 0x20},
+	{0x22C5, 0x00},
+	{0x22C6, 0x20},
+	{0x22C7, 0x00},
+	{0x22C8, 0x20},
+	{0x22C9, 0x00},
+	{0x22CA, 0x20},
+	{0x22CB, 0x00},
+	{0x22CC, 0x20},
+	{0x22CD, 0x00},
+	{0x22CE, 0x20},
+	{0x22CF, 0x00},
+	{0x22DA, 0x00},
+	{0x2308, 0x01},
+	{0x2311, 0x09},
+	{0x2318, 0x40},
+	{0x2319, 0xCD},
+	{0x231A, 0x54},
+	{0x2324, 0x10},
+	{0x2325, 0x00},
+	{0x2328, 0x00},
+	{0x2354, 0x0C},
+	{0x23C0, 0x5D},
+	{0x244C, 0x00},
+	{0x244D, 0x02},
+	{0x244E, 0x54},
+	{0x244F, 0x02},
+	{0x24A0, 0x00},
+	{0x24DA, 0x6F},
+	{0x24DB, 0x00},
+	{0x24DC, 0x62},
+	{0x24DD, 0x01},
+	{0x24EA, 0x32},
+	{0x24EB, 0x00},
+	{0x24EC, 0xDC},
+	{0x24ED, 0x00},
+	{0x24FA, 0x32},
+	{0x24FB, 0x00},
+	{0x24FC, 0xDD},
+	{0x24FD, 0x00},
+	{0x254A, 0x15},
+	{0x254B, 0x01},
+	{0x255A, 0x15},
+	{0x255B, 0x01},
+	{0x2560, 0x01},
+	{0x2561, 0x00},
+	{0x2562, 0x2A},
+	{0x2563, 0x00},
+	{0x2564, 0xF8},
+	{0x2565, 0x00},
+	{0x2566, 0x15},
+	{0x2567, 0x01},
+	{0x2568, 0x0C},
+	{0x2569, 0x02},
+	{0x256A, 0x31},
+	{0x256B, 0x02},
+	{0x2578, 0x90},
+	{0x2579, 0x01},
+	{0x257A, 0x92},
+	{0x257B, 0x01},
+	{0x257C, 0xB8},
+	{0x257D, 0x02},
+	{0x257E, 0xBA},
+	{0x257F, 0x02},
+	{0x2584, 0x90},
+	{0x2585, 0x01},
+	{0x2586, 0x92},
+	{0x2587, 0x01},
+	{0x2588, 0xB8},
+	{0x2589, 0x02},
+	{0x258A, 0xBA},
+	{0x258B, 0x02},
+	{0x26B8, 0x10},
+	{0x26B9, 0x00},
+	{0x26BA, 0x33},
+	{0x26BB, 0x00},
+	{0x26BC, 0x89},
+	{0x26BD, 0x00},
+	{0x26BE, 0xB0},
+	{0x26BF, 0x00},
+	{0x26C4, 0x4E},
+	{0x26C5, 0x00},
+	{0x26C8, 0xC9},
+	{0x26C9, 0x00},
+	{0x26CC, 0x35},
+	{0x26CD, 0x01},
+	{0x26D0, 0xBA},
+	{0x26D1, 0x01},
+	{0x26D4, 0x7C},
+	{0x26D5, 0x02},
+	{0x26D8, 0xF6},
+	{0x26D9, 0x02},
+	{0x26DE, 0x51},
+	{0x26DF, 0x00},
+	{0x26E0, 0x7F},
+	{0x26E1, 0x00},
+	{0x26E2, 0xCC},
+	{0x26E3, 0x00},
+	{0x26E4, 0xF8},
+	{0x26E5, 0x00},
+	{0x26E6, 0x38},
+	{0x26E7, 0x01},
+	{0x26E8, 0x65},
+	{0x26E9, 0x01},
+	{0x26EA, 0xBD},
+	{0x26EB, 0x01},
+	{0x26EE, 0x7F},
+	{0x26EF, 0x02},
+	{0x26F0, 0xAB},
+	{0x26F1, 0x02},
+	{0x26F2, 0xF9},
+	{0x26F3, 0x02},
+	{0x2722, 0x59},
+	{0x2723, 0x02},
+	{0x2938, 0x55},
+	{0x2939, 0x00},
+	{0x293A, 0x17},
+	{0x293B, 0x00},
+	{0x293C, 0xD0},
+	{0x293D, 0x00},
+	{0x293E, 0x91},
+	{0x293F, 0x00},
+	{0x2940, 0x3C},
+	{0x2941, 0x01},
+	{0x2942, 0x0C},
+	{0x2943, 0x01},
+	{0x2944, 0xC1},
+	{0x2945, 0x01},
+	{0x2946, 0x76},
+	{0x2947, 0x01},
+	{0x2948, 0x83},
+	{0x2949, 0x02},
+	{0x294A, 0xFB},
+	{0x294B, 0x01},
+	{0x294C, 0xFD},
+	{0x294D, 0x02},
+	{0x294E, 0xBF},
+	{0x294F, 0x02},
+	{0x2A06, 0xFF},
+	{0x2A07, 0x03},
+	{0x2A20, 0x00},
+	{0x2A21, 0x00},
+	{0x2A22, 0x7D},
+	{0x2A23, 0x00},
+	{0x2B11, 0x19},
+	{0x2B13, 0x15},
+	{0x2B14, 0x14},
+	{0x2B15, 0x13},
+	{0x2B16, 0x12},
+	{0x2B17, 0x11},
+	{0x2B18, 0x10},
+	{0x2B19, 0x0F},
+	{0x2B1A, 0x0E},
+	{0x2B1B, 0x0D},
+	{0x2B1C, 0x0C},
+	{0x2B1D, 0x0B},
+	{0x2B1E, 0x0A},
+	{0x2B1F, 0x09},
+	{0x2B20, 0x08},
+	{0x2B21, 0x07},
+	{0x2B22, 0x06},
+	{0x2B23, 0x05},
+	{0x2B24, 0x04},
+	{0x2B25, 0x03},
+	{0x2B26, 0x03},
+	{0x2B38, 0x01},
+	{0x2B45, 0xE3},
+	{0x2B50, 0x01},
+	{0x2B51, 0x00},
+	{0x2B6D, 0x47},
+	{0x2B70, 0x02},
+	{0x2B71, 0x02},
+	{0x2B72, 0x02},
+	{0x2B7F, 0x7F},
+	{0x2B80, 0x94},
+	{0x2B81, 0x06},
+	{0x2B87, 0x1B},
+	{0x2B88, 0x1B},
+	{0x2B89, 0x17},
+	{0x2B8A, 0x12},
+	{0x2B8B, 0x12},
+	{0x2B8D, 0x2B},
+	{0x2B8E, 0x2B},
+	{0x2B8F, 0x2B},
+	{0x2B90, 0x7F},
+	{0x2B91, 0x1F},
+	{0x2B94, 0x7F},
+	{0x2B95, 0x27},
+	{0x2B98, 0x7F},
+	{0x2B99, 0x57},
+	{0x2BA8, 0xBC},
+	{0x2BA9, 0x62},
+	{0x2BC1, 0x70},
+	{0x2BC5, 0x80},
+	{0x2BD5, 0x30},
+	{0x2BD6, 0xF0},
+	{0x2BD8, 0xDB},
+	{0x2BD9, 0xF6},
+	{0x2BDA, 0x63},
+	{0x2BDB, 0x0C},
+	{0x2BDC, 0x5C},
+	{0x2C98, 0xE1},
+	{0x2C99, 0x2E},
+	{0x2C9B, 0x86},
+	{0x2CA9, 0x80},
+	{0x2CAA, 0x01},
+	{0x2D39, 0x0E},
+	{0x2D54, 0x00},
+	{0x2D5B, 0x58},
+	{0x3000, 0x00},
+	{0x3001, 0x00},
+	{0x3002, 0x23},
+	{0x3003, 0xA1},
+	{0x3004, 0x00},
+	{0x3005, 0x20},
+	{0x3006, 0x84},
+	{0x3007, 0x00},
+	{0x3008, 0x06},
+	{0x3009, 0xB4},
+	{0x300A, 0x1F},
+	{0x300B, 0x00},
+	{0x300C, 0x00},
+	{0x300D, 0x1B},
+	{0x300E, 0x90},
+	{0x300F, 0x97},
+	{0x3010, 0x00},
+	{0x3011, 0x00},
+	{0x3012, 0x21},
+	{0x3013, 0x21},
+	{0x3014, 0x00},
+	{0x3015, 0x20},
+	{0x3016, 0x84},
+	{0x3017, 0x00},
+	{0x3018, 0x30},
+	{0x3019, 0x09},
+	{0x301A, 0x46},
+	{0x301B, 0x00},
+	{0x3070, 0xC1},
+	{0x3071, 0x81},
+	{0x3072, 0x29},
+	{0x3073, 0x81},
+	{0x3410, 0x90},
+	{0x3411, 0x07},
+	{0x3418, 0x48},
+	{0x3419, 0x04},
+	{0x34C0, 0xD3},
+	{0x34C1, 0x00},
+	{0x34C2, 0xD3},
+	{0x34C3, 0x00},
+	{0x34C4, 0xD3},
+	{0x34C5, 0x00},
+	{0x34C6, 0xD3},
+	{0x34C7, 0x00},
+	{0x34C8, 0xE2},
+	{0x34C9, 0x21},
+	{0x34CA, 0xE0},
+	{0x34CB, 0x1F},
+	{0x34CC, 0x06},
+	{0x34CD, 0x20},
+	{0x34CE, 0x28},
+	{0x34CF, 0x1F},
+	{0x3584, 0x00},
+	{0x3586, 0x00},
+	{0x3587, 0x01},
+	{0x3588, 0xE6},
+	{0x3589, 0x00},
+	{0x3590, 0x00},
+	{0x3591, 0x00},
+	{0x3594, 0x40},
+	{0x3598, 0x03},
+	{0x3599, 0x00},
+	{0x359A, 0x80},
+	{0x359B, 0x00},
+	{0x359C, 0x00},
+	{0x359D, 0x01},
+	{0x359E, 0x00},
+	{0x359F, 0x02},
+	{0x35A0, 0x00},
+	{0x35A1, 0x04},
+	{0x35A2, 0x20},
+	{0x35A3, 0x00},
+	{0x35A4, 0x40},
+	{0x35A5, 0x00},
+	{0x35A6, 0x80},
+	{0x35A7, 0x00},
+	{0x35A8, 0x00},
+	{0x35A9, 0x01},
+	{0x35AA, 0x3A},
+	{0x35AB, 0x00},
+	{0x35AC, 0x80},
+	{0x35AD, 0x00},
+	{0x35AE, 0x00},
+	{0x35AF, 0x01},
+	{0x35B0, 0x00},
+	{0x35B1, 0x02},
+	{0x35B2, 0x00},
+	{0x35B3, 0x04},
+	{0x35B4, 0x02},
+	{0x35B5, 0x00},
+	{0x35B6, 0x04},
+	{0x35B7, 0x00},
+	{0x35B8, 0x08},
+	{0x35B9, 0x00},
+	{0x35BA, 0x10},
+	{0x35BB, 0x00},
+	{0x35BC, 0x03},
+	{0x35BD, 0x00},
+	{0x35C8, 0x00},
+	{0x35C9, 0x01},
+	{0x35CA, 0x00},
+	{0x35CB, 0x04},
+	{0x35CC, 0x00},
+	{0x35CD, 0x10},
+	{0x35CE, 0x00},
+	{0x35CF, 0x40},
+	{0x35D0, 0x00},
+	{0x35D1, 0x0C},
+	{0x35D2, 0x00},
+	{0x35D3, 0x0C},
+	{0x35D4, 0x00},
+	{0x35D5, 0x0C},
+	{0x35D6, 0x00},
+	{0x35D7, 0x0C},
+	{0x35D8, 0x00},
+	{0x35D9, 0x00},
+	{0x35DA, 0x08},
+	{0x35DB, 0x00},
+	{0x35DC, 0xD8},
+	{0x35DD, 0x0E},
+	{0x35F0, 0x00},
+	{0x35F1, 0x10},
+	{0x35F2, 0x00},
+	{0x35F3, 0x10},
+	{0x35F4, 0x00},
+	{0x35F5, 0x10},
+	{0x35F6, 0x00},
+	{0x35F7, 0x03},
+	{0x35F8, 0x00},
+	{0x35F9, 0x01},
+	{0x35FA, 0x38},
+	{0x35FB, 0x00},
+	{0x35FC, 0xB3},
+	{0x35FD, 0x01},
+	{0x35FE, 0x00},
+	{0x35FF, 0x00},
+	{0x3600, 0x04},
+	{0x3601, 0x06},
+	{0x3604, 0x03},
+	{0x3605, 0x00},
+	{0x3608, 0x03},
+	{0x3609, 0x00},
+	{0x360C, 0x00},
+	{0x360D, 0x00},
+	{0x3610, 0x10},
+	{0x3611, 0x01},
+	{0x3612, 0x00},
+	{0x3613, 0x00},
+	{0x3614, 0x00},
+	{0x3615, 0x00},
+	{0x361C, 0x00},
+	{0x361D, 0x01},
+	{0x361E, 0x00},
+	{0x361F, 0x01},
+	{0x3620, 0x01},
+	{0x3621, 0x00},
+	{0x3622, 0xB0},
+	{0x3623, 0x04},
+	{0x3624, 0xDC},
+	{0x3625, 0x05},
+	{0x3626, 0x00},
+	{0x3627, 0x01},
+	{0x3628, 0xFF},
+	{0x3629, 0x0F},
+	{0x362A, 0x00},
+	{0x362B, 0x10},
+	{0x362C, 0x00},
+	{0x362D, 0x01},
+	{0x3630, 0x40},
+	{0x3631, 0x00},
+	{0x3632, 0x40},
+	{0x3633, 0x00},
+	{0x3634, 0x40},
+	{0x3635, 0x00},
+	{0x3636, 0x40},
+	{0x3637, 0x00},
+	{0x3638, 0x40},
+	{0x3639, 0x00},
+	{0x363A, 0x40},
+	{0x363B, 0x00},
+	{0x363C, 0x40},
+	{0x363D, 0x00},
+	{0x363E, 0x40},
+	{0x363F, 0x00},
+	{0x36C4, 0x99},
+	{0x36C5, 0x09},
+	{0x36C6, 0x18},
+	{0x36C7, 0x07},
+	{0x36C8, 0x65},
+	{0x36C9, 0x0E},
+	{0x36CC, 0x99},
+	{0x36CD, 0x01},
+	{0x36CE, 0x47},
+	{0x36CF, 0x00},
+	{0x36D0, 0x04},
+	{0x36D1, 0x00},
+	{0x36D4, 0x65},
+	{0x36D5, 0x0E},
+	{0x36D6, 0xA4},
+	{0x36D7, 0x0A},
+	{0x36D8, 0x65},
+	{0x36D9, 0x0E},
+	{0x36DC, 0x65},
+	{0x36DD, 0x0E},
+	{0x36DE, 0xA4},
+	{0x36DF, 0x0A},
+	{0x36E0, 0x65},
+	{0x36E1, 0x0E},
+	{0x36E4, 0x65},
+	{0x36E5, 0x0E},
+	{0x36E6, 0xA4},
+	{0x36E7, 0x0A},
+	{0x36E8, 0x65},
+	{0x36E9, 0x0E},
+	{0x36EE, 0x00},
+	{0x36EF, 0x00},
+	{0x36F0, 0x00},
+	{0x36F1, 0x80},
+	{0x36F8, 0x00},
+	{0x3702, 0x03},
+	{0x3703, 0x04},
+	{0x3704, 0x08},
+	{0x370E, 0x0E},
+	{0x3718, 0x62},
+	{0x3719, 0x4A},
+	{0x371A, 0x38},
+	{0x371B, 0x20},
+	{0x371C, 0x64},
+	{0x371D, 0x42},
+	{0x371E, 0x32},
+	{0x371F, 0x1B},
+	{0x3720, 0x9C},
+	{0x3721, 0xA4},
+	{0x3722, 0xAC},
+	{0x3723, 0xB4},
+	{0x3748, 0xAA},
+	{0x3749, 0x96},
+	{0x374A, 0x7D},
+	{0x374B, 0x69},
+	{0x37C0, 0x00},
+	{0x37C1, 0x00},
+	{0x37C2, 0x00},
+	{0x37C4, 0x00},
+	{0x37C5, 0x00},
+	{0x37C6, 0x00},
+	{0x37C8, 0x00},
+	{0x37C9, 0x00},
+	{0x37CA, 0x00},
+	{0x37CC, 0x00},
+	{0x37CD, 0x00},
+	{0x37CE, 0x00},
+	{0x37D0, 0x00},
+	{0x37D1, 0x00},
+	{0x37D2, 0x00},
+	{0x37D4, 0x00},
+	{0x37D5, 0x00},
+	{0x37D6, 0x00},
+	{0x37D8, 0x00},
+	{0x37D9, 0x00},
+	{0x37DA, 0x00},
+	{0x37DC, 0x00},
+	{0x37DD, 0x00},
+	{0x37DE, 0x00},
+	{0x37E0, 0x00},
+	{0x37E1, 0x00},
+	{0x37E2, 0x00},
+	{0x37E4, 0x00},
+	{0x37E5, 0x00},
+	{0x37E6, 0x00},
+	{0x37E8, 0x00},
+	{0x37E9, 0x00},
+	{0x37EA, 0x00},
+	{0x37EC, 0x00},
+	{0x37ED, 0x00},
+	{0x37EE, 0x00},
+	{0x37F0, 0x00},
+	{0x37F4, 0x00},
+	{0x37F5, 0x1E},
+	{0x37F6, 0x34},
+	{0x37F7, 0x00},
+	{0x37F8, 0xFF},
+	{0x37F9, 0xFF},
+	{0x37FA, 0x03},
+	{0x37FC, 0x00},
+	{0x37FD, 0x00},
+	{0x37FE, 0x04},
+	{0x3800, 0xFF},
+	{0x3801, 0xFF},
+	{0x3802, 0x03},
+	{0x3804, 0x00},
+	{0x3805, 0x00},
+	{0x3806, 0x04},
+	{0x3808, 0x00},
+	{0x3809, 0x00},
+	{0x380A, 0x00},
+	{0x380C, 0x00},
+	{0x380D, 0x00},
+	{0x380E, 0x00},
+	{0x3810, 0x00},
+	{0x3811, 0x00},
+	{0x3812, 0x00},
+	{0x3814, 0x00},
+	{0x3815, 0x00},
+	{0x3816, 0x00},
+	{0x3818, 0x00},
+	{0x3819, 0x00},
+	{0x381A, 0x00},
+	{0x381C, 0x00},
+	{0x381D, 0x00},
+	{0x381E, 0x00},
+	{0x3820, 0x00},
+	{0x3821, 0x00},
+	{0x3822, 0x00},
+	{0x3824, 0x00},
+	{0x3825, 0x00},
+	{0x3826, 0x00},
+	{0x3828, 0x00},
+	{0x3829, 0x00},
+	{0x382A, 0x00},
+	{0x382C, 0x00},
+	{0x382D, 0x00},
+	{0x382E, 0x00},
+	{0x3830, 0x00},
+	{0x3831, 0x00},
+	{0x3832, 0x00},
+	{0x3834, 0x00},
+	{0x3835, 0x00},
+	{0x3836, 0x00},
+	{0x3838, 0x00},
+	{0x3839, 0x00},
+	{0x383A, 0x00},
+	{0x383B, 0x00},
+	{0x383C, 0x00},
+	{0x383D, 0x00},
+	{0x383E, 0x00},
+	{0x383F, 0x00},
+	{0x3840, 0x00},
+	{0x3841, 0x00},
+	{0x3842, 0x00},
+	{0x3843, 0x00},
+	{0x3844, 0x00},
+	{0x3845, 0x00},
+	{0x3846, 0x00},
+	{0x3847, 0x00},
+	{0x3848, 0x00},
+	{0x3849, 0x00},
+	{0x384A, 0x00},
+	{0x384B, 0x00},
+	{0x384C, 0x00},
+	{0x384D, 0x00},
+	{0x384E, 0x00},
+	{0x384F, 0x00},
+	{0x3850, 0xFF},
+	{0x3851, 0x0F},
+	{0x3852, 0x00},
+	{0x3853, 0x10},
+	{0x3854, 0xFF},
+	{0x3855, 0x0F},
+	{0x3856, 0x00},
+	{0x3857, 0x10},
+	{0x3858, 0xFF},
+	{0x3859, 0x0F},
+	{0x385A, 0x00},
+	{0x385B, 0x10},
+	{0x385C, 0x02},
+	{0x385D, 0x00},
+	{0x385E, 0x06},
+	{0x385F, 0x00},
+	{0x3860, 0x06},
+	{0x3861, 0x00},
+	{0x3862, 0x08},
+	{0x3863, 0x00},
+	{0x3864, 0x02},
+	{0x3865, 0x00},
+	{0x38A0, 0x01},
+	{0x38A1, 0x01},
+	{0x38A2, 0x00},
+	{0x38A3, 0x01},
+	{0x38A4, 0x07},
+	{0x38A5, 0x00},
+	{0x38A6, 0x04},
+	{0x38A7, 0x05},
+	{0x38A8, 0x00},
+	{0x38A9, 0x00},
+	{0x38AC, 0x00},
+	{0x38AD, 0x00},
+	{0x38AE, 0x01},
+	{0x38B0, 0x02},
+	{0x38B2, 0x22},
+	{0x38B3, 0x00},
+	{0x38B4, 0x17},
+	{0x38B5, 0x00},
+	{0x38B6, 0x11},
+	{0x38B7, 0x00},
+	{0x38B8, 0x0E},
+	{0x38B9, 0x00},
+	{0x38BA, 0x2A},
+	{0x38BB, 0x00},
+	{0x38BC, 0x1C},
+	{0x38BD, 0x00},
+	{0x38BE, 0x14},
+	{0x38BF, 0x00},
+	{0x38C0, 0x10},
+	{0x38C1, 0x00},
+	{0x38C2, 0x31},
+	{0x38C3, 0x00},
+	{0x38C4, 0x21},
+	{0x38C5, 0x00},
+	{0x38C6, 0x18},
+	{0x38C7, 0x00},
+	{0x38C8, 0x12},
+	{0x38C9, 0x00},
+	{0x38CA, 0x3C},
+	{0x38CB, 0x00},
+	{0x38CC, 0x29},
+	{0x38CD, 0x00},
+	{0x38CE, 0x1D},
+	{0x38CF, 0x00},
+	{0x38D0, 0x15},
+	{0x38D1, 0x00},
+	{0x38D2, 0x4E},
+	{0x38D3, 0x00},
+	{0x38D4, 0x35},
+	{0x38D5, 0x00},
+	{0x38D6, 0x26},
+	{0x38D7, 0x00},
+	{0x38D8, 0x1A},
+	{0x38D9, 0x00},
+	{0x38DA, 0x69},
+	{0x38DB, 0x00},
+	{0x38DC, 0x48},
+	{0x38DD, 0x00},
+	{0x38DE, 0x33},
+	{0x38DF, 0x00},
+	{0x38E0, 0x22},
+	{0x38E1, 0x00},
+	{0x38E2, 0x93},
+	{0x38E3, 0x00},
+	{0x38E4, 0x64},
+	{0x38E5, 0x00},
+	{0x38E6, 0x48},
+	{0x38E7, 0x00},
+	{0x38E8, 0x30},
+	{0x38E9, 0x00},
+	{0x38EA, 0xD3},
+	{0x38EB, 0x00},
+	{0x38EC, 0x90},
+	{0x38ED, 0x00},
+	{0x38EE, 0x69},
+	{0x38EF, 0x00},
+	{0x38F0, 0x49},
+	{0x38F1, 0x00},
+	{0x38F2, 0x39},
+	{0x38F3, 0x01},
+	{0x38F4, 0xD5},
+	{0x38F5, 0x00},
+	{0x38F6, 0x9F},
+	{0x38F7, 0x00},
+	{0x38F8, 0x75},
+	{0x38F9, 0x00},
+	{0x38FA, 0x00},
+	{0x38FB, 0x01},
+	{0x38FC, 0x00},
+	{0x38FD, 0x01},
+	{0x38FE, 0x00},
+	{0x38FF, 0x01},
+	{0x3900, 0x00},
+	{0x3901, 0x01},
+	{0x3902, 0x70},
+	{0x3903, 0x00},
+	{0x3904, 0x30},
+	{0x3905, 0x00},
+	{0x3906, 0x25},
+	{0x3907, 0x00},
+	{0x3908, 0x20},
+	{0x3909, 0x00},
+	{0x390A, 0xB2},
+	{0x390B, 0x00},
+	{0x390C, 0x80},
+	{0x390D, 0x00},
+	{0x390E, 0x70},
+	{0x390F, 0x00},
+	{0x3910, 0x50},
+	{0x3911, 0x00},
+	{0x3912, 0xB2},
+	{0x3913, 0x00},
+	{0x3914, 0x80},
+	{0x3915, 0x00},
+	{0x3916, 0x70},
+	{0x3917, 0x00},
+	{0x3918, 0x50},
+	{0x3919, 0x00},
+	{0x391A, 0xB2},
+	{0x391B, 0x00},
+	{0x391C, 0x80},
+	{0x391D, 0x00},
+	{0x391E, 0x70},
+	{0x391F, 0x00},
+	{0x3920, 0x50},
+	{0x3921, 0x00},
+	{0x3922, 0x40},
+	{0x3923, 0x00},
+	{0x3924, 0x40},
+	{0x3925, 0x00},
+	{0x3926, 0x40},
+	{0x3927, 0x00},
+	{0x3928, 0x40},
+	{0x3929, 0x00},
+	{0x392A, 0x80},
+	{0x392B, 0x00},
+	{0x392C, 0x80},
+	{0x392D, 0x00},
+	{0x392E, 0x80},
+	{0x392F, 0x00},
+	{0x3930, 0x80},
+	{0x3931, 0x00},
+	{0x3932, 0x80},
+	{0x3933, 0x80},
+	{0x3934, 0x80},
+	{0x3940, 0x01},
+	{0x3941, 0x01},
+	{0x3942, 0x00},
+	{0x3943, 0x01},
+	{0x3944, 0x07},
+	{0x3945, 0x00},
+	{0x3946, 0x04},
+	{0x3947, 0x05},
+	{0x3948, 0x00},
+	{0x3949, 0x00},
+	{0x394C, 0x00},
+	{0x394D, 0x00},
+	{0x394E, 0x01},
+	{0x3950, 0x03},
+	{0x3952, 0x14},
+	{0x3953, 0x00},
+	{0x3954, 0x0F},
+	{0x3955, 0x00},
+	{0x3956, 0x0E},
+	{0x3957, 0x00},
+	{0x3958, 0x0E},
+	{0x3959, 0x00},
+	{0x395A, 0x19},
+	{0x395B, 0x00},
+	{0x395C, 0x11},
+	{0x395D, 0x00},
+	{0x395E, 0x0F},
+	{0x395F, 0x00},
+	{0x3960, 0x0E},
+	{0x3961, 0x00},
+	{0x3962, 0x1C},
+	{0x3963, 0x00},
+	{0x3964, 0x13},
+	{0x3965, 0x00},
+	{0x3966, 0x0F},
+	{0x3967, 0x00},
+	{0x3968, 0x0E},
+	{0x3969, 0x00},
+	{0x396A, 0x23},
+	{0x396B, 0x00},
+	{0x396C, 0x15},
+	{0x396D, 0x00},
+	{0x396E, 0x11},
+	{0x396F, 0x00},
+	{0x3970, 0x0E},
+	{0x3971, 0x00},
+	{0x3972, 0x2E},
+	{0x3973, 0x00},
+	{0x3974, 0x1A},
+	{0x3975, 0x00},
+	{0x3976, 0x14},
+	{0x3977, 0x00},
+	{0x3978, 0x0F},
+	{0x3979, 0x00},
+	{0x397A, 0x3E},
+	{0x397B, 0x00},
+	{0x397C, 0x23},
+	{0x397D, 0x00},
+	{0x397E, 0x1A},
+	{0x397F, 0x00},
+	{0x3980, 0x12},
+	{0x3981, 0x00},
+	{0x3982, 0x56},
+	{0x3983, 0x00},
+	{0x3984, 0x31},
+	{0x3985, 0x00},
+	{0x3986, 0x25},
+	{0x3987, 0x00},
+	{0x3988, 0x1A},
+	{0x3989, 0x00},
+	{0x398A, 0x7B},
+	{0x398B, 0x00},
+	{0x398C, 0x49},
+	{0x398D, 0x00},
+	{0x398E, 0x39},
+	{0x398F, 0x00},
+	{0x3990, 0x2C},
+	{0x3991, 0x00},
+	{0x3992, 0xB4},
+	{0x3993, 0x00},
+	{0x3994, 0x75},
+	{0x3995, 0x00},
+	{0x3996, 0x61},
+	{0x3997, 0x00},
+	{0x3998, 0x53},
+	{0x3999, 0x00},
+	{0x399A, 0x00},
+	{0x399B, 0x01},
+	{0x399C, 0x00},
+	{0x399D, 0x01},
+	{0x399E, 0x00},
+	{0x399F, 0x01},
+	{0x39A0, 0x00},
+	{0x39A1, 0x01},
+	{0x39A2, 0x70},
+	{0x39A3, 0x00},
+	{0x39A4, 0x30},
+	{0x39A5, 0x00},
+	{0x39A6, 0x25},
+	{0x39A7, 0x00},
+	{0x39A8, 0x20},
+	{0x39A9, 0x00},
+	{0x39AA, 0xB2},
+	{0x39AB, 0x00},
+	{0x39AC, 0x80},
+	{0x39AD, 0x00},
+	{0x39AE, 0x70},
+	{0x39AF, 0x00},
+	{0x39B0, 0x80},
+	{0x39B1, 0x00},
+	{0x39B2, 0xB2},
+	{0x39B3, 0x00},
+	{0x39B4, 0x80},
+	{0x39B5, 0x00},
+	{0x39B6, 0x70},
+	{0x39B7, 0x00},
+	{0x39B8, 0x80},
+	{0x39B9, 0x00},
+	{0x39BA, 0xB2},
+	{0x39BB, 0x00},
+	{0x39BC, 0x80},
+	{0x39BD, 0x00},
+	{0x39BE, 0x70},
+	{0x39BF, 0x00},
+	{0x39C0, 0x80},
+	{0x39C1, 0x00},
+	{0x39C2, 0x40},
+	{0x39C3, 0x00},
+	{0x39C4, 0x40},
+	{0x39C5, 0x00},
+	{0x39C6, 0x40},
+	{0x39C7, 0x00},
+	{0x39C8, 0x40},
+	{0x39C9, 0x00},
+	{0x39CA, 0x80},
+	{0x39CB, 0x00},
+	{0x39CC, 0x80},
+	{0x39CD, 0x00},
+	{0x39CE, 0x80},
+	{0x39CF, 0x00},
+	{0x39D0, 0x80},
+	{0x39D1, 0x00},
+	{0x39D2, 0x80},
+	{0x39D3, 0x80},
+	{0x39D4, 0x80},
+	{0x39E0, 0x01},
+	{0x39E1, 0x00},
+	{0x39E4, 0x40},
+	{0x39E5, 0x01},
+	{0x39E6, 0x01},
+	{0x39E8, 0x00},
+	{0x39E9, 0x01},
+	{0x39EA, 0x00},
+	{0x39EB, 0x00},
+	{0x39EC, 0x01},
+	{0x39ED, 0x00},
+	{0x39EE, 0x01},
+	{0x39F0, 0x03},
+	{0x39F1, 0x04},
+	{0x39F2, 0x0E},
+	{0x39F4, 0x1C},
+	{0x39F5, 0x00},
+	{0x39F6, 0x13},
+	{0x39F7, 0x00},
+	{0x39F8, 0x0D},
+	{0x39F9, 0x00},
+	{0x39FA, 0x07},
+	{0x39FB, 0x00},
+	{0x39FC, 0x38},
+	{0x39FD, 0x00},
+	{0x39FE, 0x1C},
+	{0x39FF, 0x00},
+	{0x3A00, 0x11},
+	{0x3A01, 0x00},
+	{0x3A02, 0x08},
+	{0x3A03, 0x00},
+	{0x3A04, 0x4A},
+	{0x3A05, 0x00},
+	{0x3A06, 0x23},
+	{0x3A07, 0x00},
+	{0x3A08, 0x15},
+	{0x3A09, 0x00},
+	{0x3A0A, 0x09},
+	{0x3A0B, 0x00},
+	{0x3A0C, 0x65},
+	{0x3A0D, 0x00},
+	{0x3A0E, 0x2D},
+	{0x3A0F, 0x00},
+	{0x3A10, 0x1A},
+	{0x3A11, 0x00},
+	{0x3A12, 0x0B},
+	{0x3A13, 0x00},
+	{0x3A14, 0x8D},
+	{0x3A15, 0x00},
+	{0x3A16, 0x3D},
+	{0x3A17, 0x00},
+	{0x3A18, 0x23},
+	{0x3A19, 0x00},
+	{0x3A1A, 0x0E},
+	{0x3A1B, 0x00},
+	{0x3A1C, 0xC5},
+	{0x3A1D, 0x00},
+	{0x3A1E, 0x55},
+	{0x3A1F, 0x00},
+	{0x3A20, 0x30},
+	{0x3A21, 0x00},
+	{0x3A22, 0x13},
+	{0x3A23, 0x00},
+	{0x3A24, 0x16},
+	{0x3A25, 0x01},
+	{0x3A26, 0x76},
+	{0x3A27, 0x00},
+	{0x3A28, 0x42},
+	{0x3A29, 0x00},
+	{0x3A2A, 0x1A},
+	{0x3A2B, 0x00},
+	{0x3A2C, 0x88},
+	{0x3A2D, 0x01},
+	{0x3A2E, 0xA7},
+	{0x3A2F, 0x00},
+	{0x3A30, 0x5D},
+	{0x3A31, 0x00},
+	{0x3A32, 0x24},
+	{0x3A33, 0x00},
+	{0x3A34, 0x2A},
+	{0x3A35, 0x02},
+	{0x3A36, 0xEB},
+	{0x3A37, 0x00},
+	{0x3A38, 0x83},
+	{0x3A39, 0x00},
+	{0x3A3A, 0x32},
+	{0x3A3B, 0x00},
+	{0x3A3C, 0x00},
+	{0x3A3D, 0x01},
+	{0x3A3E, 0x00},
+	{0x3A3F, 0x01},
+	{0x3A40, 0x00},
+	{0x3A41, 0x01},
+	{0x3A42, 0x00},
+	{0x3A43, 0x01},
+	{0x3A44, 0x80},
+	{0x3A45, 0x00},
+	{0x3A46, 0x50},
+	{0x3A47, 0x00},
+	{0x3A48, 0x30},
+	{0x3A49, 0x00},
+	{0x3A4A, 0x20},
+	{0x3A4B, 0x00},
+	{0x3A4C, 0x99},
+	{0x3A4D, 0x00},
+	{0x3A4E, 0x80},
+	{0x3A4F, 0x00},
+	{0x3A50, 0x80},
+	{0x3A51, 0x00},
+	{0x3A52, 0x80},
+	{0x3A53, 0x00},
+	{0x3A54, 0x99},
+	{0x3A55, 0x00},
+	{0x3A56, 0x80},
+	{0x3A57, 0x00},
+	{0x3A58, 0x80},
+	{0x3A59, 0x00},
+	{0x3A5A, 0x80},
+	{0x3A5B, 0x00},
+	{0x3A5C, 0x99},
+	{0x3A5D, 0x00},
+	{0x3A5E, 0x80},
+	{0x3A5F, 0x00},
+	{0x3A60, 0x80},
+	{0x3A61, 0x00},
+	{0x3A62, 0x80},
+	{0x3A63, 0x00},
+	{0x3A64, 0x1C},
+	{0x3A65, 0x00},
+	{0x3A66, 0x13},
+	{0x3A67, 0x00},
+	{0x3A68, 0x0D},
+	{0x3A69, 0x00},
+	{0x3A6A, 0x07},
+	{0x3A6B, 0x00},
+	{0x3A6C, 0x0C},
+	{0x3A6D, 0x00},
+	{0x3A6E, 0x09},
+	{0x3A6F, 0x00},
+	{0x3A70, 0x06},
+	{0x3A71, 0x00},
+	{0x3A72, 0x03},
+	{0x3A73, 0x00},
+	{0x3A74, 0x1F},
+	{0x3A75, 0x00},
+	{0x3A76, 0x1B},
+	{0x3A77, 0x00},
+	{0x3A78, 0x0F},
+	{0x3A79, 0x00},
+	{0x3A7A, 0x08},
+	{0x3A7B, 0x00},
+	{0x3A7C, 0x80},
+	{0x3A7D, 0x00},
+	{0x3A7E, 0x80},
+	{0x3A7F, 0x00},
+	{0x3A80, 0x80},
+	{0x3A81, 0x00},
+	{0x3A82, 0x80},
+	{0x3A83, 0x00},
+	{0x3A84, 0x09},
+	{0x3A85, 0x00},
+	{0x3A86, 0x04},
+	{0x3A87, 0x00},
+	{0x3A88, 0x03},
+	{0x3A89, 0x00},
+	{0x3A8A, 0x01},
+	{0x3A8B, 0x00},
+	{0x3A8C, 0x19},
+	{0x3A8D, 0x01},
+	{0x3A8E, 0xD2},
+	{0x3A8F, 0x00},
+	{0x3A90, 0x8C},
+	{0x3A91, 0x00},
+	{0x3A92, 0x64},
+	{0x3A93, 0x00},
+	{0x3A94, 0xFF},
+	{0x3A95, 0x00},
+	{0x3A96, 0xD2},
+	{0x3A97, 0x00},
+	{0x3A98, 0x8C},
+	{0x3A99, 0x00},
+	{0x3A9A, 0x64},
+	{0x3A9B, 0x00},
+	{0x3A9C, 0x08},
+	{0x3A9D, 0x10},
+	{0x3A9E, 0x80},
+	{0x3A9F, 0x80},
+	{0x3AA0, 0x80},
+	{0x3AA1, 0x04},
+	{0x3AA2, 0x05},
+	{0x3AC0, 0x01},
+	{0x3AC4, 0x81},
+	{0x3AC5, 0x00},
+	{0x3AC6, 0x00},
+	{0x3AC7, 0x00},
+	{0x3AC8, 0x00},
+	{0x3AC9, 0x00},
+	{0x3ACA, 0x00},
+	{0x3ACB, 0x00},
+	{0x3ACC, 0x02},
+	{0x3ACD, 0x00},
+	{0x3ACE, 0x81},
+	{0x3ACF, 0x00},
+	{0x3AD0, 0x00},
+	{0x3AD1, 0x00},
+	{0x3AD2, 0xFD},
+	{0x3AD3, 0x03},
+	{0x3AD4, 0x02},
+	{0x3AD5, 0x00},
+	{0x3AD6, 0x00},
+	{0x3AD7, 0x00},
+	{0x3AD8, 0x81},
+	{0x3AD9, 0x00},
+	{0x3ADA, 0xFD},
+	{0x3ADB, 0x03},
+	{0x3ADC, 0xFF},
+	{0x3ADD, 0x03},
+	{0x3ADE, 0x01},
+	{0x3ADF, 0x00},
+	{0x3AE0, 0x01},
+	{0x3AE1, 0x00},
+	{0x3AE2, 0x7E},
+	{0x3AE3, 0x00},
+	{0x3AF4, 0x00},
+	{0x3AF6, 0x40},
+	{0x3AF7, 0x1E},
+	{0x3AF8, 0x01},
+	{0x3AFA, 0x63},
+	{0x3AFB, 0x09},
+	{0x3AFC, 0x11},
+	{0x3AFD, 0x09},
+	{0x3AFE, 0x00},
+	{0x3AFF, 0x00},
+	{0x3B00, 0x00},
+	{0x3B01, 0x00},
+	{0x3B02, 0x84},
+	{0x3B03, 0x06},
+	{0x3B04, 0x30},
+	{0x3B05, 0x06},
+	{0x3B06, 0x00},
+	{0x3B07, 0x00},
+	{0x3B08, 0x00},
+	{0x3B09, 0x00},
+	{0x3B0A, 0x00},
+	{0x3B0B, 0x00},
+	{0x3B0C, 0x00},
+	{0x3B0D, 0x00},
+	{0x3B0E, 0x00},
+	{0x3B0F, 0x00},
+	{0x3B10, 0x00},
+	{0x3B11, 0x00},
+	{0x3B12, 0x00},
+	{0x3B13, 0x00},
+	{0x3B14, 0x00},
+	{0x3B15, 0x00},
+	{0x3B16, 0x00},
+	{0x3B17, 0x00},
+	{0x3B18, 0x00},
+	{0x3B19, 0x00},
+	{0x3B1A, 0x00},
+	{0x3B1B, 0x00},
+	{0x3B1C, 0x00},
+	{0x3B1D, 0x00},
+	{0x3B1E, 0x00},
+	{0x3B1F, 0x00},
+	{0x3B20, 0x00},
+	{0x3B21, 0x00},
+	{0x3B22, 0x00},
+	{0x3B23, 0x00},
+	{0x3B24, 0x00},
+	{0x3B25, 0x00},
+	{0x3B26, 0x00},
+	{0x3B27, 0x00},
+	{0x3B28, 0x00},
+	{0x3B29, 0x00},
+	{0x3B2A, 0x00},
+	{0x3B2C, 0x00},
+	{0x3B2E, 0x00},
+	{0x3B30, 0x00},
+	{0x3B32, 0x0C},
+	{0x4000, 0xD1},
+	{0x4001, 0xC0},
+	{0x4002, 0xC0},
+	{0x4003, 0xB8},
+	{0x4004, 0xC0},
+	{0x4005, 0xB8},
+	{0x4006, 0xB9},
+	{0x4007, 0xB7},
+	{0x4008, 0xB0},
+	{0x4009, 0xAB},
+	{0x400A, 0xAC},
+	{0x400B, 0xAB},
+	{0x400C, 0xA8},
+	{0x400D, 0xA6},
+	{0x400E, 0xA6},
+	{0x400F, 0xA5},
+	{0x4010, 0xA2},
+	{0x4011, 0xA0},
+	{0x4012, 0xA0},
+	{0x4013, 0x9F},
+	{0x4014, 0xA4},
+	{0x4015, 0xA2},
+	{0x4016, 0xA2},
+	{0x4017, 0x9C},
+	{0x4018, 0xA8},
+	{0x4019, 0xA6},
+	{0x401A, 0xA8},
+	{0x401B, 0xAA},
+	{0x401C, 0xB0},
+	{0x401D, 0xAE},
+	{0x401E, 0xAE},
+	{0x401F, 0xAE},
+	{0x4020, 0xBA},
+	{0x4021, 0xAE},
+	{0x4022, 0xAF},
+	{0x4023, 0xAE},
+	{0x4024, 0xC6},
+	{0x4025, 0xBD},
+	{0x4026, 0xBD},
+	{0x4027, 0xBA},
+	{0x4028, 0xB0},
+	{0x4029, 0xA9},
+	{0x402A, 0xAA},
+	{0x402B, 0xA8},
+	{0x402C, 0x9F},
+	{0x402D, 0x9C},
+	{0x402E, 0x9C},
+	{0x402F, 0x9B},
+	{0x4030, 0x93},
+	{0x4031, 0x91},
+	{0x4032, 0x92},
+	{0x4033, 0x91},
+	{0x4034, 0x8D},
+	{0x4035, 0x8C},
+	{0x4036, 0x8C},
+	{0x4037, 0x8C},
+	{0x4038, 0x8F},
+	{0x4039, 0x8E},
+	{0x403A, 0x8E},
+	{0x403B, 0x8E},
+	{0x403C, 0x98},
+	{0x403D, 0x96},
+	{0x403E, 0x96},
+	{0x403F, 0x95},
+	{0x4040, 0xA4},
+	{0x4041, 0xA0},
+	{0x4042, 0xA0},
+	{0x4043, 0x9E},
+	{0x4044, 0xB3},
+	{0x4045, 0xAE},
+	{0x4046, 0xAF},
+	{0x4047, 0xAB},
+	{0x4048, 0xC2},
+	{0x4049, 0xB7},
+	{0x404A, 0xB8},
+	{0x404B, 0xB5},
+	{0x404C, 0xAB},
+	{0x404D, 0xA4},
+	{0x404E, 0xA5},
+	{0x404F, 0xA3},
+	{0x4050, 0x99},
+	{0x4051, 0x96},
+	{0x4052, 0x96},
+	{0x4053, 0x96},
+	{0x4054, 0x8B},
+	{0x4055, 0x8A},
+	{0x4056, 0x8A},
+	{0x4057, 0x8A},
+	{0x4058, 0x82},
+	{0x4059, 0x81},
+	{0x405A, 0x81},
+	{0x405B, 0x81},
+	{0x405C, 0x85},
+	{0x405D, 0x86},
+	{0x405E, 0x85},
+	{0x405F, 0x85},
+	{0x4060, 0x90},
+	{0x4061, 0x90},
+	{0x4062, 0x8F},
+	{0x4063, 0x8F},
+	{0x4064, 0x9D},
+	{0x4065, 0x9B},
+	{0x4066, 0x9B},
+	{0x4067, 0x9A},
+	{0x4068, 0xAF},
+	{0x4069, 0xAA},
+	{0x406A, 0xAC},
+	{0x406B, 0xAA},
+	{0x406C, 0xC2},
+	{0x406D, 0xB7},
+	{0x406E, 0xB8},
+	{0x406F, 0xB5},
+	{0x4070, 0xAB},
+	{0x4071, 0xA4},
+	{0x4072, 0xA4},
+	{0x4073, 0xA3},
+	{0x4074, 0x99},
+	{0x4075, 0x96},
+	{0x4076, 0x96},
+	{0x4077, 0x96},
+	{0x4078, 0x8B},
+	{0x4079, 0x8A},
+	{0x407A, 0x8A},
+	{0x407B, 0x8A},
+	{0x407C, 0x82},
+	{0x407D, 0x82},
+	{0x407E, 0x82},
+	{0x407F, 0x82},
+	{0x4080, 0x85},
+	{0x4081, 0x86},
+	{0x4082, 0x86},
+	{0x4083, 0x86},
+	{0x4084, 0x90},
+	{0x4085, 0x90},
+	{0x4086, 0x8F},
+	{0x4087, 0x8F},
+	{0x4088, 0x9D},
+	{0x4089, 0x9B},
+	{0x408A, 0x9B},
+	{0x408B, 0x99},
+	{0x408C, 0xAE},
+	{0x408D, 0xAA},
+	{0x408E, 0xAA},
+	{0x408F, 0xA7},
+	{0x4090, 0xC7},
+	{0x4091, 0xBA},
+	{0x4092, 0xBC},
+	{0x4093, 0xB9},
+	{0x4094, 0xB1},
+	{0x4095, 0xA8},
+	{0x4096, 0xA8},
+	{0x4097, 0xA7},
+	{0x4098, 0x9F},
+	{0x4099, 0x9B},
+	{0x409A, 0x9B},
+	{0x409B, 0x9B},
+	{0x409C, 0x93},
+	{0x409D, 0x91},
+	{0x409E, 0x91},
+	{0x409F, 0x91},
+	{0x40A0, 0x8D},
+	{0x40A1, 0x8C},
+	{0x40A2, 0x8C},
+	{0x40A3, 0x8C},
+	{0x40A4, 0x8E},
+	{0x40A5, 0x8E},
+	{0x40A6, 0x8D},
+	{0x40A7, 0x8D},
+	{0x40A8, 0x96},
+	{0x40A9, 0x95},
+	{0x40AA, 0x95},
+	{0x40AB, 0x94},
+	{0x40AC, 0xA2},
+	{0x40AD, 0x9F},
+	{0x40AE, 0x9F},
+	{0x40AF, 0x9D},
+	{0x40B0, 0xB1},
+	{0x40B1, 0xAC},
+	{0x40B2, 0xAB},
+	{0x40B3, 0xAA},
+	{0x40B4, 0xD3},
+	{0x40B5, 0xBC},
+	{0x40B6, 0xBD},
+	{0x40B7, 0xBC},
+	{0x40B8, 0xC1},
+	{0x40B9, 0xB7},
+	{0x40BA, 0xB7},
+	{0x40BB, 0xB5},
+	{0x40BC, 0xB0},
+	{0x40BD, 0xAA},
+	{0x40BE, 0xAA},
+	{0x40BF, 0xAA},
+	{0x40C0, 0xA8},
+	{0x40C1, 0xA4},
+	{0x40C2, 0xA4},
+	{0x40C3, 0xA4},
+	{0x40C4, 0xA2},
+	{0x40C5, 0x9F},
+	{0x40C6, 0x9F},
+	{0x40C7, 0x9F},
+	{0x40C8, 0xA3},
+	{0x40C9, 0xA0},
+	{0x40CA, 0xA0},
+	{0x40CB, 0xA0},
+	{0x40CC, 0xA6},
+	{0x40CD, 0xA3},
+	{0x40CE, 0xA3},
+	{0x40CF, 0xA2},
+	{0x40D0, 0xAF},
+	{0x40D1, 0xAB},
+	{0x40D2, 0xAA},
+	{0x40D3, 0xA8},
+	{0x40D4, 0xBA},
+	{0x40D5, 0xAE},
+	{0x40D6, 0xAE},
+	{0x40D7, 0xAB},
+	{0x4100, 0xBD},
+	{0x4101, 0xBA},
+	{0x4102, 0xBD},
+	{0x4103, 0xB7},
+	{0x4104, 0xB7},
+	{0x4105, 0xB7},
+	{0x4106, 0xB8},
+	{0x4107, 0xB5},
+	{0x4108, 0xAB},
+	{0x4109, 0xAA},
+	{0x410A, 0xAC},
+	{0x410B, 0xAB},
+	{0x410C, 0xA4},
+	{0x410D, 0xA5},
+	{0x410E, 0xA5},
+	{0x410F, 0xA4},
+	{0x4110, 0x9F},
+	{0x4111, 0xA0},
+	{0x4112, 0xA0},
+	{0x4113, 0x9F},
+	{0x4114, 0xA0},
+	{0x4115, 0xA0},
+	{0x4116, 0xA0},
+	{0x4117, 0x9F},
+	{0x4118, 0xA1},
+	{0x4119, 0xA1},
+	{0x411A, 0xA1},
+	{0x411B, 0xA0},
+	{0x411C, 0xA7},
+	{0x411D, 0xA6},
+	{0x411E, 0xA6},
+	{0x411F, 0xA6},
+	{0x4120, 0xA7},
+	{0x4121, 0xA6},
+	{0x4122, 0xA6},
+	{0x4123, 0xA3},
+	{0x4124, 0xB9},
+	{0x4125, 0xB9},
+	{0x4126, 0xBA},
+	{0x4127, 0xB8},
+	{0x4128, 0xA6},
+	{0x4129, 0xA7},
+	{0x412A, 0xA7},
+	{0x412B, 0xA6},
+	{0x412C, 0x9B},
+	{0x412D, 0x9B},
+	{0x412E, 0x9B},
+	{0x412F, 0x9B},
+	{0x4130, 0x91},
+	{0x4131, 0x92},
+	{0x4132, 0x92},
+	{0x4133, 0x91},
+	{0x4134, 0x8C},
+	{0x4135, 0x8C},
+	{0x4136, 0x8C},
+	{0x4137, 0x8C},
+	{0x4138, 0x8D},
+	{0x4139, 0x8D},
+	{0x413A, 0x8D},
+	{0x413B, 0x8D},
+	{0x413C, 0x93},
+	{0x413D, 0x93},
+	{0x413E, 0x93},
+	{0x413F, 0x92},
+	{0x4140, 0x9A},
+	{0x4141, 0x9A},
+	{0x4142, 0x9A},
+	{0x4143, 0x99},
+	{0x4144, 0xA7},
+	{0x4145, 0xA5},
+	{0x4146, 0xA6},
+	{0x4147, 0xA6},
+	{0x4148, 0xB8},
+	{0x4149, 0xB4},
+	{0x414A, 0xB4},
+	{0x414B, 0xB3},
+	{0x414C, 0xA3},
+	{0x414D, 0xA2},
+	{0x414E, 0xA3},
+	{0x414F, 0xA2},
+	{0x4150, 0x96},
+	{0x4151, 0x96},
+	{0x4152, 0x96},
+	{0x4153, 0x96},
+	{0x4154, 0x8A},
+	{0x4155, 0x8A},
+	{0x4156, 0x8A},
+	{0x4157, 0x8A},
+	{0x4158, 0x82},
+	{0x4159, 0x82},
+	{0x415A, 0x82},
+	{0x415B, 0x82},
+	{0x415C, 0x84},
+	{0x415D, 0x85},
+	{0x415E, 0x84},
+	{0x415F, 0x84},
+	{0x4160, 0x8D},
+	{0x4161, 0x8D},
+	{0x4162, 0x8D},
+	{0x4163, 0x8D},
+	{0x4164, 0x96},
+	{0x4165, 0x96},
+	{0x4166, 0x96},
+	{0x4167, 0x95},
+	{0x4168, 0xA5},
+	{0x4169, 0xA2},
+	{0x416A, 0xA3},
+	{0x416B, 0xA2},
+	{0x416C, 0xB7},
+	{0x416D, 0xB3},
+	{0x416E, 0xB5},
+	{0x416F, 0xB4},
+	{0x4170, 0xA4},
+	{0x4171, 0xA2},
+	{0x4172, 0xA3},
+	{0x4173, 0xA2},
+	{0x4174, 0x97},
+	{0x4175, 0x96},
+	{0x4176, 0x96},
+	{0x4177, 0x96},
+	{0x4178, 0x8B},
+	{0x4179, 0x8A},
+	{0x417A, 0x8A},
+	{0x417B, 0x8A},
+	{0x417C, 0x81},
+	{0x417D, 0x81},
+	{0x417E, 0x81},
+	{0x417F, 0x81},
+	{0x4180, 0x84},
+	{0x4181, 0x84},
+	{0x4182, 0x84},
+	{0x4183, 0x84},
+	{0x4184, 0x8C},
+	{0x4185, 0x8D},
+	{0x4186, 0x8D},
+	{0x4187, 0x8D},
+	{0x4188, 0x95},
+	{0x4189, 0x96},
+	{0x418A, 0x96},
+	{0x418B, 0x95},
+	{0x418C, 0xA1},
+	{0x418D, 0xA1},
+	{0x418E, 0xA1},
+	{0x418F, 0xA0},
+	{0x4190, 0xBC},
+	{0x4191, 0xB8},
+	{0x4192, 0xB8},
+	{0x4193, 0xB9},
+	{0x4194, 0xA8},
+	{0x4195, 0xA5},
+	{0x4196, 0xA6},
+	{0x4197, 0xA5},
+	{0x4198, 0x9C},
+	{0x4199, 0x9A},
+	{0x419A, 0x9A},
+	{0x419B, 0x9A},
+	{0x419C, 0x91},
+	{0x419D, 0x91},
+	{0x419E, 0x91},
+	{0x419F, 0x91},
+	{0x41A0, 0x8B},
+	{0x41A1, 0x8B},
+	{0x41A2, 0x8B},
+	{0x41A3, 0x8B},
+	{0x41A4, 0x8C},
+	{0x41A5, 0x8C},
+	{0x41A6, 0x8C},
+	{0x41A7, 0x8C},
+	{0x41A8, 0x91},
+	{0x41A9, 0x92},
+	{0x41AA, 0x91},
+	{0x41AB, 0x91},
+	{0x41AC, 0x98},
+	{0x41AD, 0x99},
+	{0x41AE, 0x99},
+	{0x41AF, 0x98},
+	{0x41B0, 0xA3},
+	{0x41B1, 0xA3},
+	{0x41B2, 0xA3},
+	{0x41B3, 0xA2},
+	{0x41B4, 0xC1},
+	{0x41B5, 0xB8},
+	{0x41B6, 0xB9},
+	{0x41B7, 0xBA},
+	{0x41B8, 0xB8},
+	{0x41B9, 0xB4},
+	{0x41BA, 0xB4},
+	{0x41BB, 0xB4},
+	{0x41BC, 0xAA},
+	{0x41BD, 0xA7},
+	{0x41BE, 0xA7},
+	{0x41BF, 0xA8},
+	{0x41C0, 0xA4},
+	{0x41C1, 0xA2},
+	{0x41C2, 0xA2},
+	{0x41C3, 0xA3},
+	{0x41C4, 0x9E},
+	{0x41C5, 0x9D},
+	{0x41C6, 0x9D},
+	{0x41C7, 0x9D},
+	{0x41C8, 0x9E},
+	{0x41C9, 0x9D},
+	{0x41CA, 0x9D},
+	{0x41CB, 0x9D},
+	{0x41CC, 0x9E},
+	{0x41CD, 0x9E},
+	{0x41CE, 0x9E},
+	{0x41CF, 0x9E},
+	{0x41D0, 0xA3},
+	{0x41D1, 0xA3},
+	{0x41D2, 0xA2},
+	{0x41D3, 0xA1},
+	{0x41D4, 0xA7},
+	{0x41D5, 0xA7},
+	{0x41D6, 0xA7},
+	{0x41D7, 0xA3},
+	{0x4200, 0xCE},
+	{0x4201, 0xC0},
+	{0x4202, 0xC1},
+	{0x4203, 0xB9},
+	{0x4204, 0xC3},
+	{0x4205, 0xB9},
+	{0x4206, 0xBC},
+	{0x4207, 0xBD},
+	{0x4208, 0xB3},
+	{0x4209, 0xAE},
+	{0x420A, 0xAF},
+	{0x420B, 0xAE},
+	{0x420C, 0xAA},
+	{0x420D, 0xA8},
+	{0x420E, 0xA8},
+	{0x420F, 0xA6},
+	{0x4210, 0xA4},
+	{0x4211, 0xA2},
+	{0x4212, 0xA2},
+	{0x4213, 0xA0},
+	{0x4214, 0xA4},
+	{0x4215, 0xA3},
+	{0x4216, 0xA2},
+	{0x4217, 0xA0},
+	{0x4218, 0xA7},
+	{0x4219, 0xA5},
+	{0x421A, 0xA3},
+	{0x421B, 0xA1},
+	{0x421C, 0xB0},
+	{0x421D, 0xA8},
+	{0x421E, 0xA8},
+	{0x421F, 0xA6},
+	{0x4220, 0xB4},
+	{0x4221, 0xAA},
+	{0x4222, 0xA5},
+	{0x4223, 0xA3},
+	{0x4224, 0xC7},
+	{0x4225, 0xBC},
+	{0x4226, 0xBE},
+	{0x4227, 0xBC},
+	{0x4228, 0xB0},
+	{0x4229, 0xA9},
+	{0x422A, 0xA9},
+	{0x422B, 0xA8},
+	{0x422C, 0xA0},
+	{0x422D, 0x9D},
+	{0x422E, 0x9D},
+	{0x422F, 0x9C},
+	{0x4230, 0x94},
+	{0x4231, 0x93},
+	{0x4232, 0x93},
+	{0x4233, 0x92},
+	{0x4234, 0x8E},
+	{0x4235, 0x8D},
+	{0x4236, 0x8D},
+	{0x4237, 0x8C},
+	{0x4238, 0x8F},
+	{0x4239, 0x8E},
+	{0x423A, 0x8E},
+	{0x423B, 0x8D},
+	{0x423C, 0x96},
+	{0x423D, 0x94},
+	{0x423E, 0x94},
+	{0x423F, 0x92},
+	{0x4240, 0xA1},
+	{0x4241, 0x9C},
+	{0x4242, 0x9C},
+	{0x4243, 0x99},
+	{0x4244, 0xB0},
+	{0x4245, 0xA8},
+	{0x4246, 0xAB},
+	{0x4247, 0xA7},
+	{0x4248, 0xC3},
+	{0x4249, 0xB7},
+	{0x424A, 0xB7},
+	{0x424B, 0xBC},
+	{0x424C, 0xAB},
+	{0x424D, 0xA4},
+	{0x424E, 0xA5},
+	{0x424F, 0xA5},
+	{0x4250, 0x9A},
+	{0x4251, 0x97},
+	{0x4252, 0x97},
+	{0x4253, 0x98},
+	{0x4254, 0x8C},
+	{0x4255, 0x8B},
+	{0x4256, 0x8B},
+	{0x4257, 0x8B},
+	{0x4258, 0x82},
+	{0x4259, 0x82},
+	{0x425A, 0x82},
+	{0x425B, 0x82},
+	{0x425C, 0x85},
+	{0x425D, 0x85},
+	{0x425E, 0x85},
+	{0x425F, 0x84},
+	{0x4260, 0x8F},
+	{0x4261, 0x8E},
+	{0x4262, 0x8E},
+	{0x4263, 0x8D},
+	{0x4264, 0x9B},
+	{0x4265, 0x98},
+	{0x4266, 0x98},
+	{0x4267, 0x95},
+	{0x4268, 0xAE},
+	{0x4269, 0xA5},
+	{0x426A, 0xA7},
+	{0x426B, 0xA2},
+	{0x426C, 0xC2},
+	{0x426D, 0xB7},
+	{0x426E, 0xB8},
+	{0x426F, 0xB9},
+	{0x4270, 0xAA},
+	{0x4271, 0xA4},
+	{0x4272, 0xA4},
+	{0x4273, 0xA5},
+	{0x4274, 0x99},
+	{0x4275, 0x96},
+	{0x4276, 0x97},
+	{0x4277, 0x98},
+	{0x4278, 0x8B},
+	{0x4279, 0x8A},
+	{0x427A, 0x8A},
+	{0x427B, 0x8B},
+	{0x427C, 0x81},
+	{0x427D, 0x81},
+	{0x427E, 0x81},
+	{0x427F, 0x82},
+	{0x4280, 0x84},
+	{0x4281, 0x84},
+	{0x4282, 0x84},
+	{0x4283, 0x84},
+	{0x4284, 0x8E},
+	{0x4285, 0x8E},
+	{0x4286, 0x8D},
+	{0x4287, 0x8C},
+	{0x4288, 0x9A},
+	{0x4289, 0x97},
+	{0x428A, 0x97},
+	{0x428B, 0x95},
+	{0x428C, 0xAA},
+	{0x428D, 0xA3},
+	{0x428E, 0xA3},
+	{0x428F, 0xA2},
+	{0x4290, 0xC7},
+	{0x4291, 0xBA},
+	{0x4292, 0xC0},
+	{0x4293, 0xC3},
+	{0x4294, 0xB0},
+	{0x4295, 0xA7},
+	{0x4296, 0xA7},
+	{0x4297, 0xA9},
+	{0x4298, 0x9F},
+	{0x4299, 0x9B},
+	{0x429A, 0x9B},
+	{0x429B, 0x9D},
+	{0x429C, 0x93},
+	{0x429D, 0x91},
+	{0x429E, 0x91},
+	{0x429F, 0x92},
+	{0x42A0, 0x8C},
+	{0x42A1, 0x8B},
+	{0x42A2, 0x8B},
+	{0x42A3, 0x8C},
+	{0x42A4, 0x8D},
+	{0x42A5, 0x8C},
+	{0x42A6, 0x8C},
+	{0x42A7, 0x8C},
+	{0x42A8, 0x94},
+	{0x42A9, 0x93},
+	{0x42AA, 0x92},
+	{0x42AB, 0x91},
+	{0x42AC, 0x9E},
+	{0x42AD, 0x9B},
+	{0x42AE, 0x9B},
+	{0x42AF, 0x98},
+	{0x42B0, 0xAC},
+	{0x42B1, 0xA6},
+	{0x42B2, 0xA6},
+	{0x42B3, 0xA2},
+	{0x42B4, 0xCE},
+	{0x42B5, 0xBA},
+	{0x42B6, 0xBC},
+	{0x42B7, 0xB7},
+	{0x42B8, 0xC5},
+	{0x42B9, 0xB5},
+	{0x42BA, 0xBA},
+	{0x42BB, 0xC0},
+	{0x42BC, 0xB1},
+	{0x42BD, 0xA8},
+	{0x42BE, 0xAE},
+	{0x42BF, 0xAF},
+	{0x42C0, 0xA7},
+	{0x42C1, 0xA3},
+	{0x42C2, 0xA3},
+	{0x42C3, 0xA5},
+	{0x42C4, 0xA0},
+	{0x42C5, 0x9D},
+	{0x42C6, 0x9D},
+	{0x42C7, 0x9F},
+	{0x42C8, 0xA0},
+	{0x42C9, 0x9E},
+	{0x42CA, 0x9E},
+	{0x42CB, 0x9F},
+	{0x42CC, 0xA2},
+	{0x42CD, 0xA0},
+	{0x42CE, 0xA0},
+	{0x42CF, 0xA0},
+	{0x42D0, 0xA8},
+	{0x42D1, 0xA5},
+	{0x42D2, 0xA5},
+	{0x42D3, 0xA2},
+	{0x42D4, 0xB3},
+	{0x42D5, 0xAA},
+	{0x42D6, 0xAB},
+	{0x42D7, 0xA3},
+	{0x42D8, 0x00},
+	{0x42D9, 0x00},
+	{0x4300, 0xA2},
+	{0x4301, 0xAE},
+	{0x4302, 0xAD},
+	{0x4303, 0xB5},
+	{0x4304, 0x95},
+	{0x4305, 0x9A},
+	{0x4306, 0x98},
+	{0x4307, 0x9B},
+	{0x4308, 0x8D},
+	{0x4309, 0x90},
+	{0x430A, 0x8F},
+	{0x430B, 0x91},
+	{0x430C, 0x86},
+	{0x430D, 0x88},
+	{0x430E, 0x87},
+	{0x430F, 0x89},
+	{0x4310, 0x86},
+	{0x4311, 0x87},
+	{0x4312, 0x86},
+	{0x4313, 0x88},
+	{0x4314, 0x89},
+	{0x4315, 0x88},
+	{0x4316, 0x88},
+	{0x4317, 0x8E},
+	{0x4318, 0x90},
+	{0x4319, 0x8F},
+	{0x431A, 0x8C},
+	{0x431B, 0x8C},
+	{0x431C, 0x9C},
+	{0x431D, 0x99},
+	{0x431E, 0x98},
+	{0x431F, 0x99},
+	{0x4320, 0xAB},
+	{0x4321, 0xB0},
+	{0x4322, 0xAD},
+	{0x4323, 0xAF},
+	{0x4324, 0x9B},
+	{0x4325, 0x9F},
+	{0x4326, 0x9E},
+	{0x4327, 0xA1},
+	{0x4328, 0x8E},
+	{0x4329, 0x91},
+	{0x432A, 0x90},
+	{0x432B, 0x93},
+	{0x432C, 0x86},
+	{0x432D, 0x88},
+	{0x432E, 0x87},
+	{0x432F, 0x89},
+	{0x4330, 0x82},
+	{0x4331, 0x84},
+	{0x4332, 0x83},
+	{0x4333, 0x84},
+	{0x4334, 0x82},
+	{0x4335, 0x82},
+	{0x4336, 0x82},
+	{0x4337, 0x83},
+	{0x4338, 0x85},
+	{0x4339, 0x84},
+	{0x433A, 0x84},
+	{0x433B, 0x85},
+	{0x433C, 0x8A},
+	{0x433D, 0x89},
+	{0x433E, 0x88},
+	{0x433F, 0x89},
+	{0x4340, 0x93},
+	{0x4341, 0x91},
+	{0x4342, 0x91},
+	{0x4343, 0x93},
+	{0x4344, 0xA0},
+	{0x4345, 0x9E},
+	{0x4346, 0x9D},
+	{0x4347, 0xA1},
+	{0x4348, 0x95},
+	{0x4349, 0x9B},
+	{0x434A, 0x9A},
+	{0x434B, 0x9C},
+	{0x434C, 0x8A},
+	{0x434D, 0x8D},
+	{0x434E, 0x8C},
+	{0x434F, 0x8D},
+	{0x4350, 0x83},
+	{0x4351, 0x85},
+	{0x4352, 0x84},
+	{0x4353, 0x85},
+	{0x4354, 0x80},
+	{0x4355, 0x81},
+	{0x4356, 0x81},
+	{0x4357, 0x81},
+	{0x4358, 0x80},
+	{0x4359, 0x80},
+	{0x435A, 0x80},
+	{0x435B, 0x80},
+	{0x435C, 0x82},
+	{0x435D, 0x81},
+	{0x435E, 0x81},
+	{0x435F, 0x81},
+	{0x4360, 0x85},
+	{0x4361, 0x84},
+	{0x4362, 0x84},
+	{0x4363, 0x85},
+	{0x4364, 0x8D},
+	{0x4365, 0x8B},
+	{0x4366, 0x8B},
+	{0x4367, 0x8D},
+	{0x4368, 0x98},
+	{0x4369, 0x98},
+	{0x436A, 0x95},
+	{0x436B, 0x98},
+	{0x436C, 0x95},
+	{0x436D, 0x9A},
+	{0x436E, 0x99},
+	{0x436F, 0x9A},
+	{0x4370, 0x8A},
+	{0x4371, 0x8D},
+	{0x4372, 0x8C},
+	{0x4373, 0x8C},
+	{0x4374, 0x83},
+	{0x4375, 0x85},
+	{0x4376, 0x84},
+	{0x4377, 0x84},
+	{0x4378, 0x80},
+	{0x4379, 0x80},
+	{0x437A, 0x80},
+	{0x437B, 0x80},
+	{0x437C, 0x7F},
+	{0x437D, 0x7F},
+	{0x437E, 0x7F},
+	{0x437F, 0x7F},
+	{0x4380, 0x81},
+	{0x4381, 0x80},
+	{0x4382, 0x80},
+	{0x4383, 0x81},
+	{0x4384, 0x84},
+	{0x4385, 0x83},
+	{0x4386, 0x83},
+	{0x4387, 0x84},
+	{0x4388, 0x8B},
+	{0x4389, 0x8A},
+	{0x438A, 0x8A},
+	{0x438B, 0x8C},
+	{0x438C, 0x97},
+	{0x438D, 0x96},
+	{0x438E, 0x96},
+	{0x438F, 0x99},
+	{0x4390, 0x99},
+	{0x4391, 0x9F},
+	{0x4392, 0x9E},
+	{0x4393, 0x9D},
+	{0x4394, 0x8D},
+	{0x4395, 0x90},
+	{0x4396, 0x90},
+	{0x4397, 0x8F},
+	{0x4398, 0x85},
+	{0x4399, 0x87},
+	{0x439A, 0x87},
+	{0x439B, 0x86},
+	{0x439C, 0x81},
+	{0x439D, 0x83},
+	{0x439E, 0x82},
+	{0x439F, 0x82},
+	{0x43A0, 0x80},
+	{0x43A1, 0x81},
+	{0x43A2, 0x81},
+	{0x43A3, 0x81},
+	{0x43A4, 0x82},
+	{0x43A5, 0x82},
+	{0x43A6, 0x82},
+	{0x43A7, 0x82},
+	{0x43A8, 0x86},
+	{0x43A9, 0x85},
+	{0x43AA, 0x85},
+	{0x43AB, 0x87},
+	{0x43AC, 0x8D},
+	{0x43AD, 0x8D},
+	{0x43AE, 0x8D},
+	{0x43AF, 0x90},
+	{0x43B0, 0x9A},
+	{0x43B1, 0x9A},
+	{0x43B2, 0x9B},
+	{0x43B3, 0x9D},
+	{0x43B4, 0xA0},
+	{0x43B5, 0xAD},
+	{0x43B6, 0xAC},
+	{0x43B7, 0xAA},
+	{0x43B8, 0x93},
+	{0x43B9, 0x97},
+	{0x43BA, 0x97},
+	{0x43BB, 0x96},
+	{0x43BC, 0x8B},
+	{0x43BD, 0x8E},
+	{0x43BE, 0x8E},
+	{0x43BF, 0x8C},
+	{0x43C0, 0x83},
+	{0x43C1, 0x85},
+	{0x43C2, 0x85},
+	{0x43C3, 0x84},
+	{0x43C4, 0x82},
+	{0x43C5, 0x84},
+	{0x43C6, 0x83},
+	{0x43C7, 0x83},
+	{0x43C8, 0x83},
+	{0x43C9, 0x84},
+	{0x43CA, 0x84},
+	{0x43CB, 0x85},
+	{0x43CC, 0x8A},
+	{0x43CD, 0x8A},
+	{0x43CE, 0x8A},
+	{0x43CF, 0x8C},
+	{0x43D0, 0x92},
+	{0x43D1, 0x93},
+	{0x43D2, 0x93},
+	{0x43D3, 0x96},
+	{0x43D4, 0x9F},
+	{0x43D5, 0xA6},
+	{0x43D6, 0xA5},
+	{0x43D7, 0xAA},
+	{0x4400, 0xA1},
+	{0x4401, 0xAB},
+	{0x4402, 0xA7},
+	{0x4403, 0xB0},
+	{0x4404, 0x91},
+	{0x4405, 0x96},
+	{0x4406, 0x94},
+	{0x4407, 0x99},
+	{0x4408, 0x8A},
+	{0x4409, 0x8E},
+	{0x440A, 0x8C},
+	{0x440B, 0x8F},
+	{0x440C, 0x85},
+	{0x440D, 0x86},
+	{0x440E, 0x86},
+	{0x440F, 0x88},
+	{0x4410, 0x85},
+	{0x4411, 0x86},
+	{0x4412, 0x85},
+	{0x4413, 0x87},
+	{0x4414, 0x88},
+	{0x4415, 0x87},
+	{0x4416, 0x87},
+	{0x4417, 0x89},
+	{0x4418, 0x91},
+	{0x4419, 0x8F},
+	{0x441A, 0x8F},
+	{0x441B, 0x90},
+	{0x441C, 0x9C},
+	{0x441D, 0x9B},
+	{0x441E, 0x9A},
+	{0x441F, 0x9A},
+	{0x4420, 0xB3},
+	{0x4421, 0xB1},
+	{0x4422, 0xB0},
+	{0x4423, 0xB2},
+	{0x4424, 0x96},
+	{0x4425, 0x9C},
+	{0x4426, 0x9A},
+	{0x4427, 0x9E},
+	{0x4428, 0x8B},
+	{0x4429, 0x8F},
+	{0x442A, 0x8E},
+	{0x442B, 0x91},
+	{0x442C, 0x84},
+	{0x442D, 0x87},
+	{0x442E, 0x86},
+	{0x442F, 0x88},
+	{0x4430, 0x82},
+	{0x4431, 0x83},
+	{0x4432, 0x82},
+	{0x4433, 0x84},
+	{0x4434, 0x82},
+	{0x4435, 0x82},
+	{0x4436, 0x82},
+	{0x4437, 0x83},
+	{0x4438, 0x84},
+	{0x4439, 0x84},
+	{0x443A, 0x84},
+	{0x443B, 0x84},
+	{0x443C, 0x8B},
+	{0x443D, 0x89},
+	{0x443E, 0x89},
+	{0x443F, 0x89},
+	{0x4440, 0x95},
+	{0x4441, 0x93},
+	{0x4442, 0x93},
+	{0x4443, 0x93},
+	{0x4444, 0xA2},
+	{0x4445, 0xA2},
+	{0x4446, 0xA1},
+	{0x4447, 0xA0},
+	{0x4448, 0x8F},
+	{0x4449, 0x97},
+	{0x444A, 0x97},
+	{0x444B, 0x98},
+	{0x444C, 0x87},
+	{0x444D, 0x8B},
+	{0x444E, 0x8A},
+	{0x444F, 0x8B},
+	{0x4450, 0x81},
+	{0x4451, 0x83},
+	{0x4452, 0x83},
+	{0x4453, 0x84},
+	{0x4454, 0x7F},
+	{0x4455, 0x80},
+	{0x4456, 0x80},
+	{0x4457, 0x81},
+	{0x4458, 0x80},
+	{0x4459, 0x80},
+	{0x445A, 0x80},
+	{0x445B, 0x80},
+	{0x445C, 0x82},
+	{0x445D, 0x81},
+	{0x445E, 0x81},
+	{0x445F, 0x81},
+	{0x4460, 0x87},
+	{0x4461, 0x85},
+	{0x4462, 0x85},
+	{0x4463, 0x86},
+	{0x4464, 0x90},
+	{0x4465, 0x8E},
+	{0x4466, 0x8E},
+	{0x4467, 0x8E},
+	{0x4468, 0x9B},
+	{0x4469, 0x9C},
+	{0x446A, 0x9A},
+	{0x446B, 0x9A},
+	{0x446C, 0x91},
+	{0x446D, 0x97},
+	{0x446E, 0x95},
+	{0x446F, 0x95},
+	{0x4470, 0x87},
+	{0x4471, 0x8A},
+	{0x4472, 0x8A},
+	{0x4473, 0x89},
+	{0x4474, 0x81},
+	{0x4475, 0x83},
+	{0x4476, 0x83},
+	{0x4477, 0x83},
+	{0x4478, 0x7F},
+	{0x4479, 0x80},
+	{0x447A, 0x80},
+	{0x447B, 0x80},
+	{0x447C, 0x80},
+	{0x447D, 0x80},
+	{0x447E, 0x80},
+	{0x447F, 0x7F},
+	{0x4480, 0x81},
+	{0x4481, 0x81},
+	{0x4482, 0x81},
+	{0x4483, 0x81},
+	{0x4484, 0x85},
+	{0x4485, 0x85},
+	{0x4486, 0x85},
+	{0x4487, 0x85},
+	{0x4488, 0x8E},
+	{0x4489, 0x8D},
+	{0x448A, 0x8D},
+	{0x448B, 0x8E},
+	{0x448C, 0x9D},
+	{0x448D, 0x9C},
+	{0x448E, 0x9C},
+	{0x448F, 0x9C},
+	{0x4490, 0x94},
+	{0x4491, 0x9B},
+	{0x4492, 0x9A},
+	{0x4493, 0x97},
+	{0x4494, 0x8A},
+	{0x4495, 0x8E},
+	{0x4496, 0x8E},
+	{0x4497, 0x8C},
+	{0x4498, 0x84},
+	{0x4499, 0x86},
+	{0x449A, 0x86},
+	{0x449B, 0x84},
+	{0x449C, 0x81},
+	{0x449D, 0x83},
+	{0x449E, 0x83},
+	{0x449F, 0x81},
+	{0x44A0, 0x81},
+	{0x44A1, 0x82},
+	{0x44A2, 0x82},
+	{0x44A3, 0x81},
+	{0x44A4, 0x83},
+	{0x44A5, 0x83},
+	{0x44A6, 0x83},
+	{0x44A7, 0x83},
+	{0x44A8, 0x88},
+	{0x44A9, 0x88},
+	{0x44AA, 0x88},
+	{0x44AB, 0x88},
+	{0x44AC, 0x91},
+	{0x44AD, 0x91},
+	{0x44AE, 0x91},
+	{0x44AF, 0x92},
+	{0x44B0, 0xA0},
+	{0x44B1, 0xA0},
+	{0x44B2, 0xA0},
+	{0x44B3, 0xA0},
+	{0x44B4, 0x9E},
+	{0x44B5, 0xA9},
+	{0x44B6, 0xA8},
+	{0x44B7, 0xA3},
+	{0x44B8, 0x90},
+	{0x44B9, 0x95},
+	{0x44BA, 0x95},
+	{0x44BB, 0x92},
+	{0x44BC, 0x8A},
+	{0x44BD, 0x8E},
+	{0x44BE, 0x8E},
+	{0x44BF, 0x8B},
+	{0x44C0, 0x84},
+	{0x44C1, 0x86},
+	{0x44C2, 0x86},
+	{0x44C3, 0x84},
+	{0x44C4, 0x84},
+	{0x44C5, 0x85},
+	{0x44C6, 0x85},
+	{0x44C7, 0x84},
+	{0x44C8, 0x86},
+	{0x44C9, 0x87},
+	{0x44CA, 0x87},
+	{0x44CB, 0x86},
+	{0x44CC, 0x8D},
+	{0x44CD, 0x8E},
+	{0x44CE, 0x8E},
+	{0x44CF, 0x8D},
+	{0x44D0, 0x98},
+	{0x44D1, 0x98},
+	{0x44D2, 0x99},
+	{0x44D3, 0x9A},
+	{0x44D4, 0xA9},
+	{0x44D5, 0xAA},
+	{0x44D6, 0xAA},
+	{0x44D7, 0xAD},
+	{0x4500, 0x9F},
+	{0x4501, 0xA8},
+	{0x4502, 0xA5},
+	{0x4503, 0xAF},
+	{0x4504, 0x8F},
+	{0x4505, 0x96},
+	{0x4506, 0x92},
+	{0x4507, 0x94},
+	{0x4508, 0x89},
+	{0x4509, 0x8D},
+	{0x450A, 0x8A},
+	{0x450B, 0x8E},
+	{0x450C, 0x84},
+	{0x450D, 0x85},
+	{0x450E, 0x84},
+	{0x450F, 0x87},
+	{0x4510, 0x84},
+	{0x4511, 0x85},
+	{0x4512, 0x84},
+	{0x4513, 0x86},
+	{0x4514, 0x87},
+	{0x4515, 0x86},
+	{0x4516, 0x86},
+	{0x4517, 0x88},
+	{0x4518, 0x8F},
+	{0x4519, 0x8D},
+	{0x451A, 0x8D},
+	{0x451B, 0x8F},
+	{0x451C, 0x9A},
+	{0x451D, 0x9A},
+	{0x451E, 0x98},
+	{0x451F, 0x9A},
+	{0x4520, 0xAF},
+	{0x4521, 0xAF},
+	{0x4522, 0xB2},
+	{0x4523, 0xB1},
+	{0x4524, 0x95},
+	{0x4525, 0x9B},
+	{0x4526, 0x97},
+	{0x4527, 0x9C},
+	{0x4528, 0x8A},
+	{0x4529, 0x8E},
+	{0x452A, 0x8D},
+	{0x452B, 0x90},
+	{0x452C, 0x84},
+	{0x452D, 0x86},
+	{0x452E, 0x85},
+	{0x452F, 0x87},
+	{0x4530, 0x81},
+	{0x4531, 0x82},
+	{0x4532, 0x82},
+	{0x4533, 0x83},
+	{0x4534, 0x81},
+	{0x4535, 0x81},
+	{0x4536, 0x81},
+	{0x4537, 0x82},
+	{0x4538, 0x84},
+	{0x4539, 0x83},
+	{0x453A, 0x83},
+	{0x453B, 0x84},
+	{0x453C, 0x8A},
+	{0x453D, 0x88},
+	{0x453E, 0x88},
+	{0x453F, 0x89},
+	{0x4540, 0x94},
+	{0x4541, 0x92},
+	{0x4542, 0x91},
+	{0x4543, 0x92},
+	{0x4544, 0xA1},
+	{0x4545, 0xA0},
+	{0x4546, 0x9C},
+	{0x4547, 0x9D},
+	{0x4548, 0x8F},
+	{0x4549, 0x96},
+	{0x454A, 0x95},
+	{0x454B, 0x92},
+	{0x454C, 0x87},
+	{0x454D, 0x8A},
+	{0x454E, 0x89},
+	{0x454F, 0x8A},
+	{0x4550, 0x81},
+	{0x4551, 0x83},
+	{0x4552, 0x82},
+	{0x4553, 0x83},
+	{0x4554, 0x7F},
+	{0x4555, 0x80},
+	{0x4556, 0x80},
+	{0x4557, 0x81},
+	{0x4558, 0x7F},
+	{0x4559, 0x80},
+	{0x455A, 0x7F},
+	{0x455B, 0x80},
+	{0x455C, 0x81},
+	{0x455D, 0x81},
+	{0x455E, 0x81},
+	{0x455F, 0x81},
+	{0x4560, 0x86},
+	{0x4561, 0x85},
+	{0x4562, 0x85},
+	{0x4563, 0x85},
+	{0x4564, 0x8F},
+	{0x4565, 0x8D},
+	{0x4566, 0x8D},
+	{0x4567, 0x8D},
+	{0x4568, 0x99},
+	{0x4569, 0x9A},
+	{0x456A, 0x97},
+	{0x456B, 0x99},
+	{0x456C, 0x90},
+	{0x456D, 0x95},
+	{0x456E, 0x93},
+	{0x456F, 0x92},
+	{0x4570, 0x87},
+	{0x4571, 0x8A},
+	{0x4572, 0x88},
+	{0x4573, 0x87},
+	{0x4574, 0x81},
+	{0x4575, 0x83},
+	{0x4576, 0x82},
+	{0x4577, 0x82},
+	{0x4578, 0x7F},
+	{0x4579, 0x80},
+	{0x457A, 0x80},
+	{0x457B, 0x80},
+	{0x457C, 0x80},
+	{0x457D, 0x80},
+	{0x457E, 0x80},
+	{0x457F, 0x80},
+	{0x4580, 0x81},
+	{0x4581, 0x81},
+	{0x4582, 0x81},
+	{0x4583, 0x81},
+	{0x4584, 0x85},
+	{0x4585, 0x85},
+	{0x4586, 0x84},
+	{0x4587, 0x85},
+	{0x4588, 0x8E},
+	{0x4589, 0x8D},
+	{0x458A, 0x8C},
+	{0x458B, 0x8D},
+	{0x458C, 0x9B},
+	{0x458D, 0x9B},
+	{0x458E, 0x9A},
+	{0x458F, 0x98},
+	{0x4590, 0x94},
+	{0x4591, 0x9A},
+	{0x4592, 0x94},
+	{0x4593, 0x90},
+	{0x4594, 0x8A},
+	{0x4595, 0x8D},
+	{0x4596, 0x8C},
+	{0x4597, 0x89},
+	{0x4598, 0x84},
+	{0x4599, 0x86},
+	{0x459A, 0x85},
+	{0x459B, 0x83},
+	{0x459C, 0x82},
+	{0x459D, 0x83},
+	{0x459E, 0x82},
+	{0x459F, 0x80},
+	{0x45A0, 0x81},
+	{0x45A1, 0x82},
+	{0x45A2, 0x81},
+	{0x45A3, 0x80},
+	{0x45A4, 0x83},
+	{0x45A5, 0x83},
+	{0x45A6, 0x83},
+	{0x45A7, 0x83},
+	{0x45A8, 0x88},
+	{0x45A9, 0x87},
+	{0x45AA, 0x87},
+	{0x45AB, 0x88},
+	{0x45AC, 0x91},
+	{0x45AD, 0x90},
+	{0x45AE, 0x90},
+	{0x45AF, 0x91},
+	{0x45B0, 0x9F},
+	{0x45B1, 0x9F},
+	{0x45B2, 0x9E},
+	{0x45B3, 0x9F},
+	{0x45B4, 0x9F},
+	{0x45B5, 0xA8},
+	{0x45B6, 0xA6},
+	{0x45B7, 0xA7},
+	{0x45B8, 0x8D},
+	{0x45B9, 0x95},
+	{0x45BA, 0x90},
+	{0x45BB, 0x8A},
+	{0x45BC, 0x89},
+	{0x45BD, 0x8D},
+	{0x45BE, 0x88},
+	{0x45BF, 0x86},
+	{0x45C0, 0x84},
+	{0x45C1, 0x86},
+	{0x45C2, 0x85},
+	{0x45C3, 0x82},
+	{0x45C4, 0x84},
+	{0x45C5, 0x85},
+	{0x45C6, 0x85},
+	{0x45C7, 0x83},
+	{0x45C8, 0x86},
+	{0x45C9, 0x86},
+	{0x45CA, 0x86},
+	{0x45CB, 0x85},
+	{0x45CC, 0x8E},
+	{0x45CD, 0x8D},
+	{0x45CE, 0x8D},
+	{0x45CF, 0x8C},
+	{0x45D0, 0x99},
+	{0x45D1, 0x98},
+	{0x45D2, 0x98},
+	{0x45D3, 0x98},
+	{0x45D4, 0xA6},
+	{0x45D5, 0xA9},
+	{0x45D6, 0xA7},
+	{0x45D7, 0xAC},
+};
+const size_t imx390_mode_1936x1100SP1H_len =
+	ARRAY_SIZE(imx390_mode_1936x1100SP1H);
diff --git a/drivers/d3/imx390/imx390-mode-1936x1100-SP1H.h b/drivers/d3/imx390/imx390-mode-1936x1100-SP1H.h
new file mode 100644
index 000000000000..c2d2efe87053
--- /dev/null
+++ b/drivers/d3/imx390/imx390-mode-1936x1100-SP1H.h
@@ -0,0 +1,30 @@
+/**
+ * @author Greg Rowe <growe@d3engineering.com>
+ *
+ * imx390 v4l2 driver for Nvidia Jetson
+ *
+ * Copyright (c) 2018-2019, D3 Engineering.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+#ifndef _IMX390_1936X1100SP1H_H
+#define _IMX390_1936X1100SP1H_H
+
+
+#include <linux/regmap.h>
+
+extern const struct reg_sequence imx390_mode_1936x1100SP1H[];
+extern const size_t imx390_mode_1936x1100SP1H_len;
+
+
+#endif
diff --git a/drivers/d3/imx390/imx390-mode-1936x1100-SP1L.c b/drivers/d3/imx390/imx390-mode-1936x1100-SP1L.c
new file mode 100644
index 000000000000..716f5ef1addb
--- /dev/null
+++ b/drivers/d3/imx390/imx390-mode-1936x1100-SP1L.c
@@ -0,0 +1,3105 @@
+/**
+ * @author Greg Rowe <growe@d3engineering.com>
+ *
+ * imx390 v4l2 driver for Nvidia Jetson
+ *
+ * Copyright (c) 2018-2019, D3 Engineering.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+#include "imx390-mode-1936x1100-SP1L.h"
+
+/**
+ * This configuration was supplied by Sony. The only real modification
+ * we (D3) made was to disable the rear embedded data line.
+ *
+ * This was supplied on 2018-10-24 and is the SPIL table
+ */
+const struct reg_sequence imx390_mode_1936x1100SP1L[] = {
+	{0x000C, 0xF2},
+	{0x000D, 0x02},
+	{0x000E, 0x00},
+	{0x0010, 0xF2},
+	{0x0011, 0x02},
+	{0x0012, 0x00},
+	{0x0018, 0x15},
+	{0x0019, 0x00},
+	{0x001A, 0x0C},
+	{0x001B, 0x00},
+	{0x0038, 0x00},
+	{0x003C, 0x00},
+	{0x003D, 0x00},
+	{0x003E, 0x00},
+	{0x0040, 0x00},
+	{0x0041, 0x00},
+	{0x0042, 0x00},
+	{0x0044, 0x00},
+	{0x0045, 0x00},
+	{0x0046, 0x00},
+	{0x0048, 0x00},
+	{0x0049, 0x00},
+	{0x004A, 0x00},
+	{0x004C, 0x00},
+	{0x004D, 0x00},
+	{0x004E, 0x00},
+	{0x0050, 0x00},
+	{0x0051, 0x00},
+	{0x0052, 0x00},
+	{0x0054, 0x00},
+	{0x0055, 0x00},
+	{0x0056, 0x00},
+	{0x0058, 0x00},
+	{0x0059, 0x00},
+	{0x005A, 0x00},
+	{0x005C, 0x00},
+	{0x005D, 0x00},
+	{0x005E, 0x00},
+	{0x0060, 0x00},
+	{0x0061, 0x00},
+	{0x0062, 0x00},
+	{0x0064, 0x00},
+	{0x0065, 0x00},
+	{0x0066, 0x00},
+	{0x0068, 0x00},
+	{0x0069, 0x00},
+	{0x006A, 0x00},
+	{0x0078, 0x00},
+	{0x007C, 0x00},
+	{0x007D, 0x00},
+	{0x0080, 0x00},
+	{0x0081, 0x00},
+	{0x00F4, 0x1C},
+	{0x00F5, 0xF8},
+	{0x00F6, 0x01},
+	{0x00F8, 0x03},
+	{0x00F9, 0x00},
+	{0x00FA, 0x01},
+	{0x00FB, 0x00},
+	{0x0114, 0x00},
+	{0x0115, 0x01},
+	{0x0118, 0x20},
+	{0x0119, 0x03},
+	{0x011A, 0x00},
+	{0x011B, 0x41},
+	{0x011C, 0x80},
+	{0x011D, 0x00},
+	{0x0120, 0x20},
+	{0x0121, 0x00},
+	{0x0122, 0x00},
+	{0x0123, 0x44},
+	{0x0124, 0x00},
+	{0x0125, 0x01},
+	{0x0128, 0xAC},
+	{0x0129, 0x0D},
+	{0x012A, 0x00},
+	{0x012B, 0xA4},
+	{0x012C, 0x00},
+	{0x012D, 0x01},
+	{0x0130, 0xC4},
+	{0x0131, 0x09},
+	{0x0132, 0x00},
+	{0x0133, 0xDA},
+	{0x013B, 0x01},
+	{0x01C4, 0x00},
+	{0x01C5, 0x00},
+	{0x01CC, 0x01},
+	{0x01D0, 0x09},
+	{0x01D4, 0x01},
+	{0x0332, 0x21},
+	{0x0333, 0x00},
+	{0x0390, 0x00},
+	{0x0391, 0x00},
+	{0x0392, 0x00},
+	{0x03C0, 0x00},
+	{0x2000, 0x55},
+	{0x2001, 0x55},
+	{0x2002, 0x55},
+	{0x2003, 0x05},
+	{0x2004, 0x02},
+	{0x2008, 0x65},
+	{0x2009, 0x04},
+	{0x200A, 0x00},
+	{0x200C, 0x30},
+	{0x200D, 0x11},
+	{0x2010, 0x04},
+	{0x2014, 0x01},
+	{0x2018, 0x02},
+	{0x2019, 0x04},
+	{0x201A, 0x00},
+	{0x201C, 0x21},
+	{0x201D, 0x11},
+	{0x201E, 0x00},
+	{0x201F, 0x00},
+	{0x2020, 0xBC},
+	{0x2021, 0x00},
+	{0x2022, 0x7F},
+	{0x2023, 0x00},
+	{0x2024, 0xBA},
+	{0x2025, 0x00},
+	{0x2026, 0x81},
+	{0x2027, 0x00},
+	{0x2028, 0x7D},
+	{0x2029, 0x90},
+	{0x202A, 0x05},
+	{0x202C, 0xFC},
+	{0x202D, 0x02},
+	{0x202E, 0x25},
+	{0x202F, 0x03},
+	{0x2030, 0x05},
+	{0x2031, 0x02},
+	{0x2032, 0xCA},
+	{0x2033, 0x02},
+	{0x2034, 0xFC},
+	{0x2035, 0x02},
+	{0x2036, 0x25},
+	{0x2037, 0x03},
+	{0x2038, 0x25},
+	{0x2039, 0x97},
+	{0x203A, 0xEC},
+	{0x203B, 0x01},
+	{0x203C, 0xF5},
+	{0x203D, 0x8E},
+	{0x203E, 0x0C},
+	{0x203F, 0x2D},
+	{0x2040, 0x69},
+	{0x2041, 0x01},
+	{0x2042, 0x8E},
+	{0x2043, 0x01},
+	{0x2044, 0x0C},
+	{0x2045, 0x02},
+	{0x2046, 0x31},
+	{0x2047, 0x02},
+	{0x2048, 0x6A},
+	{0x2049, 0x01},
+	{0x204A, 0x8E},
+	{0x204B, 0x01},
+	{0x204C, 0x0D},
+	{0x204D, 0x02},
+	{0x204E, 0x31},
+	{0x204F, 0x02},
+	{0x2050, 0x7B},
+	{0x2051, 0x00},
+	{0x2052, 0x7D},
+	{0x2053, 0x00},
+	{0x2054, 0x95},
+	{0x2055, 0x00},
+	{0x2056, 0x97},
+	{0x2057, 0x00},
+	{0x2058, 0xAD},
+	{0x2059, 0x00},
+	{0x205A, 0xAF},
+	{0x205B, 0x00},
+	{0x205C, 0x92},
+	{0x205D, 0x00},
+	{0x205E, 0x94},
+	{0x205F, 0x00},
+	{0x2060, 0x8E},
+	{0x2061, 0x00},
+	{0x2062, 0x90},
+	{0x2063, 0x00},
+	{0x2064, 0xB1},
+	{0x2065, 0x00},
+	{0x2066, 0xB3},
+	{0x2067, 0x00},
+	{0x2068, 0x08},
+	{0x2069, 0x00},
+	{0x206A, 0x04},
+	{0x206B, 0x00},
+	{0x206C, 0x84},
+	{0x206D, 0x00},
+	{0x206E, 0x80},
+	{0x206F, 0x00},
+	{0x2070, 0x04},
+	{0x2071, 0x00},
+	{0x2072, 0x46},
+	{0x2073, 0x00},
+	{0x2074, 0xE9},
+	{0x2075, 0x01},
+	{0x2076, 0x74},
+	{0x2077, 0x02},
+	{0x2078, 0x80},
+	{0x2079, 0x00},
+	{0x207A, 0xC1},
+	{0x207B, 0x00},
+	{0x207C, 0xFF},
+	{0x207D, 0x03},
+	{0x207E, 0xFF},
+	{0x207F, 0x03},
+	{0x2080, 0x78},
+	{0x2081, 0x00},
+	{0x2082, 0x6A},
+	{0x2083, 0x01},
+	{0x2084, 0xE4},
+	{0x2085, 0x01},
+	{0x2086, 0x2B},
+	{0x2087, 0x03},
+	{0x2088, 0x00},
+	{0x2089, 0x00},
+	{0x208A, 0xFF},
+	{0x208B, 0x03},
+	{0x208C, 0xFF},
+	{0x208D, 0x03},
+	{0x208E, 0xFF},
+	{0x208F, 0x03},
+	{0x2090, 0x7D},
+	{0x2091, 0x00},
+	{0x2092, 0x62},
+	{0x2093, 0x01},
+	{0x2094, 0xE9},
+	{0x2095, 0x01},
+	{0x2096, 0x00},
+	{0x2097, 0x00},
+	{0x2098, 0x7C},
+	{0x2099, 0x00},
+	{0x209A, 0x21},
+	{0x209B, 0x03},
+	{0x209C, 0xE9},
+	{0x209D, 0x01},
+	{0x209E, 0x21},
+	{0x209F, 0x03},
+	{0x20A0, 0xFF},
+	{0x20A1, 0x03},
+	{0x20A2, 0xFF},
+	{0x20A3, 0x03},
+	{0x20A4, 0xFF},
+	{0x20A5, 0x03},
+	{0x20A6, 0xFF},
+	{0x20A7, 0x03},
+	{0x20A8, 0xFF},
+	{0x20A9, 0x03},
+	{0x20AA, 0xFF},
+	{0x20AB, 0x03},
+	{0x20AC, 0xFF},
+	{0x20AD, 0x03},
+	{0x20AE, 0xFF},
+	{0x20AF, 0x03},
+	{0x20B0, 0xFF},
+	{0x20B1, 0x03},
+	{0x20B2, 0xFF},
+	{0x20B3, 0x03},
+	{0x20B4, 0x87},
+	{0x20B5, 0xCC},
+	{0x20B6, 0x87},
+	{0x20B7, 0x08},
+	{0x20B8, 0xF4},
+	{0x20B9, 0xA5},
+	{0x20BA, 0x07},
+	{0x20BC, 0x1F},
+	{0x20BD, 0x01},
+	{0x20BE, 0xF6},
+	{0x20BF, 0x00},
+	{0x20C0, 0x90},
+	{0x20C1, 0x01},
+	{0x20C2, 0x67},
+	{0x20C3, 0x01},
+	{0x20C4, 0xFF},
+	{0x20C5, 0x03},
+	{0x20C6, 0xFF},
+	{0x20C7, 0x03},
+	{0x20C8, 0x33},
+	{0x20C9, 0x02},
+	{0x20CA, 0x0A},
+	{0x20CB, 0x02},
+	{0x20CC, 0x7F},
+	{0x20CD, 0x00},
+	{0x20CE, 0xD2},
+	{0x20CF, 0x00},
+	{0x20D0, 0x81},
+	{0x20D1, 0x00},
+	{0x20D2, 0x87},
+	{0x20D3, 0x00},
+	{0x20D4, 0x09},
+	{0x20D5, 0x00},
+	{0x20D8, 0x7F},
+	{0x20D9, 0x00},
+	{0x20DA, 0x62},
+	{0x20DB, 0x01},
+	{0x20DC, 0x7F},
+	{0x20DD, 0x00},
+	{0x20DE, 0x62},
+	{0x20DF, 0x01},
+	{0x20E0, 0x65},
+	{0x20E1, 0x00},
+	{0x20E2, 0x75},
+	{0x20E3, 0x00},
+	{0x20E4, 0xE0},
+	{0x20E5, 0x00},
+	{0x20E6, 0xF0},
+	{0x20E7, 0x00},
+	{0x20E8, 0x4C},
+	{0x20E9, 0x01},
+	{0x20EA, 0x5C},
+	{0x20EB, 0x01},
+	{0x20EC, 0xD1},
+	{0x20ED, 0x01},
+	{0x20EE, 0xE1},
+	{0x20EF, 0x01},
+	{0x20F0, 0x93},
+	{0x20F1, 0x02},
+	{0x20F2, 0xA3},
+	{0x20F3, 0x02},
+	{0x20F4, 0x0D},
+	{0x20F5, 0x03},
+	{0x20F6, 0x1D},
+	{0x20F7, 0x03},
+	{0x20F8, 0x57},
+	{0x20F9, 0x00},
+	{0x20FA, 0x7B},
+	{0x20FB, 0x00},
+	{0x20FC, 0xD2},
+	{0x20FD, 0x00},
+	{0x20FE, 0xF6},
+	{0x20FF, 0x00},
+	{0x2100, 0x3E},
+	{0x2101, 0x01},
+	{0x2102, 0x60},
+	{0x2103, 0x01},
+	{0x2104, 0xC3},
+	{0x2105, 0x01},
+	{0x2106, 0xE5},
+	{0x2107, 0x01},
+	{0x2108, 0x85},
+	{0x2109, 0x02},
+	{0x210A, 0xA9},
+	{0x210B, 0x02},
+	{0x210C, 0xFF},
+	{0x210D, 0x02},
+	{0x210E, 0x21},
+	{0x210F, 0x03},
+	{0x2110, 0xFF},
+	{0x2111, 0x03},
+	{0x2112, 0x00},
+	{0x2113, 0x00},
+	{0x2114, 0xFF},
+	{0x2115, 0x03},
+	{0x2116, 0xFF},
+	{0x2117, 0x03},
+	{0x2118, 0xFF},
+	{0x2119, 0x03},
+	{0x211A, 0xFF},
+	{0x211B, 0x03},
+	{0x211C, 0xFF},
+	{0x211D, 0x03},
+	{0x211E, 0xFF},
+	{0x211F, 0x03},
+	{0x2120, 0xFF},
+	{0x2121, 0x03},
+	{0x2122, 0xFF},
+	{0x2123, 0x03},
+	{0x2124, 0xFF},
+	{0x2125, 0x03},
+	{0x2126, 0xFF},
+	{0x2127, 0x03},
+	{0x2128, 0x7D},
+	{0x2129, 0x90},
+	{0x212A, 0xD5},
+	{0x212B, 0x07},
+	{0x212C, 0x64},
+	{0x212D, 0x01},
+	{0x2130, 0x5F},
+	{0x2131, 0x7D},
+	{0x2132, 0x05},
+	{0x2134, 0x78},
+	{0x2135, 0x00},
+	{0x2136, 0x76},
+	{0x2137, 0x00},
+	{0x2138, 0xF3},
+	{0x2139, 0x00},
+	{0x213A, 0xF1},
+	{0x213B, 0x00},
+	{0x213C, 0xA6},
+	{0x213D, 0x02},
+	{0x213E, 0xA4},
+	{0x213F, 0x02},
+	{0x2140, 0x7D},
+	{0x2141, 0x00},
+	{0x2142, 0x8D},
+	{0x2143, 0x00},
+	{0x2144, 0xA1},
+	{0x2145, 0x01},
+	{0x2146, 0xB1},
+	{0x2147, 0x01},
+	{0x2148, 0xAB},
+	{0x2149, 0x02},
+	{0x214A, 0xBB},
+	{0x214B, 0x02},
+	{0x214C, 0x17},
+	{0x214D, 0x5C},
+	{0x214E, 0x00},
+	{0x2150, 0x00},
+	{0x2151, 0x00},
+	{0x2152, 0xF8},
+	{0x2153, 0x00},
+	{0x2154, 0xBE},
+	{0x2155, 0x00},
+	{0x2156, 0x7D},
+	{0x2157, 0x00},
+	{0x2158, 0x25},
+	{0x2159, 0x00},
+	{0x215A, 0x7D},
+	{0x215B, 0x00},
+	{0x215C, 0x62},
+	{0x215D, 0x01},
+	{0x215E, 0xFF},
+	{0x215F, 0x03},
+	{0x2160, 0x26},
+	{0x2161, 0x00},
+	{0x2162, 0x7D},
+	{0x2163, 0x00},
+	{0x2164, 0x63},
+	{0x2165, 0x01},
+	{0x2166, 0xFF},
+	{0x2167, 0x03},
+	{0x2168, 0xCB},
+	{0x2169, 0x02},
+	{0x216A, 0xCF},
+	{0x216B, 0x02},
+	{0x216C, 0xFF},
+	{0x216D, 0x03},
+	{0x216E, 0xFF},
+	{0x216F, 0x03},
+	{0x2170, 0xFF},
+	{0x2171, 0x03},
+	{0x2172, 0xFF},
+	{0x2173, 0x03},
+	{0x2174, 0xFF},
+	{0x2175, 0x03},
+	{0x2176, 0xFF},
+	{0x2177, 0x03},
+	{0x2178, 0x7E},
+	{0x2179, 0x00},
+	{0x217A, 0xBD},
+	{0x217B, 0x00},
+	{0x217C, 0xEC},
+	{0x217D, 0x01},
+	{0x217E, 0x7B},
+	{0x217F, 0x02},
+	{0x2180, 0xD1},
+	{0x2181, 0x02},
+	{0x2182, 0x25},
+	{0x2183, 0x03},
+	{0x2184, 0x7F},
+	{0x2185, 0x00},
+	{0x2186, 0xBD},
+	{0x2187, 0x00},
+	{0x2188, 0xED},
+	{0x2189, 0x01},
+	{0x218A, 0x7B},
+	{0x218B, 0x02},
+	{0x218C, 0xD2},
+	{0x218D, 0x02},
+	{0x218E, 0x25},
+	{0x218F, 0x03},
+	{0x2190, 0xFF},
+	{0x2191, 0x03},
+	{0x2192, 0xFF},
+	{0x2193, 0x03},
+	{0x2194, 0xE9},
+	{0x2195, 0x01},
+	{0x2196, 0x21},
+	{0x2197, 0x03},
+	{0x2198, 0x17},
+	{0x2199, 0xFC},
+	{0x219A, 0x7F},
+	{0x219B, 0x01},
+	{0x219C, 0xFF},
+	{0x219D, 0x03},
+	{0x21A0, 0x1B},
+	{0x21A1, 0x1B},
+	{0x21A2, 0x1B},
+	{0x21A3, 0x1B},
+	{0x21A4, 0x2E},
+	{0x21A5, 0x80},
+	{0x21A6, 0x00},
+	{0x21A8, 0x04},
+	{0x21A9, 0x98},
+	{0x21AA, 0x60},
+	{0x21AB, 0x03},
+	{0x21AC, 0x7F},
+	{0x21AD, 0x80},
+	{0x21AE, 0x09},
+	{0x21B0, 0x1C},
+	{0x21B1, 0x00},
+	{0x21B2, 0xA0},
+	{0x21B3, 0x00},
+	{0x21B4, 0x0C},
+	{0x21B5, 0x00},
+	{0x21B6, 0x2D},
+	{0x21B7, 0x00},
+	{0x21B8, 0x20},
+	{0x21B9, 0x00},
+	{0x21BA, 0x02},
+	{0x21BB, 0x00},
+	{0x21BC, 0xCC},
+	{0x21BD, 0x00},
+	{0x21BE, 0x4A},
+	{0x21BF, 0x00},
+	{0x21C0, 0xD0},
+	{0x21C1, 0x00},
+	{0x21C2, 0x44},
+	{0x21C3, 0x00},
+	{0x21C4, 0x00},
+	{0x21C5, 0xE0},
+	{0x21C6, 0x00},
+	{0x21C8, 0x11},
+	{0x21C9, 0x00},
+	{0x21CA, 0x02},
+	{0x21CC, 0x08},
+	{0x21CD, 0xC0},
+	{0x21CE, 0x0C},
+	{0x21D0, 0x44},
+	{0x21D1, 0x00},
+	{0x21D2, 0x02},
+	{0x21D4, 0x02},
+	{0x21D5, 0x20},
+	{0x21D6, 0x2C},
+	{0x21D8, 0xFE},
+	{0x21D9, 0x9D},
+	{0x21DA, 0xDF},
+	{0x21DB, 0x03},
+	{0x21DC, 0x62},
+	{0x21DD, 0x01},
+	{0x21DE, 0x7F},
+	{0x21DF, 0x00},
+	{0x21E0, 0xB7},
+	{0x21E1, 0x01},
+	{0x21E2, 0xB5},
+	{0x21E3, 0x01},
+	{0x21E4, 0xC1},
+	{0x21E5, 0x02},
+	{0x21E6, 0xBF},
+	{0x21E7, 0x02},
+	{0x21E8, 0xB3},
+	{0x21E9, 0x0D},
+	{0x21EA, 0x00},
+	{0x21EB, 0x04},
+	{0x21EC, 0x90},
+	{0x21ED, 0x07},
+	{0x21EE, 0x58},
+	{0x21EF, 0x04},
+	{0x21F0, 0x54},
+	{0x21F1, 0x04},
+	{0x21F4, 0x02},
+	{0x21F5, 0x00},
+	{0x21F6, 0x00},
+	{0x21F8, 0x3C},
+	{0x21F9, 0x00},
+	{0x21FC, 0x28},
+	{0x21FD, 0x00},
+	{0x21FE, 0x3C},
+	{0x21FF, 0x00},
+	{0x2200, 0x00},
+	{0x2204, 0x4C},
+	{0x2205, 0x04},
+	{0x2206, 0x65},
+	{0x2207, 0x04},
+	{0x2208, 0x0A},
+	{0x2209, 0x00},
+	{0x220C, 0x47},
+	{0x220D, 0x00},
+	{0x220E, 0x1F},
+	{0x220F, 0x00},
+	{0x2210, 0x17},
+	{0x2211, 0x00},
+	{0x2212, 0x0F},
+	{0x2213, 0x00},
+	{0x2214, 0x17},
+	{0x2215, 0x00},
+	{0x2216, 0x47},
+	{0x2217, 0x00},
+	{0x2218, 0x0F},
+	{0x2219, 0x00},
+	{0x221A, 0x0F},
+	{0x221B, 0x00},
+	{0x221C, 0x03},
+	{0x2220, 0x20},
+	{0x2221, 0x20},
+	{0x2222, 0x22},
+	{0x2223, 0x02},
+	{0x2224, 0xA7},
+	{0x2225, 0xAA},
+	{0x2226, 0x80},
+	{0x2227, 0x08},
+	{0x2228, 0x01},
+	{0x22B2, 0x92},
+	{0x22B4, 0x20},
+	{0x22B5, 0x00},
+	{0x22B6, 0x20},
+	{0x22B7, 0x00},
+	{0x22B8, 0x20},
+	{0x22B9, 0x00},
+	{0x22BA, 0x20},
+	{0x22BB, 0x00},
+	{0x22BC, 0x20},
+	{0x22BD, 0x00},
+	{0x22BE, 0x20},
+	{0x22BF, 0x00},
+	{0x22C0, 0x20},
+	{0x22C1, 0x00},
+	{0x22C2, 0x20},
+	{0x22C3, 0x00},
+	{0x22C4, 0x20},
+	{0x22C5, 0x00},
+	{0x22C6, 0x20},
+	{0x22C7, 0x00},
+	{0x22C8, 0x20},
+	{0x22C9, 0x00},
+	{0x22CA, 0x20},
+	{0x22CB, 0x00},
+	{0x22CC, 0x20},
+	{0x22CD, 0x00},
+	{0x22CE, 0x20},
+	{0x22CF, 0x00},
+	{0x22DA, 0x00},
+	{0x2308, 0x01},
+	{0x2311, 0x09},
+	{0x2318, 0x40},
+	{0x2319, 0xCD},
+	{0x231A, 0x54},
+	{0x2324, 0x10},
+	{0x2325, 0x00},
+	{0x2328, 0x00},
+	{0x2354, 0x0C},
+	{0x23C0, 0x5D},
+	{0x244C, 0x00},
+	{0x244D, 0x02},
+	{0x244E, 0x54},
+	{0x244F, 0x02},
+	{0x24A0, 0x00},
+	{0x24DA, 0x6F},
+	{0x24DB, 0x00},
+	{0x24DC, 0x62},
+	{0x24DD, 0x01},
+	{0x24EA, 0x32},
+	{0x24EB, 0x00},
+	{0x24EC, 0xDC},
+	{0x24ED, 0x00},
+	{0x24FA, 0x32},
+	{0x24FB, 0x00},
+	{0x24FC, 0xDD},
+	{0x24FD, 0x00},
+	{0x254A, 0x15},
+	{0x254B, 0x01},
+	{0x255A, 0x15},
+	{0x255B, 0x01},
+	{0x2560, 0x01},
+	{0x2561, 0x00},
+	{0x2562, 0x2A},
+	{0x2563, 0x00},
+	{0x2564, 0xF8},
+	{0x2565, 0x00},
+	{0x2566, 0x15},
+	{0x2567, 0x01},
+	{0x2568, 0x0C},
+	{0x2569, 0x02},
+	{0x256A, 0x31},
+	{0x256B, 0x02},
+	{0x2578, 0x90},
+	{0x2579, 0x01},
+	{0x257A, 0x92},
+	{0x257B, 0x01},
+	{0x257C, 0xB8},
+	{0x257D, 0x02},
+	{0x257E, 0xBA},
+	{0x257F, 0x02},
+	{0x2584, 0x90},
+	{0x2585, 0x01},
+	{0x2586, 0x92},
+	{0x2587, 0x01},
+	{0x2588, 0xB8},
+	{0x2589, 0x02},
+	{0x258A, 0xBA},
+	{0x258B, 0x02},
+	{0x26B8, 0x10},
+	{0x26B9, 0x00},
+	{0x26BA, 0x33},
+	{0x26BB, 0x00},
+	{0x26BC, 0x89},
+	{0x26BD, 0x00},
+	{0x26BE, 0xB0},
+	{0x26BF, 0x00},
+	{0x26C4, 0x4E},
+	{0x26C5, 0x00},
+	{0x26C8, 0xC9},
+	{0x26C9, 0x00},
+	{0x26CC, 0x35},
+	{0x26CD, 0x01},
+	{0x26D0, 0xBA},
+	{0x26D1, 0x01},
+	{0x26D4, 0x7C},
+	{0x26D5, 0x02},
+	{0x26D8, 0xF6},
+	{0x26D9, 0x02},
+	{0x26DE, 0x51},
+	{0x26DF, 0x00},
+	{0x26E0, 0x7F},
+	{0x26E1, 0x00},
+	{0x26E2, 0xCC},
+	{0x26E3, 0x00},
+	{0x26E4, 0xF8},
+	{0x26E5, 0x00},
+	{0x26E6, 0x38},
+	{0x26E7, 0x01},
+	{0x26E8, 0x65},
+	{0x26E9, 0x01},
+	{0x26EA, 0xBD},
+	{0x26EB, 0x01},
+	{0x26EE, 0x7F},
+	{0x26EF, 0x02},
+	{0x26F0, 0xAB},
+	{0x26F1, 0x02},
+	{0x26F2, 0xF9},
+	{0x26F3, 0x02},
+	{0x2722, 0x59},
+	{0x2723, 0x02},
+	{0x2938, 0x55},
+	{0x2939, 0x00},
+	{0x293A, 0x17},
+	{0x293B, 0x00},
+	{0x293C, 0xD0},
+	{0x293D, 0x00},
+	{0x293E, 0x91},
+	{0x293F, 0x00},
+	{0x2940, 0x3C},
+	{0x2941, 0x01},
+	{0x2942, 0x0C},
+	{0x2943, 0x01},
+	{0x2944, 0xC1},
+	{0x2945, 0x01},
+	{0x2946, 0x76},
+	{0x2947, 0x01},
+	{0x2948, 0x83},
+	{0x2949, 0x02},
+	{0x294A, 0xFB},
+	{0x294B, 0x01},
+	{0x294C, 0xFD},
+	{0x294D, 0x02},
+	{0x294E, 0xBF},
+	{0x294F, 0x02},
+	{0x2A06, 0xFF},
+	{0x2A07, 0x03},
+	{0x2A20, 0x00},
+	{0x2A21, 0x00},
+	{0x2A22, 0x7D},
+	{0x2A23, 0x00},
+	{0x2B11, 0x19},
+	{0x2B13, 0x15},
+	{0x2B14, 0x14},
+	{0x2B15, 0x13},
+	{0x2B16, 0x12},
+	{0x2B17, 0x11},
+	{0x2B18, 0x10},
+	{0x2B19, 0x0F},
+	{0x2B1A, 0x0E},
+	{0x2B1B, 0x0D},
+	{0x2B1C, 0x0C},
+	{0x2B1D, 0x0B},
+	{0x2B1E, 0x0A},
+	{0x2B1F, 0x09},
+	{0x2B20, 0x08},
+	{0x2B21, 0x07},
+	{0x2B22, 0x06},
+	{0x2B23, 0x05},
+	{0x2B24, 0x04},
+	{0x2B25, 0x03},
+	{0x2B26, 0x03},
+	{0x2B38, 0x01},
+	{0x2B45, 0xE3},
+	{0x2B50, 0x01},
+	{0x2B51, 0x00},
+	{0x2B6D, 0x47},
+	{0x2B70, 0x02},
+	{0x2B71, 0x02},
+	{0x2B72, 0x02},
+	{0x2B7F, 0x7F},
+	{0x2B80, 0x94},
+	{0x2B81, 0x06},
+	{0x2B87, 0x1B},
+	{0x2B88, 0x1B},
+	{0x2B89, 0x17},
+	{0x2B8A, 0x12},
+	{0x2B8B, 0x12},
+	{0x2B8D, 0x2B},
+	{0x2B8E, 0x2B},
+	{0x2B8F, 0x2B},
+	{0x2B90, 0x7F},
+	{0x2B91, 0x1F},
+	{0x2B94, 0x7F},
+	{0x2B95, 0x27},
+	{0x2B98, 0x7F},
+	{0x2B99, 0x57},
+	{0x2BA8, 0xBC},
+	{0x2BA9, 0x62},
+	{0x2BC1, 0x70},
+	{0x2BC5, 0x80},
+	{0x2BD5, 0x30},
+	{0x2BD6, 0xF0},
+	{0x2BD8, 0xDB},
+	{0x2BD9, 0xF6},
+	{0x2BDA, 0x63},
+	{0x2BDB, 0x0C},
+	{0x2BDC, 0x5C},
+	{0x2C98, 0xE1},
+	{0x2C99, 0x2E},
+	{0x2C9B, 0x86},
+	{0x2CA9, 0x80},
+	{0x2CAA, 0x01},
+	{0x2D39, 0x0E},
+	{0x2D54, 0x00},
+	{0x2D5B, 0x58},
+	{0x3000, 0x00},
+	{0x3001, 0x00},
+	{0x3002, 0x23},
+	{0x3003, 0xA1},
+	{0x3004, 0x00},
+	{0x3005, 0x20},
+	{0x3006, 0x84},
+	{0x3007, 0x00},
+	{0x3008, 0x06},
+	{0x3009, 0xB4},
+	{0x300A, 0x1F},
+	{0x300B, 0x00},
+	{0x300C, 0x00},
+	{0x300D, 0x1B},
+	{0x300E, 0x90},
+	{0x300F, 0x97},
+	{0x3010, 0x00},
+	{0x3011, 0x00},
+	{0x3012, 0x21},
+	{0x3013, 0x21},
+	{0x3014, 0x00},
+	{0x3015, 0x20},
+	{0x3016, 0x84},
+	{0x3017, 0x00},
+	{0x3018, 0x30},
+	{0x3019, 0x09},
+	{0x301A, 0x46},
+	{0x301B, 0x00},
+	{0x3070, 0xC1},
+	{0x3071, 0x81},
+	{0x3072, 0x29},
+	{0x3073, 0x81},
+	{0x3410, 0x90},
+	{0x3411, 0x07},
+	{0x3418, 0x48},
+	{0x3419, 0x04},
+	{0x34C0, 0xD3},
+	{0x34C1, 0x00},
+	{0x34C2, 0xD3},
+	{0x34C3, 0x00},
+	{0x34C4, 0xD3},
+	{0x34C5, 0x00},
+	{0x34C6, 0xD3},
+	{0x34C7, 0x00},
+	{0x34C8, 0xE2},
+	{0x34C9, 0x21},
+	{0x34CA, 0xE0},
+	{0x34CB, 0x1F},
+	{0x34CC, 0x06},
+	{0x34CD, 0x20},
+	{0x34CE, 0x28},
+	{0x34CF, 0x1F},
+	{0x3584, 0x00},
+	{0x3586, 0x00},
+	{0x3587, 0x01},
+	{0x3588, 0xE6},
+	{0x3589, 0x00},
+	{0x3590, 0x00},
+	{0x3591, 0x00},
+	{0x3594, 0x40},
+	{0x3598, 0x03},
+	{0x3599, 0x00},
+	{0x359A, 0x80},
+	{0x359B, 0x00},
+	{0x359C, 0x00},
+	{0x359D, 0x01},
+	{0x359E, 0x00},
+	{0x359F, 0x02},
+	{0x35A0, 0x00},
+	{0x35A1, 0x04},
+	{0x35A2, 0x20},
+	{0x35A3, 0x00},
+	{0x35A4, 0x40},
+	{0x35A5, 0x00},
+	{0x35A6, 0x80},
+	{0x35A7, 0x00},
+	{0x35A8, 0x00},
+	{0x35A9, 0x01},
+	{0x35AA, 0x3A},
+	{0x35AB, 0x00},
+	{0x35AC, 0x80},
+	{0x35AD, 0x00},
+	{0x35AE, 0x00},
+	{0x35AF, 0x01},
+	{0x35B0, 0x00},
+	{0x35B1, 0x02},
+	{0x35B2, 0x00},
+	{0x35B3, 0x04},
+	{0x35B4, 0x02},
+	{0x35B5, 0x00},
+	{0x35B6, 0x04},
+	{0x35B7, 0x00},
+	{0x35B8, 0x08},
+	{0x35B9, 0x00},
+	{0x35BA, 0x10},
+	{0x35BB, 0x00},
+	{0x35BC, 0x03},
+	{0x35BD, 0x00},
+	{0x35C8, 0x00},
+	{0x35C9, 0x01},
+	{0x35CA, 0x00},
+	{0x35CB, 0x04},
+	{0x35CC, 0x00},
+	{0x35CD, 0x10},
+	{0x35CE, 0x00},
+	{0x35CF, 0x40},
+	{0x35D0, 0x00},
+	{0x35D1, 0x0C},
+	{0x35D2, 0x00},
+	{0x35D3, 0x0C},
+	{0x35D4, 0x00},
+	{0x35D5, 0x0C},
+	{0x35D6, 0x00},
+	{0x35D7, 0x0C},
+	{0x35D8, 0x00},
+	{0x35D9, 0x00},
+	{0x35DA, 0x08},
+	{0x35DB, 0x00},
+	{0x35DC, 0xD8},
+	{0x35DD, 0x0E},
+	{0x35F0, 0x00},
+	{0x35F1, 0x10},
+	{0x35F2, 0x00},
+	{0x35F3, 0x10},
+	{0x35F4, 0x00},
+	{0x35F5, 0x10},
+	{0x35F6, 0x00},
+	{0x35F7, 0x03},
+	{0x35F8, 0x00},
+	{0x35F9, 0x01},
+	{0x35FA, 0x38},
+	{0x35FB, 0x00},
+	{0x35FC, 0xB3},
+	{0x35FD, 0x01},
+	{0x35FE, 0x00},
+	{0x35FF, 0x00},
+	{0x3600, 0x04},
+	{0x3601, 0x06},
+	{0x3604, 0x03},
+	{0x3605, 0x00},
+	{0x3608, 0x03},
+	{0x3609, 0x00},
+	{0x360C, 0x00},
+	{0x360D, 0x00},
+	{0x3610, 0x10},
+	{0x3611, 0x01},
+	{0x3612, 0x00},
+	{0x3613, 0x00},
+	{0x3614, 0x00},
+	{0x3615, 0x00},
+	{0x361C, 0x00},
+	{0x361D, 0x01},
+	{0x361E, 0x00},
+	{0x361F, 0x01},
+	{0x3620, 0x01},
+	{0x3621, 0x00},
+	{0x3622, 0xB0},
+	{0x3623, 0x04},
+	{0x3624, 0xDC},
+	{0x3625, 0x05},
+	{0x3626, 0x00},
+	{0x3627, 0x01},
+	{0x3628, 0xFF},
+	{0x3629, 0x0F},
+	{0x362A, 0x00},
+	{0x362B, 0x10},
+	{0x362C, 0x00},
+	{0x362D, 0x01},
+	{0x3630, 0x40},
+	{0x3631, 0x00},
+	{0x3632, 0x40},
+	{0x3633, 0x00},
+	{0x3634, 0x40},
+	{0x3635, 0x00},
+	{0x3636, 0x40},
+	{0x3637, 0x00},
+	{0x3638, 0x40},
+	{0x3639, 0x00},
+	{0x363A, 0x40},
+	{0x363B, 0x00},
+	{0x363C, 0x40},
+	{0x363D, 0x00},
+	{0x363E, 0x40},
+	{0x363F, 0x00},
+	{0x36C4, 0x99},
+	{0x36C5, 0x09},
+	{0x36C6, 0x18},
+	{0x36C7, 0x07},
+	{0x36C8, 0x65},
+	{0x36C9, 0x0E},
+	{0x36CC, 0x99},
+	{0x36CD, 0x01},
+	{0x36CE, 0x47},
+	{0x36CF, 0x00},
+	{0x36D0, 0x04},
+	{0x36D1, 0x00},
+	{0x36D4, 0x65},
+	{0x36D5, 0x0E},
+	{0x36D6, 0xA4},
+	{0x36D7, 0x0A},
+	{0x36D8, 0x65},
+	{0x36D9, 0x0E},
+	{0x36DC, 0x65},
+	{0x36DD, 0x0E},
+	{0x36DE, 0xA4},
+	{0x36DF, 0x0A},
+	{0x36E0, 0x65},
+	{0x36E1, 0x0E},
+	{0x36E4, 0x65},
+	{0x36E5, 0x0E},
+	{0x36E6, 0xA4},
+	{0x36E7, 0x0A},
+	{0x36E8, 0x65},
+	{0x36E9, 0x0E},
+	{0x36EE, 0x00},
+	{0x36EF, 0x00},
+	{0x36F0, 0x00},
+	{0x36F1, 0x80},
+	{0x36F8, 0x00},
+	{0x3702, 0x03},
+	{0x3703, 0x04},
+	{0x3704, 0x08},
+	{0x370E, 0x0E},
+	{0x3718, 0x62},
+	{0x3719, 0x4A},
+	{0x371A, 0x38},
+	{0x371B, 0x20},
+	{0x371C, 0x64},
+	{0x371D, 0x42},
+	{0x371E, 0x32},
+	{0x371F, 0x1B},
+	{0x3720, 0x9C},
+	{0x3721, 0xA4},
+	{0x3722, 0xAC},
+	{0x3723, 0xB4},
+	{0x3748, 0xAA},
+	{0x3749, 0x96},
+	{0x374A, 0x7D},
+	{0x374B, 0x69},
+	{0x37C0, 0x00},
+	{0x37C1, 0x00},
+	{0x37C2, 0x00},
+	{0x37C4, 0x00},
+	{0x37C5, 0x00},
+	{0x37C6, 0x00},
+	{0x37C8, 0x00},
+	{0x37C9, 0x00},
+	{0x37CA, 0x00},
+	{0x37CC, 0x00},
+	{0x37CD, 0x00},
+	{0x37CE, 0x00},
+	{0x37D0, 0x00},
+	{0x37D1, 0x00},
+	{0x37D2, 0x00},
+	{0x37D4, 0x00},
+	{0x37D5, 0x00},
+	{0x37D6, 0x00},
+	{0x37D8, 0x00},
+	{0x37D9, 0x00},
+	{0x37DA, 0x00},
+	{0x37DC, 0x00},
+	{0x37DD, 0x00},
+	{0x37DE, 0x00},
+	{0x37E0, 0x00},
+	{0x37E1, 0x00},
+	{0x37E2, 0x00},
+	{0x37E4, 0x00},
+	{0x37E5, 0x00},
+	{0x37E6, 0x00},
+	{0x37E8, 0x00},
+	{0x37E9, 0x00},
+	{0x37EA, 0x00},
+	{0x37EC, 0x00},
+	{0x37ED, 0x00},
+	{0x37EE, 0x00},
+	{0x37F0, 0x00},
+	{0x37F4, 0x00},
+	{0x37F5, 0x1E},
+	{0x37F6, 0x34},
+	{0x37F7, 0x00},
+	{0x37F8, 0xFF},
+	{0x37F9, 0xFF},
+	{0x37FA, 0x03},
+	{0x37FC, 0x00},
+	{0x37FD, 0x00},
+	{0x37FE, 0x04},
+	{0x3800, 0xFF},
+	{0x3801, 0xFF},
+	{0x3802, 0x03},
+	{0x3804, 0x00},
+	{0x3805, 0x00},
+	{0x3806, 0x04},
+	{0x3808, 0x00},
+	{0x3809, 0x00},
+	{0x380A, 0x00},
+	{0x380C, 0x00},
+	{0x380D, 0x00},
+	{0x380E, 0x00},
+	{0x3810, 0x00},
+	{0x3811, 0x00},
+	{0x3812, 0x00},
+	{0x3814, 0x00},
+	{0x3815, 0x00},
+	{0x3816, 0x00},
+	{0x3818, 0x00},
+	{0x3819, 0x00},
+	{0x381A, 0x00},
+	{0x381C, 0x00},
+	{0x381D, 0x00},
+	{0x381E, 0x00},
+	{0x3820, 0x00},
+	{0x3821, 0x00},
+	{0x3822, 0x00},
+	{0x3824, 0x00},
+	{0x3825, 0x00},
+	{0x3826, 0x00},
+	{0x3828, 0x00},
+	{0x3829, 0x00},
+	{0x382A, 0x00},
+	{0x382C, 0x00},
+	{0x382D, 0x00},
+	{0x382E, 0x00},
+	{0x3830, 0x00},
+	{0x3831, 0x00},
+	{0x3832, 0x00},
+	{0x3834, 0x00},
+	{0x3835, 0x00},
+	{0x3836, 0x00},
+	{0x3838, 0x00},
+	{0x3839, 0x00},
+	{0x383A, 0x00},
+	{0x383B, 0x00},
+	{0x383C, 0x00},
+	{0x383D, 0x00},
+	{0x383E, 0x00},
+	{0x383F, 0x00},
+	{0x3840, 0x00},
+	{0x3841, 0x00},
+	{0x3842, 0x00},
+	{0x3843, 0x00},
+	{0x3844, 0x00},
+	{0x3845, 0x00},
+	{0x3846, 0x00},
+	{0x3847, 0x00},
+	{0x3848, 0x00},
+	{0x3849, 0x00},
+	{0x384A, 0x00},
+	{0x384B, 0x00},
+	{0x384C, 0x00},
+	{0x384D, 0x00},
+	{0x384E, 0x00},
+	{0x384F, 0x00},
+	{0x3850, 0xFF},
+	{0x3851, 0x0F},
+	{0x3852, 0x00},
+	{0x3853, 0x10},
+	{0x3854, 0xFF},
+	{0x3855, 0x0F},
+	{0x3856, 0x00},
+	{0x3857, 0x10},
+	{0x3858, 0xFF},
+	{0x3859, 0x0F},
+	{0x385A, 0x00},
+	{0x385B, 0x10},
+	{0x385C, 0x02},
+	{0x385D, 0x00},
+	{0x385E, 0x06},
+	{0x385F, 0x00},
+	{0x3860, 0x06},
+	{0x3861, 0x00},
+	{0x3862, 0x08},
+	{0x3863, 0x00},
+	{0x3864, 0x02},
+	{0x3865, 0x00},
+	{0x38A0, 0x01},
+	{0x38A1, 0x01},
+	{0x38A2, 0x00},
+	{0x38A3, 0x01},
+	{0x38A4, 0x07},
+	{0x38A5, 0x00},
+	{0x38A6, 0x04},
+	{0x38A7, 0x05},
+	{0x38A8, 0x00},
+	{0x38A9, 0x00},
+	{0x38AC, 0x00},
+	{0x38AD, 0x00},
+	{0x38AE, 0x01},
+	{0x38B0, 0x02},
+	{0x38B2, 0x22},
+	{0x38B3, 0x00},
+	{0x38B4, 0x17},
+	{0x38B5, 0x00},
+	{0x38B6, 0x11},
+	{0x38B7, 0x00},
+	{0x38B8, 0x0E},
+	{0x38B9, 0x00},
+	{0x38BA, 0x2A},
+	{0x38BB, 0x00},
+	{0x38BC, 0x1C},
+	{0x38BD, 0x00},
+	{0x38BE, 0x14},
+	{0x38BF, 0x00},
+	{0x38C0, 0x10},
+	{0x38C1, 0x00},
+	{0x38C2, 0x31},
+	{0x38C3, 0x00},
+	{0x38C4, 0x21},
+	{0x38C5, 0x00},
+	{0x38C6, 0x18},
+	{0x38C7, 0x00},
+	{0x38C8, 0x12},
+	{0x38C9, 0x00},
+	{0x38CA, 0x3C},
+	{0x38CB, 0x00},
+	{0x38CC, 0x29},
+	{0x38CD, 0x00},
+	{0x38CE, 0x1D},
+	{0x38CF, 0x00},
+	{0x38D0, 0x15},
+	{0x38D1, 0x00},
+	{0x38D2, 0x4E},
+	{0x38D3, 0x00},
+	{0x38D4, 0x35},
+	{0x38D5, 0x00},
+	{0x38D6, 0x26},
+	{0x38D7, 0x00},
+	{0x38D8, 0x1A},
+	{0x38D9, 0x00},
+	{0x38DA, 0x69},
+	{0x38DB, 0x00},
+	{0x38DC, 0x48},
+	{0x38DD, 0x00},
+	{0x38DE, 0x33},
+	{0x38DF, 0x00},
+	{0x38E0, 0x22},
+	{0x38E1, 0x00},
+	{0x38E2, 0x93},
+	{0x38E3, 0x00},
+	{0x38E4, 0x64},
+	{0x38E5, 0x00},
+	{0x38E6, 0x48},
+	{0x38E7, 0x00},
+	{0x38E8, 0x30},
+	{0x38E9, 0x00},
+	{0x38EA, 0xD3},
+	{0x38EB, 0x00},
+	{0x38EC, 0x90},
+	{0x38ED, 0x00},
+	{0x38EE, 0x69},
+	{0x38EF, 0x00},
+	{0x38F0, 0x49},
+	{0x38F1, 0x00},
+	{0x38F2, 0x39},
+	{0x38F3, 0x01},
+	{0x38F4, 0xD5},
+	{0x38F5, 0x00},
+	{0x38F6, 0x9F},
+	{0x38F7, 0x00},
+	{0x38F8, 0x75},
+	{0x38F9, 0x00},
+	{0x38FA, 0x00},
+	{0x38FB, 0x01},
+	{0x38FC, 0x00},
+	{0x38FD, 0x01},
+	{0x38FE, 0x00},
+	{0x38FF, 0x01},
+	{0x3900, 0x00},
+	{0x3901, 0x01},
+	{0x3902, 0x70},
+	{0x3903, 0x00},
+	{0x3904, 0x30},
+	{0x3905, 0x00},
+	{0x3906, 0x25},
+	{0x3907, 0x00},
+	{0x3908, 0x20},
+	{0x3909, 0x00},
+	{0x390A, 0xB2},
+	{0x390B, 0x00},
+	{0x390C, 0x80},
+	{0x390D, 0x00},
+	{0x390E, 0x70},
+	{0x390F, 0x00},
+	{0x3910, 0x50},
+	{0x3911, 0x00},
+	{0x3912, 0xB2},
+	{0x3913, 0x00},
+	{0x3914, 0x80},
+	{0x3915, 0x00},
+	{0x3916, 0x70},
+	{0x3917, 0x00},
+	{0x3918, 0x50},
+	{0x3919, 0x00},
+	{0x391A, 0xB2},
+	{0x391B, 0x00},
+	{0x391C, 0x80},
+	{0x391D, 0x00},
+	{0x391E, 0x70},
+	{0x391F, 0x00},
+	{0x3920, 0x50},
+	{0x3921, 0x00},
+	{0x3922, 0x40},
+	{0x3923, 0x00},
+	{0x3924, 0x40},
+	{0x3925, 0x00},
+	{0x3926, 0x40},
+	{0x3927, 0x00},
+	{0x3928, 0x40},
+	{0x3929, 0x00},
+	{0x392A, 0x80},
+	{0x392B, 0x00},
+	{0x392C, 0x80},
+	{0x392D, 0x00},
+	{0x392E, 0x80},
+	{0x392F, 0x00},
+	{0x3930, 0x80},
+	{0x3931, 0x00},
+	{0x3932, 0x80},
+	{0x3933, 0x80},
+	{0x3934, 0x80},
+	{0x3940, 0x01},
+	{0x3941, 0x01},
+	{0x3942, 0x00},
+	{0x3943, 0x01},
+	{0x3944, 0x07},
+	{0x3945, 0x00},
+	{0x3946, 0x04},
+	{0x3947, 0x05},
+	{0x3948, 0x00},
+	{0x3949, 0x00},
+	{0x394C, 0x00},
+	{0x394D, 0x00},
+	{0x394E, 0x01},
+	{0x3950, 0x03},
+	{0x3952, 0x14},
+	{0x3953, 0x00},
+	{0x3954, 0x0F},
+	{0x3955, 0x00},
+	{0x3956, 0x0E},
+	{0x3957, 0x00},
+	{0x3958, 0x0E},
+	{0x3959, 0x00},
+	{0x395A, 0x19},
+	{0x395B, 0x00},
+	{0x395C, 0x11},
+	{0x395D, 0x00},
+	{0x395E, 0x0F},
+	{0x395F, 0x00},
+	{0x3960, 0x0E},
+	{0x3961, 0x00},
+	{0x3962, 0x1C},
+	{0x3963, 0x00},
+	{0x3964, 0x13},
+	{0x3965, 0x00},
+	{0x3966, 0x0F},
+	{0x3967, 0x00},
+	{0x3968, 0x0E},
+	{0x3969, 0x00},
+	{0x396A, 0x23},
+	{0x396B, 0x00},
+	{0x396C, 0x15},
+	{0x396D, 0x00},
+	{0x396E, 0x11},
+	{0x396F, 0x00},
+	{0x3970, 0x0E},
+	{0x3971, 0x00},
+	{0x3972, 0x2E},
+	{0x3973, 0x00},
+	{0x3974, 0x1A},
+	{0x3975, 0x00},
+	{0x3976, 0x14},
+	{0x3977, 0x00},
+	{0x3978, 0x0F},
+	{0x3979, 0x00},
+	{0x397A, 0x3E},
+	{0x397B, 0x00},
+	{0x397C, 0x23},
+	{0x397D, 0x00},
+	{0x397E, 0x1A},
+	{0x397F, 0x00},
+	{0x3980, 0x12},
+	{0x3981, 0x00},
+	{0x3982, 0x56},
+	{0x3983, 0x00},
+	{0x3984, 0x31},
+	{0x3985, 0x00},
+	{0x3986, 0x25},
+	{0x3987, 0x00},
+	{0x3988, 0x1A},
+	{0x3989, 0x00},
+	{0x398A, 0x7B},
+	{0x398B, 0x00},
+	{0x398C, 0x49},
+	{0x398D, 0x00},
+	{0x398E, 0x39},
+	{0x398F, 0x00},
+	{0x3990, 0x2C},
+	{0x3991, 0x00},
+	{0x3992, 0xB4},
+	{0x3993, 0x00},
+	{0x3994, 0x75},
+	{0x3995, 0x00},
+	{0x3996, 0x61},
+	{0x3997, 0x00},
+	{0x3998, 0x53},
+	{0x3999, 0x00},
+	{0x399A, 0x00},
+	{0x399B, 0x01},
+	{0x399C, 0x00},
+	{0x399D, 0x01},
+	{0x399E, 0x00},
+	{0x399F, 0x01},
+	{0x39A0, 0x00},
+	{0x39A1, 0x01},
+	{0x39A2, 0x70},
+	{0x39A3, 0x00},
+	{0x39A4, 0x30},
+	{0x39A5, 0x00},
+	{0x39A6, 0x25},
+	{0x39A7, 0x00},
+	{0x39A8, 0x20},
+	{0x39A9, 0x00},
+	{0x39AA, 0xB2},
+	{0x39AB, 0x00},
+	{0x39AC, 0x80},
+	{0x39AD, 0x00},
+	{0x39AE, 0x70},
+	{0x39AF, 0x00},
+	{0x39B0, 0x80},
+	{0x39B1, 0x00},
+	{0x39B2, 0xB2},
+	{0x39B3, 0x00},
+	{0x39B4, 0x80},
+	{0x39B5, 0x00},
+	{0x39B6, 0x70},
+	{0x39B7, 0x00},
+	{0x39B8, 0x80},
+	{0x39B9, 0x00},
+	{0x39BA, 0xB2},
+	{0x39BB, 0x00},
+	{0x39BC, 0x80},
+	{0x39BD, 0x00},
+	{0x39BE, 0x70},
+	{0x39BF, 0x00},
+	{0x39C0, 0x80},
+	{0x39C1, 0x00},
+	{0x39C2, 0x40},
+	{0x39C3, 0x00},
+	{0x39C4, 0x40},
+	{0x39C5, 0x00},
+	{0x39C6, 0x40},
+	{0x39C7, 0x00},
+	{0x39C8, 0x40},
+	{0x39C9, 0x00},
+	{0x39CA, 0x80},
+	{0x39CB, 0x00},
+	{0x39CC, 0x80},
+	{0x39CD, 0x00},
+	{0x39CE, 0x80},
+	{0x39CF, 0x00},
+	{0x39D0, 0x80},
+	{0x39D1, 0x00},
+	{0x39D2, 0x80},
+	{0x39D3, 0x80},
+	{0x39D4, 0x80},
+	{0x39E0, 0x01},
+	{0x39E1, 0x00},
+	{0x39E4, 0x40},
+	{0x39E5, 0x01},
+	{0x39E6, 0x01},
+	{0x39E8, 0x00},
+	{0x39E9, 0x01},
+	{0x39EA, 0x00},
+	{0x39EB, 0x00},
+	{0x39EC, 0x01},
+	{0x39ED, 0x00},
+	{0x39EE, 0x01},
+	{0x39F0, 0x03},
+	{0x39F1, 0x04},
+	{0x39F2, 0x0E},
+	{0x39F4, 0x1C},
+	{0x39F5, 0x00},
+	{0x39F6, 0x13},
+	{0x39F7, 0x00},
+	{0x39F8, 0x0D},
+	{0x39F9, 0x00},
+	{0x39FA, 0x07},
+	{0x39FB, 0x00},
+	{0x39FC, 0x38},
+	{0x39FD, 0x00},
+	{0x39FE, 0x1C},
+	{0x39FF, 0x00},
+	{0x3A00, 0x11},
+	{0x3A01, 0x00},
+	{0x3A02, 0x08},
+	{0x3A03, 0x00},
+	{0x3A04, 0x4A},
+	{0x3A05, 0x00},
+	{0x3A06, 0x23},
+	{0x3A07, 0x00},
+	{0x3A08, 0x15},
+	{0x3A09, 0x00},
+	{0x3A0A, 0x09},
+	{0x3A0B, 0x00},
+	{0x3A0C, 0x65},
+	{0x3A0D, 0x00},
+	{0x3A0E, 0x2D},
+	{0x3A0F, 0x00},
+	{0x3A10, 0x1A},
+	{0x3A11, 0x00},
+	{0x3A12, 0x0B},
+	{0x3A13, 0x00},
+	{0x3A14, 0x8D},
+	{0x3A15, 0x00},
+	{0x3A16, 0x3D},
+	{0x3A17, 0x00},
+	{0x3A18, 0x23},
+	{0x3A19, 0x00},
+	{0x3A1A, 0x0E},
+	{0x3A1B, 0x00},
+	{0x3A1C, 0xC5},
+	{0x3A1D, 0x00},
+	{0x3A1E, 0x55},
+	{0x3A1F, 0x00},
+	{0x3A20, 0x30},
+	{0x3A21, 0x00},
+	{0x3A22, 0x13},
+	{0x3A23, 0x00},
+	{0x3A24, 0x16},
+	{0x3A25, 0x01},
+	{0x3A26, 0x76},
+	{0x3A27, 0x00},
+	{0x3A28, 0x42},
+	{0x3A29, 0x00},
+	{0x3A2A, 0x1A},
+	{0x3A2B, 0x00},
+	{0x3A2C, 0x88},
+	{0x3A2D, 0x01},
+	{0x3A2E, 0xA7},
+	{0x3A2F, 0x00},
+	{0x3A30, 0x5D},
+	{0x3A31, 0x00},
+	{0x3A32, 0x24},
+	{0x3A33, 0x00},
+	{0x3A34, 0x2A},
+	{0x3A35, 0x02},
+	{0x3A36, 0xEB},
+	{0x3A37, 0x00},
+	{0x3A38, 0x83},
+	{0x3A39, 0x00},
+	{0x3A3A, 0x32},
+	{0x3A3B, 0x00},
+	{0x3A3C, 0x00},
+	{0x3A3D, 0x01},
+	{0x3A3E, 0x00},
+	{0x3A3F, 0x01},
+	{0x3A40, 0x00},
+	{0x3A41, 0x01},
+	{0x3A42, 0x00},
+	{0x3A43, 0x01},
+	{0x3A44, 0x80},
+	{0x3A45, 0x00},
+	{0x3A46, 0x50},
+	{0x3A47, 0x00},
+	{0x3A48, 0x30},
+	{0x3A49, 0x00},
+	{0x3A4A, 0x20},
+	{0x3A4B, 0x00},
+	{0x3A4C, 0x99},
+	{0x3A4D, 0x00},
+	{0x3A4E, 0x80},
+	{0x3A4F, 0x00},
+	{0x3A50, 0x80},
+	{0x3A51, 0x00},
+	{0x3A52, 0x80},
+	{0x3A53, 0x00},
+	{0x3A54, 0x99},
+	{0x3A55, 0x00},
+	{0x3A56, 0x80},
+	{0x3A57, 0x00},
+	{0x3A58, 0x80},
+	{0x3A59, 0x00},
+	{0x3A5A, 0x80},
+	{0x3A5B, 0x00},
+	{0x3A5C, 0x99},
+	{0x3A5D, 0x00},
+	{0x3A5E, 0x80},
+	{0x3A5F, 0x00},
+	{0x3A60, 0x80},
+	{0x3A61, 0x00},
+	{0x3A62, 0x80},
+	{0x3A63, 0x00},
+	{0x3A64, 0x1C},
+	{0x3A65, 0x00},
+	{0x3A66, 0x13},
+	{0x3A67, 0x00},
+	{0x3A68, 0x0D},
+	{0x3A69, 0x00},
+	{0x3A6A, 0x07},
+	{0x3A6B, 0x00},
+	{0x3A6C, 0x0C},
+	{0x3A6D, 0x00},
+	{0x3A6E, 0x09},
+	{0x3A6F, 0x00},
+	{0x3A70, 0x06},
+	{0x3A71, 0x00},
+	{0x3A72, 0x03},
+	{0x3A73, 0x00},
+	{0x3A74, 0x1F},
+	{0x3A75, 0x00},
+	{0x3A76, 0x1B},
+	{0x3A77, 0x00},
+	{0x3A78, 0x0F},
+	{0x3A79, 0x00},
+	{0x3A7A, 0x08},
+	{0x3A7B, 0x00},
+	{0x3A7C, 0x80},
+	{0x3A7D, 0x00},
+	{0x3A7E, 0x80},
+	{0x3A7F, 0x00},
+	{0x3A80, 0x80},
+	{0x3A81, 0x00},
+	{0x3A82, 0x80},
+	{0x3A83, 0x00},
+	{0x3A84, 0x09},
+	{0x3A85, 0x00},
+	{0x3A86, 0x04},
+	{0x3A87, 0x00},
+	{0x3A88, 0x03},
+	{0x3A89, 0x00},
+	{0x3A8A, 0x01},
+	{0x3A8B, 0x00},
+	{0x3A8C, 0x19},
+	{0x3A8D, 0x01},
+	{0x3A8E, 0xD2},
+	{0x3A8F, 0x00},
+	{0x3A90, 0x8C},
+	{0x3A91, 0x00},
+	{0x3A92, 0x64},
+	{0x3A93, 0x00},
+	{0x3A94, 0xFF},
+	{0x3A95, 0x00},
+	{0x3A96, 0xD2},
+	{0x3A97, 0x00},
+	{0x3A98, 0x8C},
+	{0x3A99, 0x00},
+	{0x3A9A, 0x64},
+	{0x3A9B, 0x00},
+	{0x3A9C, 0x08},
+	{0x3A9D, 0x10},
+	{0x3A9E, 0x80},
+	{0x3A9F, 0x80},
+	{0x3AA0, 0x80},
+	{0x3AA1, 0x04},
+	{0x3AA2, 0x05},
+	{0x3AC0, 0x01},
+	{0x3AC4, 0x81},
+	{0x3AC5, 0x00},
+	{0x3AC6, 0x00},
+	{0x3AC7, 0x00},
+	{0x3AC8, 0x00},
+	{0x3AC9, 0x00},
+	{0x3ACA, 0x00},
+	{0x3ACB, 0x00},
+	{0x3ACC, 0x02},
+	{0x3ACD, 0x00},
+	{0x3ACE, 0x81},
+	{0x3ACF, 0x00},
+	{0x3AD0, 0x00},
+	{0x3AD1, 0x00},
+	{0x3AD2, 0xFD},
+	{0x3AD3, 0x03},
+	{0x3AD4, 0x02},
+	{0x3AD5, 0x00},
+	{0x3AD6, 0x00},
+	{0x3AD7, 0x00},
+	{0x3AD8, 0x81},
+	{0x3AD9, 0x00},
+	{0x3ADA, 0xFD},
+	{0x3ADB, 0x03},
+	{0x3ADC, 0xFF},
+	{0x3ADD, 0x03},
+	{0x3ADE, 0x01},
+	{0x3ADF, 0x00},
+	{0x3AE0, 0x01},
+	{0x3AE1, 0x00},
+	{0x3AE2, 0x7E},
+	{0x3AE3, 0x00},
+	{0x3AF4, 0x00},
+	{0x3AF6, 0x40},
+	{0x3AF7, 0x1E},
+	{0x3AF8, 0x01},
+	{0x3AFA, 0x63},
+	{0x3AFB, 0x09},
+	{0x3AFC, 0x11},
+	{0x3AFD, 0x09},
+	{0x3AFE, 0x00},
+	{0x3AFF, 0x00},
+	{0x3B00, 0x00},
+	{0x3B01, 0x00},
+	{0x3B02, 0x84},
+	{0x3B03, 0x06},
+	{0x3B04, 0x30},
+	{0x3B05, 0x06},
+	{0x3B06, 0x00},
+	{0x3B07, 0x00},
+	{0x3B08, 0x00},
+	{0x3B09, 0x00},
+	{0x3B0A, 0x00},
+	{0x3B0B, 0x00},
+	{0x3B0C, 0x00},
+	{0x3B0D, 0x00},
+	{0x3B0E, 0x00},
+	{0x3B0F, 0x00},
+	{0x3B10, 0x00},
+	{0x3B11, 0x00},
+	{0x3B12, 0x00},
+	{0x3B13, 0x00},
+	{0x3B14, 0x00},
+	{0x3B15, 0x00},
+	{0x3B16, 0x00},
+	{0x3B17, 0x00},
+	{0x3B18, 0x00},
+	{0x3B19, 0x00},
+	{0x3B1A, 0x00},
+	{0x3B1B, 0x00},
+	{0x3B1C, 0x00},
+	{0x3B1D, 0x00},
+	{0x3B1E, 0x00},
+	{0x3B1F, 0x00},
+	{0x3B20, 0x00},
+	{0x3B21, 0x00},
+	{0x3B22, 0x00},
+	{0x3B23, 0x00},
+	{0x3B24, 0x00},
+	{0x3B25, 0x00},
+	{0x3B26, 0x00},
+	{0x3B27, 0x00},
+	{0x3B28, 0x00},
+	{0x3B29, 0x00},
+	{0x3B2A, 0x00},
+	{0x3B2C, 0x00},
+	{0x3B2E, 0x00},
+	{0x3B30, 0x00},
+	{0x3B32, 0x0C},
+	{0x4000, 0xD1},
+	{0x4001, 0xC0},
+	{0x4002, 0xC0},
+	{0x4003, 0xB8},
+	{0x4004, 0xC0},
+	{0x4005, 0xB8},
+	{0x4006, 0xB9},
+	{0x4007, 0xB7},
+	{0x4008, 0xB0},
+	{0x4009, 0xAB},
+	{0x400A, 0xAC},
+	{0x400B, 0xAB},
+	{0x400C, 0xA8},
+	{0x400D, 0xA6},
+	{0x400E, 0xA6},
+	{0x400F, 0xA5},
+	{0x4010, 0xA2},
+	{0x4011, 0xA0},
+	{0x4012, 0xA0},
+	{0x4013, 0x9F},
+	{0x4014, 0xA4},
+	{0x4015, 0xA2},
+	{0x4016, 0xA2},
+	{0x4017, 0x9C},
+	{0x4018, 0xA8},
+	{0x4019, 0xA6},
+	{0x401A, 0xA8},
+	{0x401B, 0xAA},
+	{0x401C, 0xB0},
+	{0x401D, 0xAE},
+	{0x401E, 0xAE},
+	{0x401F, 0xAE},
+	{0x4020, 0xBA},
+	{0x4021, 0xAE},
+	{0x4022, 0xAF},
+	{0x4023, 0xAE},
+	{0x4024, 0xC6},
+	{0x4025, 0xBD},
+	{0x4026, 0xBD},
+	{0x4027, 0xBA},
+	{0x4028, 0xB0},
+	{0x4029, 0xA9},
+	{0x402A, 0xAA},
+	{0x402B, 0xA8},
+	{0x402C, 0x9F},
+	{0x402D, 0x9C},
+	{0x402E, 0x9C},
+	{0x402F, 0x9B},
+	{0x4030, 0x93},
+	{0x4031, 0x91},
+	{0x4032, 0x92},
+	{0x4033, 0x91},
+	{0x4034, 0x8D},
+	{0x4035, 0x8C},
+	{0x4036, 0x8C},
+	{0x4037, 0x8C},
+	{0x4038, 0x8F},
+	{0x4039, 0x8E},
+	{0x403A, 0x8E},
+	{0x403B, 0x8E},
+	{0x403C, 0x98},
+	{0x403D, 0x96},
+	{0x403E, 0x96},
+	{0x403F, 0x95},
+	{0x4040, 0xA4},
+	{0x4041, 0xA0},
+	{0x4042, 0xA0},
+	{0x4043, 0x9E},
+	{0x4044, 0xB3},
+	{0x4045, 0xAE},
+	{0x4046, 0xAF},
+	{0x4047, 0xAB},
+	{0x4048, 0xC2},
+	{0x4049, 0xB7},
+	{0x404A, 0xB8},
+	{0x404B, 0xB5},
+	{0x404C, 0xAB},
+	{0x404D, 0xA4},
+	{0x404E, 0xA5},
+	{0x404F, 0xA3},
+	{0x4050, 0x99},
+	{0x4051, 0x96},
+	{0x4052, 0x96},
+	{0x4053, 0x96},
+	{0x4054, 0x8B},
+	{0x4055, 0x8A},
+	{0x4056, 0x8A},
+	{0x4057, 0x8A},
+	{0x4058, 0x82},
+	{0x4059, 0x81},
+	{0x405A, 0x81},
+	{0x405B, 0x81},
+	{0x405C, 0x85},
+	{0x405D, 0x86},
+	{0x405E, 0x85},
+	{0x405F, 0x85},
+	{0x4060, 0x90},
+	{0x4061, 0x90},
+	{0x4062, 0x8F},
+	{0x4063, 0x8F},
+	{0x4064, 0x9D},
+	{0x4065, 0x9B},
+	{0x4066, 0x9B},
+	{0x4067, 0x9A},
+	{0x4068, 0xAF},
+	{0x4069, 0xAA},
+	{0x406A, 0xAC},
+	{0x406B, 0xAA},
+	{0x406C, 0xC2},
+	{0x406D, 0xB7},
+	{0x406E, 0xB8},
+	{0x406F, 0xB5},
+	{0x4070, 0xAB},
+	{0x4071, 0xA4},
+	{0x4072, 0xA4},
+	{0x4073, 0xA3},
+	{0x4074, 0x99},
+	{0x4075, 0x96},
+	{0x4076, 0x96},
+	{0x4077, 0x96},
+	{0x4078, 0x8B},
+	{0x4079, 0x8A},
+	{0x407A, 0x8A},
+	{0x407B, 0x8A},
+	{0x407C, 0x82},
+	{0x407D, 0x82},
+	{0x407E, 0x82},
+	{0x407F, 0x82},
+	{0x4080, 0x85},
+	{0x4081, 0x86},
+	{0x4082, 0x86},
+	{0x4083, 0x86},
+	{0x4084, 0x90},
+	{0x4085, 0x90},
+	{0x4086, 0x8F},
+	{0x4087, 0x8F},
+	{0x4088, 0x9D},
+	{0x4089, 0x9B},
+	{0x408A, 0x9B},
+	{0x408B, 0x99},
+	{0x408C, 0xAE},
+	{0x408D, 0xAA},
+	{0x408E, 0xAA},
+	{0x408F, 0xA7},
+	{0x4090, 0xC7},
+	{0x4091, 0xBA},
+	{0x4092, 0xBC},
+	{0x4093, 0xB9},
+	{0x4094, 0xB1},
+	{0x4095, 0xA8},
+	{0x4096, 0xA8},
+	{0x4097, 0xA7},
+	{0x4098, 0x9F},
+	{0x4099, 0x9B},
+	{0x409A, 0x9B},
+	{0x409B, 0x9B},
+	{0x409C, 0x93},
+	{0x409D, 0x91},
+	{0x409E, 0x91},
+	{0x409F, 0x91},
+	{0x40A0, 0x8D},
+	{0x40A1, 0x8C},
+	{0x40A2, 0x8C},
+	{0x40A3, 0x8C},
+	{0x40A4, 0x8E},
+	{0x40A5, 0x8E},
+	{0x40A6, 0x8D},
+	{0x40A7, 0x8D},
+	{0x40A8, 0x96},
+	{0x40A9, 0x95},
+	{0x40AA, 0x95},
+	{0x40AB, 0x94},
+	{0x40AC, 0xA2},
+	{0x40AD, 0x9F},
+	{0x40AE, 0x9F},
+	{0x40AF, 0x9D},
+	{0x40B0, 0xB1},
+	{0x40B1, 0xAC},
+	{0x40B2, 0xAB},
+	{0x40B3, 0xAA},
+	{0x40B4, 0xD3},
+	{0x40B5, 0xBC},
+	{0x40B6, 0xBD},
+	{0x40B7, 0xBC},
+	{0x40B8, 0xC1},
+	{0x40B9, 0xB7},
+	{0x40BA, 0xB7},
+	{0x40BB, 0xB5},
+	{0x40BC, 0xB0},
+	{0x40BD, 0xAA},
+	{0x40BE, 0xAA},
+	{0x40BF, 0xAA},
+	{0x40C0, 0xA8},
+	{0x40C1, 0xA4},
+	{0x40C2, 0xA4},
+	{0x40C3, 0xA4},
+	{0x40C4, 0xA2},
+	{0x40C5, 0x9F},
+	{0x40C6, 0x9F},
+	{0x40C7, 0x9F},
+	{0x40C8, 0xA3},
+	{0x40C9, 0xA0},
+	{0x40CA, 0xA0},
+	{0x40CB, 0xA0},
+	{0x40CC, 0xA6},
+	{0x40CD, 0xA3},
+	{0x40CE, 0xA3},
+	{0x40CF, 0xA2},
+	{0x40D0, 0xAF},
+	{0x40D1, 0xAB},
+	{0x40D2, 0xAA},
+	{0x40D3, 0xA8},
+	{0x40D4, 0xBA},
+	{0x40D5, 0xAE},
+	{0x40D6, 0xAE},
+	{0x40D7, 0xAB},
+	{0x4100, 0xBD},
+	{0x4101, 0xBA},
+	{0x4102, 0xBD},
+	{0x4103, 0xB7},
+	{0x4104, 0xB7},
+	{0x4105, 0xB7},
+	{0x4106, 0xB8},
+	{0x4107, 0xB5},
+	{0x4108, 0xAB},
+	{0x4109, 0xAA},
+	{0x410A, 0xAC},
+	{0x410B, 0xAB},
+	{0x410C, 0xA4},
+	{0x410D, 0xA5},
+	{0x410E, 0xA5},
+	{0x410F, 0xA4},
+	{0x4110, 0x9F},
+	{0x4111, 0xA0},
+	{0x4112, 0xA0},
+	{0x4113, 0x9F},
+	{0x4114, 0xA0},
+	{0x4115, 0xA0},
+	{0x4116, 0xA0},
+	{0x4117, 0x9F},
+	{0x4118, 0xA1},
+	{0x4119, 0xA1},
+	{0x411A, 0xA1},
+	{0x411B, 0xA0},
+	{0x411C, 0xA7},
+	{0x411D, 0xA6},
+	{0x411E, 0xA6},
+	{0x411F, 0xA6},
+	{0x4120, 0xA7},
+	{0x4121, 0xA6},
+	{0x4122, 0xA6},
+	{0x4123, 0xA3},
+	{0x4124, 0xB9},
+	{0x4125, 0xB9},
+	{0x4126, 0xBA},
+	{0x4127, 0xB8},
+	{0x4128, 0xA6},
+	{0x4129, 0xA7},
+	{0x412A, 0xA7},
+	{0x412B, 0xA6},
+	{0x412C, 0x9B},
+	{0x412D, 0x9B},
+	{0x412E, 0x9B},
+	{0x412F, 0x9B},
+	{0x4130, 0x91},
+	{0x4131, 0x92},
+	{0x4132, 0x92},
+	{0x4133, 0x91},
+	{0x4134, 0x8C},
+	{0x4135, 0x8C},
+	{0x4136, 0x8C},
+	{0x4137, 0x8C},
+	{0x4138, 0x8D},
+	{0x4139, 0x8D},
+	{0x413A, 0x8D},
+	{0x413B, 0x8D},
+	{0x413C, 0x93},
+	{0x413D, 0x93},
+	{0x413E, 0x93},
+	{0x413F, 0x92},
+	{0x4140, 0x9A},
+	{0x4141, 0x9A},
+	{0x4142, 0x9A},
+	{0x4143, 0x99},
+	{0x4144, 0xA7},
+	{0x4145, 0xA5},
+	{0x4146, 0xA6},
+	{0x4147, 0xA6},
+	{0x4148, 0xB8},
+	{0x4149, 0xB4},
+	{0x414A, 0xB4},
+	{0x414B, 0xB3},
+	{0x414C, 0xA3},
+	{0x414D, 0xA2},
+	{0x414E, 0xA3},
+	{0x414F, 0xA2},
+	{0x4150, 0x96},
+	{0x4151, 0x96},
+	{0x4152, 0x96},
+	{0x4153, 0x96},
+	{0x4154, 0x8A},
+	{0x4155, 0x8A},
+	{0x4156, 0x8A},
+	{0x4157, 0x8A},
+	{0x4158, 0x82},
+	{0x4159, 0x82},
+	{0x415A, 0x82},
+	{0x415B, 0x82},
+	{0x415C, 0x84},
+	{0x415D, 0x85},
+	{0x415E, 0x84},
+	{0x415F, 0x84},
+	{0x4160, 0x8D},
+	{0x4161, 0x8D},
+	{0x4162, 0x8D},
+	{0x4163, 0x8D},
+	{0x4164, 0x96},
+	{0x4165, 0x96},
+	{0x4166, 0x96},
+	{0x4167, 0x95},
+	{0x4168, 0xA5},
+	{0x4169, 0xA2},
+	{0x416A, 0xA3},
+	{0x416B, 0xA2},
+	{0x416C, 0xB7},
+	{0x416D, 0xB3},
+	{0x416E, 0xB5},
+	{0x416F, 0xB4},
+	{0x4170, 0xA4},
+	{0x4171, 0xA2},
+	{0x4172, 0xA3},
+	{0x4173, 0xA2},
+	{0x4174, 0x97},
+	{0x4175, 0x96},
+	{0x4176, 0x96},
+	{0x4177, 0x96},
+	{0x4178, 0x8B},
+	{0x4179, 0x8A},
+	{0x417A, 0x8A},
+	{0x417B, 0x8A},
+	{0x417C, 0x81},
+	{0x417D, 0x81},
+	{0x417E, 0x81},
+	{0x417F, 0x81},
+	{0x4180, 0x84},
+	{0x4181, 0x84},
+	{0x4182, 0x84},
+	{0x4183, 0x84},
+	{0x4184, 0x8C},
+	{0x4185, 0x8D},
+	{0x4186, 0x8D},
+	{0x4187, 0x8D},
+	{0x4188, 0x95},
+	{0x4189, 0x96},
+	{0x418A, 0x96},
+	{0x418B, 0x95},
+	{0x418C, 0xA1},
+	{0x418D, 0xA1},
+	{0x418E, 0xA1},
+	{0x418F, 0xA0},
+	{0x4190, 0xBC},
+	{0x4191, 0xB8},
+	{0x4192, 0xB8},
+	{0x4193, 0xB9},
+	{0x4194, 0xA8},
+	{0x4195, 0xA5},
+	{0x4196, 0xA6},
+	{0x4197, 0xA5},
+	{0x4198, 0x9C},
+	{0x4199, 0x9A},
+	{0x419A, 0x9A},
+	{0x419B, 0x9A},
+	{0x419C, 0x91},
+	{0x419D, 0x91},
+	{0x419E, 0x91},
+	{0x419F, 0x91},
+	{0x41A0, 0x8B},
+	{0x41A1, 0x8B},
+	{0x41A2, 0x8B},
+	{0x41A3, 0x8B},
+	{0x41A4, 0x8C},
+	{0x41A5, 0x8C},
+	{0x41A6, 0x8C},
+	{0x41A7, 0x8C},
+	{0x41A8, 0x91},
+	{0x41A9, 0x92},
+	{0x41AA, 0x91},
+	{0x41AB, 0x91},
+	{0x41AC, 0x98},
+	{0x41AD, 0x99},
+	{0x41AE, 0x99},
+	{0x41AF, 0x98},
+	{0x41B0, 0xA3},
+	{0x41B1, 0xA3},
+	{0x41B2, 0xA3},
+	{0x41B3, 0xA2},
+	{0x41B4, 0xC1},
+	{0x41B5, 0xB8},
+	{0x41B6, 0xB9},
+	{0x41B7, 0xBA},
+	{0x41B8, 0xB8},
+	{0x41B9, 0xB4},
+	{0x41BA, 0xB4},
+	{0x41BB, 0xB4},
+	{0x41BC, 0xAA},
+	{0x41BD, 0xA7},
+	{0x41BE, 0xA7},
+	{0x41BF, 0xA8},
+	{0x41C0, 0xA4},
+	{0x41C1, 0xA2},
+	{0x41C2, 0xA2},
+	{0x41C3, 0xA3},
+	{0x41C4, 0x9E},
+	{0x41C5, 0x9D},
+	{0x41C6, 0x9D},
+	{0x41C7, 0x9D},
+	{0x41C8, 0x9E},
+	{0x41C9, 0x9D},
+	{0x41CA, 0x9D},
+	{0x41CB, 0x9D},
+	{0x41CC, 0x9E},
+	{0x41CD, 0x9E},
+	{0x41CE, 0x9E},
+	{0x41CF, 0x9E},
+	{0x41D0, 0xA3},
+	{0x41D1, 0xA3},
+	{0x41D2, 0xA2},
+	{0x41D3, 0xA1},
+	{0x41D4, 0xA7},
+	{0x41D5, 0xA7},
+	{0x41D6, 0xA7},
+	{0x41D7, 0xA3},
+	{0x4200, 0xCE},
+	{0x4201, 0xC0},
+	{0x4202, 0xC1},
+	{0x4203, 0xB9},
+	{0x4204, 0xC3},
+	{0x4205, 0xB9},
+	{0x4206, 0xBC},
+	{0x4207, 0xBD},
+	{0x4208, 0xB3},
+	{0x4209, 0xAE},
+	{0x420A, 0xAF},
+	{0x420B, 0xAE},
+	{0x420C, 0xAA},
+	{0x420D, 0xA8},
+	{0x420E, 0xA8},
+	{0x420F, 0xA6},
+	{0x4210, 0xA4},
+	{0x4211, 0xA2},
+	{0x4212, 0xA2},
+	{0x4213, 0xA0},
+	{0x4214, 0xA4},
+	{0x4215, 0xA3},
+	{0x4216, 0xA2},
+	{0x4217, 0xA0},
+	{0x4218, 0xA7},
+	{0x4219, 0xA5},
+	{0x421A, 0xA3},
+	{0x421B, 0xA1},
+	{0x421C, 0xB0},
+	{0x421D, 0xA8},
+	{0x421E, 0xA8},
+	{0x421F, 0xA6},
+	{0x4220, 0xB4},
+	{0x4221, 0xAA},
+	{0x4222, 0xA5},
+	{0x4223, 0xA3},
+	{0x4224, 0xC7},
+	{0x4225, 0xBC},
+	{0x4226, 0xBE},
+	{0x4227, 0xBC},
+	{0x4228, 0xB0},
+	{0x4229, 0xA9},
+	{0x422A, 0xA9},
+	{0x422B, 0xA8},
+	{0x422C, 0xA0},
+	{0x422D, 0x9D},
+	{0x422E, 0x9D},
+	{0x422F, 0x9C},
+	{0x4230, 0x94},
+	{0x4231, 0x93},
+	{0x4232, 0x93},
+	{0x4233, 0x92},
+	{0x4234, 0x8E},
+	{0x4235, 0x8D},
+	{0x4236, 0x8D},
+	{0x4237, 0x8C},
+	{0x4238, 0x8F},
+	{0x4239, 0x8E},
+	{0x423A, 0x8E},
+	{0x423B, 0x8D},
+	{0x423C, 0x96},
+	{0x423D, 0x94},
+	{0x423E, 0x94},
+	{0x423F, 0x92},
+	{0x4240, 0xA1},
+	{0x4241, 0x9C},
+	{0x4242, 0x9C},
+	{0x4243, 0x99},
+	{0x4244, 0xB0},
+	{0x4245, 0xA8},
+	{0x4246, 0xAB},
+	{0x4247, 0xA7},
+	{0x4248, 0xC3},
+	{0x4249, 0xB7},
+	{0x424A, 0xB7},
+	{0x424B, 0xBC},
+	{0x424C, 0xAB},
+	{0x424D, 0xA4},
+	{0x424E, 0xA5},
+	{0x424F, 0xA5},
+	{0x4250, 0x9A},
+	{0x4251, 0x97},
+	{0x4252, 0x97},
+	{0x4253, 0x98},
+	{0x4254, 0x8C},
+	{0x4255, 0x8B},
+	{0x4256, 0x8B},
+	{0x4257, 0x8B},
+	{0x4258, 0x82},
+	{0x4259, 0x82},
+	{0x425A, 0x82},
+	{0x425B, 0x82},
+	{0x425C, 0x85},
+	{0x425D, 0x85},
+	{0x425E, 0x85},
+	{0x425F, 0x84},
+	{0x4260, 0x8F},
+	{0x4261, 0x8E},
+	{0x4262, 0x8E},
+	{0x4263, 0x8D},
+	{0x4264, 0x9B},
+	{0x4265, 0x98},
+	{0x4266, 0x98},
+	{0x4267, 0x95},
+	{0x4268, 0xAE},
+	{0x4269, 0xA5},
+	{0x426A, 0xA7},
+	{0x426B, 0xA2},
+	{0x426C, 0xC2},
+	{0x426D, 0xB7},
+	{0x426E, 0xB8},
+	{0x426F, 0xB9},
+	{0x4270, 0xAA},
+	{0x4271, 0xA4},
+	{0x4272, 0xA4},
+	{0x4273, 0xA5},
+	{0x4274, 0x99},
+	{0x4275, 0x96},
+	{0x4276, 0x97},
+	{0x4277, 0x98},
+	{0x4278, 0x8B},
+	{0x4279, 0x8A},
+	{0x427A, 0x8A},
+	{0x427B, 0x8B},
+	{0x427C, 0x81},
+	{0x427D, 0x81},
+	{0x427E, 0x81},
+	{0x427F, 0x82},
+	{0x4280, 0x84},
+	{0x4281, 0x84},
+	{0x4282, 0x84},
+	{0x4283, 0x84},
+	{0x4284, 0x8E},
+	{0x4285, 0x8E},
+	{0x4286, 0x8D},
+	{0x4287, 0x8C},
+	{0x4288, 0x9A},
+	{0x4289, 0x97},
+	{0x428A, 0x97},
+	{0x428B, 0x95},
+	{0x428C, 0xAA},
+	{0x428D, 0xA3},
+	{0x428E, 0xA3},
+	{0x428F, 0xA2},
+	{0x4290, 0xC7},
+	{0x4291, 0xBA},
+	{0x4292, 0xC0},
+	{0x4293, 0xC3},
+	{0x4294, 0xB0},
+	{0x4295, 0xA7},
+	{0x4296, 0xA7},
+	{0x4297, 0xA9},
+	{0x4298, 0x9F},
+	{0x4299, 0x9B},
+	{0x429A, 0x9B},
+	{0x429B, 0x9D},
+	{0x429C, 0x93},
+	{0x429D, 0x91},
+	{0x429E, 0x91},
+	{0x429F, 0x92},
+	{0x42A0, 0x8C},
+	{0x42A1, 0x8B},
+	{0x42A2, 0x8B},
+	{0x42A3, 0x8C},
+	{0x42A4, 0x8D},
+	{0x42A5, 0x8C},
+	{0x42A6, 0x8C},
+	{0x42A7, 0x8C},
+	{0x42A8, 0x94},
+	{0x42A9, 0x93},
+	{0x42AA, 0x92},
+	{0x42AB, 0x91},
+	{0x42AC, 0x9E},
+	{0x42AD, 0x9B},
+	{0x42AE, 0x9B},
+	{0x42AF, 0x98},
+	{0x42B0, 0xAC},
+	{0x42B1, 0xA6},
+	{0x42B2, 0xA6},
+	{0x42B3, 0xA2},
+	{0x42B4, 0xCE},
+	{0x42B5, 0xBA},
+	{0x42B6, 0xBC},
+	{0x42B7, 0xB7},
+	{0x42B8, 0xC5},
+	{0x42B9, 0xB5},
+	{0x42BA, 0xBA},
+	{0x42BB, 0xC0},
+	{0x42BC, 0xB1},
+	{0x42BD, 0xA8},
+	{0x42BE, 0xAE},
+	{0x42BF, 0xAF},
+	{0x42C0, 0xA7},
+	{0x42C1, 0xA3},
+	{0x42C2, 0xA3},
+	{0x42C3, 0xA5},
+	{0x42C4, 0xA0},
+	{0x42C5, 0x9D},
+	{0x42C6, 0x9D},
+	{0x42C7, 0x9F},
+	{0x42C8, 0xA0},
+	{0x42C9, 0x9E},
+	{0x42CA, 0x9E},
+	{0x42CB, 0x9F},
+	{0x42CC, 0xA2},
+	{0x42CD, 0xA0},
+	{0x42CE, 0xA0},
+	{0x42CF, 0xA0},
+	{0x42D0, 0xA8},
+	{0x42D1, 0xA5},
+	{0x42D2, 0xA5},
+	{0x42D3, 0xA2},
+	{0x42D4, 0xB3},
+	{0x42D5, 0xAA},
+	{0x42D6, 0xAB},
+	{0x42D7, 0xA3},
+	{0x42D8, 0x00},
+	{0x42D9, 0x00},
+	{0x4300, 0xA2},
+	{0x4301, 0xAE},
+	{0x4302, 0xAD},
+	{0x4303, 0xB5},
+	{0x4304, 0x95},
+	{0x4305, 0x9A},
+	{0x4306, 0x98},
+	{0x4307, 0x9B},
+	{0x4308, 0x8D},
+	{0x4309, 0x90},
+	{0x430A, 0x8F},
+	{0x430B, 0x91},
+	{0x430C, 0x86},
+	{0x430D, 0x88},
+	{0x430E, 0x87},
+	{0x430F, 0x89},
+	{0x4310, 0x86},
+	{0x4311, 0x87},
+	{0x4312, 0x86},
+	{0x4313, 0x88},
+	{0x4314, 0x89},
+	{0x4315, 0x88},
+	{0x4316, 0x88},
+	{0x4317, 0x8E},
+	{0x4318, 0x90},
+	{0x4319, 0x8F},
+	{0x431A, 0x8C},
+	{0x431B, 0x8C},
+	{0x431C, 0x9C},
+	{0x431D, 0x99},
+	{0x431E, 0x98},
+	{0x431F, 0x99},
+	{0x4320, 0xAB},
+	{0x4321, 0xB0},
+	{0x4322, 0xAD},
+	{0x4323, 0xAF},
+	{0x4324, 0x9B},
+	{0x4325, 0x9F},
+	{0x4326, 0x9E},
+	{0x4327, 0xA1},
+	{0x4328, 0x8E},
+	{0x4329, 0x91},
+	{0x432A, 0x90},
+	{0x432B, 0x93},
+	{0x432C, 0x86},
+	{0x432D, 0x88},
+	{0x432E, 0x87},
+	{0x432F, 0x89},
+	{0x4330, 0x82},
+	{0x4331, 0x84},
+	{0x4332, 0x83},
+	{0x4333, 0x84},
+	{0x4334, 0x82},
+	{0x4335, 0x82},
+	{0x4336, 0x82},
+	{0x4337, 0x83},
+	{0x4338, 0x85},
+	{0x4339, 0x84},
+	{0x433A, 0x84},
+	{0x433B, 0x85},
+	{0x433C, 0x8A},
+	{0x433D, 0x89},
+	{0x433E, 0x88},
+	{0x433F, 0x89},
+	{0x4340, 0x93},
+	{0x4341, 0x91},
+	{0x4342, 0x91},
+	{0x4343, 0x93},
+	{0x4344, 0xA0},
+	{0x4345, 0x9E},
+	{0x4346, 0x9D},
+	{0x4347, 0xA1},
+	{0x4348, 0x95},
+	{0x4349, 0x9B},
+	{0x434A, 0x9A},
+	{0x434B, 0x9C},
+	{0x434C, 0x8A},
+	{0x434D, 0x8D},
+	{0x434E, 0x8C},
+	{0x434F, 0x8D},
+	{0x4350, 0x83},
+	{0x4351, 0x85},
+	{0x4352, 0x84},
+	{0x4353, 0x85},
+	{0x4354, 0x80},
+	{0x4355, 0x81},
+	{0x4356, 0x81},
+	{0x4357, 0x81},
+	{0x4358, 0x80},
+	{0x4359, 0x80},
+	{0x435A, 0x80},
+	{0x435B, 0x80},
+	{0x435C, 0x82},
+	{0x435D, 0x81},
+	{0x435E, 0x81},
+	{0x435F, 0x81},
+	{0x4360, 0x85},
+	{0x4361, 0x84},
+	{0x4362, 0x84},
+	{0x4363, 0x85},
+	{0x4364, 0x8D},
+	{0x4365, 0x8B},
+	{0x4366, 0x8B},
+	{0x4367, 0x8D},
+	{0x4368, 0x98},
+	{0x4369, 0x98},
+	{0x436A, 0x95},
+	{0x436B, 0x98},
+	{0x436C, 0x95},
+	{0x436D, 0x9A},
+	{0x436E, 0x99},
+	{0x436F, 0x9A},
+	{0x4370, 0x8A},
+	{0x4371, 0x8D},
+	{0x4372, 0x8C},
+	{0x4373, 0x8C},
+	{0x4374, 0x83},
+	{0x4375, 0x85},
+	{0x4376, 0x84},
+	{0x4377, 0x84},
+	{0x4378, 0x80},
+	{0x4379, 0x80},
+	{0x437A, 0x80},
+	{0x437B, 0x80},
+	{0x437C, 0x7F},
+	{0x437D, 0x7F},
+	{0x437E, 0x7F},
+	{0x437F, 0x7F},
+	{0x4380, 0x81},
+	{0x4381, 0x80},
+	{0x4382, 0x80},
+	{0x4383, 0x81},
+	{0x4384, 0x84},
+	{0x4385, 0x83},
+	{0x4386, 0x83},
+	{0x4387, 0x84},
+	{0x4388, 0x8B},
+	{0x4389, 0x8A},
+	{0x438A, 0x8A},
+	{0x438B, 0x8C},
+	{0x438C, 0x97},
+	{0x438D, 0x96},
+	{0x438E, 0x96},
+	{0x438F, 0x99},
+	{0x4390, 0x99},
+	{0x4391, 0x9F},
+	{0x4392, 0x9E},
+	{0x4393, 0x9D},
+	{0x4394, 0x8D},
+	{0x4395, 0x90},
+	{0x4396, 0x90},
+	{0x4397, 0x8F},
+	{0x4398, 0x85},
+	{0x4399, 0x87},
+	{0x439A, 0x87},
+	{0x439B, 0x86},
+	{0x439C, 0x81},
+	{0x439D, 0x83},
+	{0x439E, 0x82},
+	{0x439F, 0x82},
+	{0x43A0, 0x80},
+	{0x43A1, 0x81},
+	{0x43A2, 0x81},
+	{0x43A3, 0x81},
+	{0x43A4, 0x82},
+	{0x43A5, 0x82},
+	{0x43A6, 0x82},
+	{0x43A7, 0x82},
+	{0x43A8, 0x86},
+	{0x43A9, 0x85},
+	{0x43AA, 0x85},
+	{0x43AB, 0x87},
+	{0x43AC, 0x8D},
+	{0x43AD, 0x8D},
+	{0x43AE, 0x8D},
+	{0x43AF, 0x90},
+	{0x43B0, 0x9A},
+	{0x43B1, 0x9A},
+	{0x43B2, 0x9B},
+	{0x43B3, 0x9D},
+	{0x43B4, 0xA0},
+	{0x43B5, 0xAD},
+	{0x43B6, 0xAC},
+	{0x43B7, 0xAA},
+	{0x43B8, 0x93},
+	{0x43B9, 0x97},
+	{0x43BA, 0x97},
+	{0x43BB, 0x96},
+	{0x43BC, 0x8B},
+	{0x43BD, 0x8E},
+	{0x43BE, 0x8E},
+	{0x43BF, 0x8C},
+	{0x43C0, 0x83},
+	{0x43C1, 0x85},
+	{0x43C2, 0x85},
+	{0x43C3, 0x84},
+	{0x43C4, 0x82},
+	{0x43C5, 0x84},
+	{0x43C6, 0x83},
+	{0x43C7, 0x83},
+	{0x43C8, 0x83},
+	{0x43C9, 0x84},
+	{0x43CA, 0x84},
+	{0x43CB, 0x85},
+	{0x43CC, 0x8A},
+	{0x43CD, 0x8A},
+	{0x43CE, 0x8A},
+	{0x43CF, 0x8C},
+	{0x43D0, 0x92},
+	{0x43D1, 0x93},
+	{0x43D2, 0x93},
+	{0x43D3, 0x96},
+	{0x43D4, 0x9F},
+	{0x43D5, 0xA6},
+	{0x43D6, 0xA5},
+	{0x43D7, 0xAA},
+	{0x4400, 0xA1},
+	{0x4401, 0xAB},
+	{0x4402, 0xA7},
+	{0x4403, 0xB0},
+	{0x4404, 0x91},
+	{0x4405, 0x96},
+	{0x4406, 0x94},
+	{0x4407, 0x99},
+	{0x4408, 0x8A},
+	{0x4409, 0x8E},
+	{0x440A, 0x8C},
+	{0x440B, 0x8F},
+	{0x440C, 0x85},
+	{0x440D, 0x86},
+	{0x440E, 0x86},
+	{0x440F, 0x88},
+	{0x4410, 0x85},
+	{0x4411, 0x86},
+	{0x4412, 0x85},
+	{0x4413, 0x87},
+	{0x4414, 0x88},
+	{0x4415, 0x87},
+	{0x4416, 0x87},
+	{0x4417, 0x89},
+	{0x4418, 0x91},
+	{0x4419, 0x8F},
+	{0x441A, 0x8F},
+	{0x441B, 0x90},
+	{0x441C, 0x9C},
+	{0x441D, 0x9B},
+	{0x441E, 0x9A},
+	{0x441F, 0x9A},
+	{0x4420, 0xB3},
+	{0x4421, 0xB1},
+	{0x4422, 0xB0},
+	{0x4423, 0xB2},
+	{0x4424, 0x96},
+	{0x4425, 0x9C},
+	{0x4426, 0x9A},
+	{0x4427, 0x9E},
+	{0x4428, 0x8B},
+	{0x4429, 0x8F},
+	{0x442A, 0x8E},
+	{0x442B, 0x91},
+	{0x442C, 0x84},
+	{0x442D, 0x87},
+	{0x442E, 0x86},
+	{0x442F, 0x88},
+	{0x4430, 0x82},
+	{0x4431, 0x83},
+	{0x4432, 0x82},
+	{0x4433, 0x84},
+	{0x4434, 0x82},
+	{0x4435, 0x82},
+	{0x4436, 0x82},
+	{0x4437, 0x83},
+	{0x4438, 0x84},
+	{0x4439, 0x84},
+	{0x443A, 0x84},
+	{0x443B, 0x84},
+	{0x443C, 0x8B},
+	{0x443D, 0x89},
+	{0x443E, 0x89},
+	{0x443F, 0x89},
+	{0x4440, 0x95},
+	{0x4441, 0x93},
+	{0x4442, 0x93},
+	{0x4443, 0x93},
+	{0x4444, 0xA2},
+	{0x4445, 0xA2},
+	{0x4446, 0xA1},
+	{0x4447, 0xA0},
+	{0x4448, 0x8F},
+	{0x4449, 0x97},
+	{0x444A, 0x97},
+	{0x444B, 0x98},
+	{0x444C, 0x87},
+	{0x444D, 0x8B},
+	{0x444E, 0x8A},
+	{0x444F, 0x8B},
+	{0x4450, 0x81},
+	{0x4451, 0x83},
+	{0x4452, 0x83},
+	{0x4453, 0x84},
+	{0x4454, 0x7F},
+	{0x4455, 0x80},
+	{0x4456, 0x80},
+	{0x4457, 0x81},
+	{0x4458, 0x80},
+	{0x4459, 0x80},
+	{0x445A, 0x80},
+	{0x445B, 0x80},
+	{0x445C, 0x82},
+	{0x445D, 0x81},
+	{0x445E, 0x81},
+	{0x445F, 0x81},
+	{0x4460, 0x87},
+	{0x4461, 0x85},
+	{0x4462, 0x85},
+	{0x4463, 0x86},
+	{0x4464, 0x90},
+	{0x4465, 0x8E},
+	{0x4466, 0x8E},
+	{0x4467, 0x8E},
+	{0x4468, 0x9B},
+	{0x4469, 0x9C},
+	{0x446A, 0x9A},
+	{0x446B, 0x9A},
+	{0x446C, 0x91},
+	{0x446D, 0x97},
+	{0x446E, 0x95},
+	{0x446F, 0x95},
+	{0x4470, 0x87},
+	{0x4471, 0x8A},
+	{0x4472, 0x8A},
+	{0x4473, 0x89},
+	{0x4474, 0x81},
+	{0x4475, 0x83},
+	{0x4476, 0x83},
+	{0x4477, 0x83},
+	{0x4478, 0x7F},
+	{0x4479, 0x80},
+	{0x447A, 0x80},
+	{0x447B, 0x80},
+	{0x447C, 0x80},
+	{0x447D, 0x80},
+	{0x447E, 0x80},
+	{0x447F, 0x7F},
+	{0x4480, 0x81},
+	{0x4481, 0x81},
+	{0x4482, 0x81},
+	{0x4483, 0x81},
+	{0x4484, 0x85},
+	{0x4485, 0x85},
+	{0x4486, 0x85},
+	{0x4487, 0x85},
+	{0x4488, 0x8E},
+	{0x4489, 0x8D},
+	{0x448A, 0x8D},
+	{0x448B, 0x8E},
+	{0x448C, 0x9D},
+	{0x448D, 0x9C},
+	{0x448E, 0x9C},
+	{0x448F, 0x9C},
+	{0x4490, 0x94},
+	{0x4491, 0x9B},
+	{0x4492, 0x9A},
+	{0x4493, 0x97},
+	{0x4494, 0x8A},
+	{0x4495, 0x8E},
+	{0x4496, 0x8E},
+	{0x4497, 0x8C},
+	{0x4498, 0x84},
+	{0x4499, 0x86},
+	{0x449A, 0x86},
+	{0x449B, 0x84},
+	{0x449C, 0x81},
+	{0x449D, 0x83},
+	{0x449E, 0x83},
+	{0x449F, 0x81},
+	{0x44A0, 0x81},
+	{0x44A1, 0x82},
+	{0x44A2, 0x82},
+	{0x44A3, 0x81},
+	{0x44A4, 0x83},
+	{0x44A5, 0x83},
+	{0x44A6, 0x83},
+	{0x44A7, 0x83},
+	{0x44A8, 0x88},
+	{0x44A9, 0x88},
+	{0x44AA, 0x88},
+	{0x44AB, 0x88},
+	{0x44AC, 0x91},
+	{0x44AD, 0x91},
+	{0x44AE, 0x91},
+	{0x44AF, 0x92},
+	{0x44B0, 0xA0},
+	{0x44B1, 0xA0},
+	{0x44B2, 0xA0},
+	{0x44B3, 0xA0},
+	{0x44B4, 0x9E},
+	{0x44B5, 0xA9},
+	{0x44B6, 0xA8},
+	{0x44B7, 0xA3},
+	{0x44B8, 0x90},
+	{0x44B9, 0x95},
+	{0x44BA, 0x95},
+	{0x44BB, 0x92},
+	{0x44BC, 0x8A},
+	{0x44BD, 0x8E},
+	{0x44BE, 0x8E},
+	{0x44BF, 0x8B},
+	{0x44C0, 0x84},
+	{0x44C1, 0x86},
+	{0x44C2, 0x86},
+	{0x44C3, 0x84},
+	{0x44C4, 0x84},
+	{0x44C5, 0x85},
+	{0x44C6, 0x85},
+	{0x44C7, 0x84},
+	{0x44C8, 0x86},
+	{0x44C9, 0x87},
+	{0x44CA, 0x87},
+	{0x44CB, 0x86},
+	{0x44CC, 0x8D},
+	{0x44CD, 0x8E},
+	{0x44CE, 0x8E},
+	{0x44CF, 0x8D},
+	{0x44D0, 0x98},
+	{0x44D1, 0x98},
+	{0x44D2, 0x99},
+	{0x44D3, 0x9A},
+	{0x44D4, 0xA9},
+	{0x44D5, 0xAA},
+	{0x44D6, 0xAA},
+	{0x44D7, 0xAD},
+	{0x4500, 0x9F},
+	{0x4501, 0xA8},
+	{0x4502, 0xA5},
+	{0x4503, 0xAF},
+	{0x4504, 0x8F},
+	{0x4505, 0x96},
+	{0x4506, 0x92},
+	{0x4507, 0x94},
+	{0x4508, 0x89},
+	{0x4509, 0x8D},
+	{0x450A, 0x8A},
+	{0x450B, 0x8E},
+	{0x450C, 0x84},
+	{0x450D, 0x85},
+	{0x450E, 0x84},
+	{0x450F, 0x87},
+	{0x4510, 0x84},
+	{0x4511, 0x85},
+	{0x4512, 0x84},
+	{0x4513, 0x86},
+	{0x4514, 0x87},
+	{0x4515, 0x86},
+	{0x4516, 0x86},
+	{0x4517, 0x88},
+	{0x4518, 0x8F},
+	{0x4519, 0x8D},
+	{0x451A, 0x8D},
+	{0x451B, 0x8F},
+	{0x451C, 0x9A},
+	{0x451D, 0x9A},
+	{0x451E, 0x98},
+	{0x451F, 0x9A},
+	{0x4520, 0xAF},
+	{0x4521, 0xAF},
+	{0x4522, 0xB2},
+	{0x4523, 0xB1},
+	{0x4524, 0x95},
+	{0x4525, 0x9B},
+	{0x4526, 0x97},
+	{0x4527, 0x9C},
+	{0x4528, 0x8A},
+	{0x4529, 0x8E},
+	{0x452A, 0x8D},
+	{0x452B, 0x90},
+	{0x452C, 0x84},
+	{0x452D, 0x86},
+	{0x452E, 0x85},
+	{0x452F, 0x87},
+	{0x4530, 0x81},
+	{0x4531, 0x82},
+	{0x4532, 0x82},
+	{0x4533, 0x83},
+	{0x4534, 0x81},
+	{0x4535, 0x81},
+	{0x4536, 0x81},
+	{0x4537, 0x82},
+	{0x4538, 0x84},
+	{0x4539, 0x83},
+	{0x453A, 0x83},
+	{0x453B, 0x84},
+	{0x453C, 0x8A},
+	{0x453D, 0x88},
+	{0x453E, 0x88},
+	{0x453F, 0x89},
+	{0x4540, 0x94},
+	{0x4541, 0x92},
+	{0x4542, 0x91},
+	{0x4543, 0x92},
+	{0x4544, 0xA1},
+	{0x4545, 0xA0},
+	{0x4546, 0x9C},
+	{0x4547, 0x9D},
+	{0x4548, 0x8F},
+	{0x4549, 0x96},
+	{0x454A, 0x95},
+	{0x454B, 0x92},
+	{0x454C, 0x87},
+	{0x454D, 0x8A},
+	{0x454E, 0x89},
+	{0x454F, 0x8A},
+	{0x4550, 0x81},
+	{0x4551, 0x83},
+	{0x4552, 0x82},
+	{0x4553, 0x83},
+	{0x4554, 0x7F},
+	{0x4555, 0x80},
+	{0x4556, 0x80},
+	{0x4557, 0x81},
+	{0x4558, 0x7F},
+	{0x4559, 0x80},
+	{0x455A, 0x7F},
+	{0x455B, 0x80},
+	{0x455C, 0x81},
+	{0x455D, 0x81},
+	{0x455E, 0x81},
+	{0x455F, 0x81},
+	{0x4560, 0x86},
+	{0x4561, 0x85},
+	{0x4562, 0x85},
+	{0x4563, 0x85},
+	{0x4564, 0x8F},
+	{0x4565, 0x8D},
+	{0x4566, 0x8D},
+	{0x4567, 0x8D},
+	{0x4568, 0x99},
+	{0x4569, 0x9A},
+	{0x456A, 0x97},
+	{0x456B, 0x99},
+	{0x456C, 0x90},
+	{0x456D, 0x95},
+	{0x456E, 0x93},
+	{0x456F, 0x92},
+	{0x4570, 0x87},
+	{0x4571, 0x8A},
+	{0x4572, 0x88},
+	{0x4573, 0x87},
+	{0x4574, 0x81},
+	{0x4575, 0x83},
+	{0x4576, 0x82},
+	{0x4577, 0x82},
+	{0x4578, 0x7F},
+	{0x4579, 0x80},
+	{0x457A, 0x80},
+	{0x457B, 0x80},
+	{0x457C, 0x80},
+	{0x457D, 0x80},
+	{0x457E, 0x80},
+	{0x457F, 0x80},
+	{0x4580, 0x81},
+	{0x4581, 0x81},
+	{0x4582, 0x81},
+	{0x4583, 0x81},
+	{0x4584, 0x85},
+	{0x4585, 0x85},
+	{0x4586, 0x84},
+	{0x4587, 0x85},
+	{0x4588, 0x8E},
+	{0x4589, 0x8D},
+	{0x458A, 0x8C},
+	{0x458B, 0x8D},
+	{0x458C, 0x9B},
+	{0x458D, 0x9B},
+	{0x458E, 0x9A},
+	{0x458F, 0x98},
+	{0x4590, 0x94},
+	{0x4591, 0x9A},
+	{0x4592, 0x94},
+	{0x4593, 0x90},
+	{0x4594, 0x8A},
+	{0x4595, 0x8D},
+	{0x4596, 0x8C},
+	{0x4597, 0x89},
+	{0x4598, 0x84},
+	{0x4599, 0x86},
+	{0x459A, 0x85},
+	{0x459B, 0x83},
+	{0x459C, 0x82},
+	{0x459D, 0x83},
+	{0x459E, 0x82},
+	{0x459F, 0x80},
+	{0x45A0, 0x81},
+	{0x45A1, 0x82},
+	{0x45A2, 0x81},
+	{0x45A3, 0x80},
+	{0x45A4, 0x83},
+	{0x45A5, 0x83},
+	{0x45A6, 0x83},
+	{0x45A7, 0x83},
+	{0x45A8, 0x88},
+	{0x45A9, 0x87},
+	{0x45AA, 0x87},
+	{0x45AB, 0x88},
+	{0x45AC, 0x91},
+	{0x45AD, 0x90},
+	{0x45AE, 0x90},
+	{0x45AF, 0x91},
+	{0x45B0, 0x9F},
+	{0x45B1, 0x9F},
+	{0x45B2, 0x9E},
+	{0x45B3, 0x9F},
+	{0x45B4, 0x9F},
+	{0x45B5, 0xA8},
+	{0x45B6, 0xA6},
+	{0x45B7, 0xA7},
+	{0x45B8, 0x8D},
+	{0x45B9, 0x95},
+	{0x45BA, 0x90},
+	{0x45BB, 0x8A},
+	{0x45BC, 0x89},
+	{0x45BD, 0x8D},
+	{0x45BE, 0x88},
+	{0x45BF, 0x86},
+	{0x45C0, 0x84},
+	{0x45C1, 0x86},
+	{0x45C2, 0x85},
+	{0x45C3, 0x82},
+	{0x45C4, 0x84},
+	{0x45C5, 0x85},
+	{0x45C6, 0x85},
+	{0x45C7, 0x83},
+	{0x45C8, 0x86},
+	{0x45C9, 0x86},
+	{0x45CA, 0x86},
+	{0x45CB, 0x85},
+	{0x45CC, 0x8E},
+	{0x45CD, 0x8D},
+	{0x45CE, 0x8D},
+	{0x45CF, 0x8C},
+	{0x45D0, 0x99},
+	{0x45D1, 0x98},
+	{0x45D2, 0x98},
+	{0x45D3, 0x98},
+	{0x45D4, 0xA6},
+	{0x45D5, 0xA9},
+	{0x45D6, 0xA7},
+	{0x45D7, 0xAC},
+};
+
+const size_t imx390_mode_1936x1100SP1L_len =
+	ARRAY_SIZE(imx390_mode_1936x1100SP1L);
diff --git a/drivers/d3/imx390/imx390-mode-1936x1100-SP1L.h b/drivers/d3/imx390/imx390-mode-1936x1100-SP1L.h
new file mode 100644
index 000000000000..183af7ea9745
--- /dev/null
+++ b/drivers/d3/imx390/imx390-mode-1936x1100-SP1L.h
@@ -0,0 +1,28 @@
+/**
+ * @author Greg Rowe <growe@d3engineering.com>
+ *
+ * imx390 v4l2 driver for Nvidia Jetson
+ *
+ * Copyright (c) 2018-2019, D3 Engineering.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+#ifndef _IMX390_MODE_1936X1100_SP1L_H
+#define _IMX390_MODE_1936X1100_SP1L_H
+
+#include <linux/regmap.h>
+
+extern const struct reg_sequence imx390_mode_1936x1100SP1L[];
+extern const size_t imx390_mode_1936x1100SP1L_len;
+
+#endif
diff --git a/drivers/d3/imx390/imx390-mode-1936x1100-SP2.c b/drivers/d3/imx390/imx390-mode-1936x1100-SP2.c
new file mode 100644
index 000000000000..01282b217f43
--- /dev/null
+++ b/drivers/d3/imx390/imx390-mode-1936x1100-SP2.c
@@ -0,0 +1,3104 @@
+/**
+ * @author Greg Rowe <growe@d3engineering.com>
+ *
+ * imx390 v4l2 driver for Nvidia Jetson
+ *
+ * Copyright (c) 2018-2019, D3 Engineering.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+#include "imx390-mode-1936x1100-SP2.h"
+
+/**
+ * This configuration was supplied by Sony. The only real modification
+ * we (D3) made was to disable the rear embedded data line.
+ *
+ * This was supplied on 2018-10-24 and is the SP2 table
+ */
+const struct reg_sequence imx390_mode_1936x1100SP2[] = {
+	{0x000C,0xF2},
+	{0x000D,0x02},
+	{0x000E,0x00},
+	{0x0010,0xF2},
+	{0x0011,0x02},
+	{0x0012,0x00},
+	{0x0018,0x15},
+	{0x0019,0x00},
+	{0x001A,0x0C},
+	{0x001B,0x00},
+	{0x0038,0x00},
+	{0x003C,0x00},
+	{0x003D,0x00},
+	{0x003E,0x00},
+	{0x0040,0x00},
+	{0x0041,0x00},
+	{0x0042,0x00},
+	{0x0044,0x00},
+	{0x0045,0x00},
+	{0x0046,0x00},
+	{0x0048,0x00},
+	{0x0049,0x00},
+	{0x004A,0x00},
+	{0x004C,0x00},
+	{0x004D,0x00},
+	{0x004E,0x00},
+	{0x0050,0x00},
+	{0x0051,0x00},
+	{0x0052,0x00},
+	{0x0054,0x00},
+	{0x0055,0x00},
+	{0x0056,0x00},
+	{0x0058,0x00},
+	{0x0059,0x00},
+	{0x005A,0x00},
+	{0x005C,0x00},
+	{0x005D,0x00},
+	{0x005E,0x00},
+	{0x0060,0x00},
+	{0x0061,0x00},
+	{0x0062,0x00},
+	{0x0064,0x00},
+	{0x0065,0x00},
+	{0x0066,0x00},
+	{0x0068,0x00},
+	{0x0069,0x00},
+	{0x006A,0x00},
+	{0x0078,0x00},
+	{0x007C,0x00},
+	{0x007D,0x00},
+	{0x0080,0x00},
+	{0x0081,0x00},
+	{0x00F4,0x1C},
+	{0x00F5,0xF8},
+	{0x00F6,0x01},
+	{0x00F8,0x03},
+	{0x00F9,0x00},
+	{0x00FA,0x02},
+	{0x00FB,0x00},
+	{0x0114,0x00},
+	{0x0115,0x01},
+	{0x0118,0x20},
+	{0x0119,0x03},
+	{0x011A,0x00},
+	{0x011B,0x41},
+	{0x011C,0x80},
+	{0x011D,0x00},
+	{0x0120,0x20},
+	{0x0121,0x00},
+	{0x0122,0x00},
+	{0x0123,0x44},
+	{0x0124,0x00},
+	{0x0125,0x01},
+	{0x0128,0xAC},
+	{0x0129,0x0D},
+	{0x012A,0x00},
+	{0x012B,0xA4},
+	{0x012C,0x00},
+	{0x012D,0x01},
+	{0x0130,0xC4},
+	{0x0131,0x09},
+	{0x0132,0x00},
+	{0x0133,0xDA},
+	{0x013B,0x01},
+	{0x01C4,0x00},
+	{0x01C5,0x00},
+	{0x01CC,0x01},
+	{0x01D0,0x09},
+	{0x01D4,0x01},
+	{0x0332,0x2A},
+	{0x0333,0x00},
+	{0x0390,0x00},
+	{0x0391,0x00},
+	{0x0392,0x00},
+	{0x03C0,0x00},
+	{0x2000,0x55},
+	{0x2001,0x55},
+	{0x2002,0x55},
+	{0x2003,0x05},
+	{0x2004,0x02},
+	{0x2008,0x65},
+	{0x2009,0x04},
+	{0x200A,0x00},
+	{0x200C,0x30},
+	{0x200D,0x11},
+	{0x2010,0x04},
+	{0x2014,0x01},
+	{0x2018,0x02},
+	{0x2019,0x04},
+	{0x201A,0x00},
+	{0x201C,0x21},
+	{0x201D,0x11},
+	{0x201E,0x00},
+	{0x201F,0x00},
+	{0x2020,0xBC},
+	{0x2021,0x00},
+	{0x2022,0x7F},
+	{0x2023,0x00},
+	{0x2024,0xBA},
+	{0x2025,0x00},
+	{0x2026,0x81},
+	{0x2027,0x00},
+	{0x2028,0x7D},
+	{0x2029,0x90},
+	{0x202A,0x05},
+	{0x202C,0xFC},
+	{0x202D,0x02},
+	{0x202E,0x25},
+	{0x202F,0x03},
+	{0x2030,0x05},
+	{0x2031,0x02},
+	{0x2032,0xCA},
+	{0x2033,0x02},
+	{0x2034,0xFC},
+	{0x2035,0x02},
+	{0x2036,0x25},
+	{0x2037,0x03},
+	{0x2038,0x25},
+	{0x2039,0x97},
+	{0x203A,0xEC},
+	{0x203B,0x01},
+	{0x203C,0xF5},
+	{0x203D,0x8E},
+	{0x203E,0x0C},
+	{0x203F,0x2D},
+	{0x2040,0x69},
+	{0x2041,0x01},
+	{0x2042,0x8E},
+	{0x2043,0x01},
+	{0x2044,0x0C},
+	{0x2045,0x02},
+	{0x2046,0x31},
+	{0x2047,0x02},
+	{0x2048,0x6A},
+	{0x2049,0x01},
+	{0x204A,0x8E},
+	{0x204B,0x01},
+	{0x204C,0x0D},
+	{0x204D,0x02},
+	{0x204E,0x31},
+	{0x204F,0x02},
+	{0x2050,0x7B},
+	{0x2051,0x00},
+	{0x2052,0x7D},
+	{0x2053,0x00},
+	{0x2054,0x95},
+	{0x2055,0x00},
+	{0x2056,0x97},
+	{0x2057,0x00},
+	{0x2058,0xAD},
+	{0x2059,0x00},
+	{0x205A,0xAF},
+	{0x205B,0x00},
+	{0x205C,0x92},
+	{0x205D,0x00},
+	{0x205E,0x94},
+	{0x205F,0x00},
+	{0x2060,0x8E},
+	{0x2061,0x00},
+	{0x2062,0x90},
+	{0x2063,0x00},
+	{0x2064,0xB1},
+	{0x2065,0x00},
+	{0x2066,0xB3},
+	{0x2067,0x00},
+	{0x2068,0x08},
+	{0x2069,0x00},
+	{0x206A,0x04},
+	{0x206B,0x00},
+	{0x206C,0x84},
+	{0x206D,0x00},
+	{0x206E,0x80},
+	{0x206F,0x00},
+	{0x2070,0x04},
+	{0x2071,0x00},
+	{0x2072,0x46},
+	{0x2073,0x00},
+	{0x2074,0xE9},
+	{0x2075,0x01},
+	{0x2076,0x74},
+	{0x2077,0x02},
+	{0x2078,0x80},
+	{0x2079,0x00},
+	{0x207A,0xC1},
+	{0x207B,0x00},
+	{0x207C,0xFF},
+	{0x207D,0x03},
+	{0x207E,0xFF},
+	{0x207F,0x03},
+	{0x2080,0x78},
+	{0x2081,0x00},
+	{0x2082,0x6A},
+	{0x2083,0x01},
+	{0x2084,0xE4},
+	{0x2085,0x01},
+	{0x2086,0x2B},
+	{0x2087,0x03},
+	{0x2088,0x00},
+	{0x2089,0x00},
+	{0x208A,0xFF},
+	{0x208B,0x03},
+	{0x208C,0xFF},
+	{0x208D,0x03},
+	{0x208E,0xFF},
+	{0x208F,0x03},
+	{0x2090,0x7D},
+	{0x2091,0x00},
+	{0x2092,0x62},
+	{0x2093,0x01},
+	{0x2094,0xE9},
+	{0x2095,0x01},
+	{0x2096,0x00},
+	{0x2097,0x00},
+	{0x2098,0x7C},
+	{0x2099,0x00},
+	{0x209A,0x21},
+	{0x209B,0x03},
+	{0x209C,0xE9},
+	{0x209D,0x01},
+	{0x209E,0x21},
+	{0x209F,0x03},
+	{0x20A0,0xFF},
+	{0x20A1,0x03},
+	{0x20A2,0xFF},
+	{0x20A3,0x03},
+	{0x20A4,0xFF},
+	{0x20A5,0x03},
+	{0x20A6,0xFF},
+	{0x20A7,0x03},
+	{0x20A8,0xFF},
+	{0x20A9,0x03},
+	{0x20AA,0xFF},
+	{0x20AB,0x03},
+	{0x20AC,0xFF},
+	{0x20AD,0x03},
+	{0x20AE,0xFF},
+	{0x20AF,0x03},
+	{0x20B0,0xFF},
+	{0x20B1,0x03},
+	{0x20B2,0xFF},
+	{0x20B3,0x03},
+	{0x20B4,0x87},
+	{0x20B5,0xCC},
+	{0x20B6,0x87},
+	{0x20B7,0x08},
+	{0x20B8,0xF4},
+	{0x20B9,0xA5},
+	{0x20BA,0x07},
+	{0x20BC,0x1F},
+	{0x20BD,0x01},
+	{0x20BE,0xF6},
+	{0x20BF,0x00},
+	{0x20C0,0x90},
+	{0x20C1,0x01},
+	{0x20C2,0x67},
+	{0x20C3,0x01},
+	{0x20C4,0xFF},
+	{0x20C5,0x03},
+	{0x20C6,0xFF},
+	{0x20C7,0x03},
+	{0x20C8,0x33},
+	{0x20C9,0x02},
+	{0x20CA,0x0A},
+	{0x20CB,0x02},
+	{0x20CC,0x7F},
+	{0x20CD,0x00},
+	{0x20CE,0xD2},
+	{0x20CF,0x00},
+	{0x20D0,0x81},
+	{0x20D1,0x00},
+	{0x20D2,0x87},
+	{0x20D3,0x00},
+	{0x20D4,0x09},
+	{0x20D5,0x00},
+	{0x20D8,0x7F},
+	{0x20D9,0x00},
+	{0x20DA,0x62},
+	{0x20DB,0x01},
+	{0x20DC,0x7F},
+	{0x20DD,0x00},
+	{0x20DE,0x62},
+	{0x20DF,0x01},
+	{0x20E0,0x65},
+	{0x20E1,0x00},
+	{0x20E2,0x75},
+	{0x20E3,0x00},
+	{0x20E4,0xE0},
+	{0x20E5,0x00},
+	{0x20E6,0xF0},
+	{0x20E7,0x00},
+	{0x20E8,0x4C},
+	{0x20E9,0x01},
+	{0x20EA,0x5C},
+	{0x20EB,0x01},
+	{0x20EC,0xD1},
+	{0x20ED,0x01},
+	{0x20EE,0xE1},
+	{0x20EF,0x01},
+	{0x20F0,0x93},
+	{0x20F1,0x02},
+	{0x20F2,0xA3},
+	{0x20F3,0x02},
+	{0x20F4,0x0D},
+	{0x20F5,0x03},
+	{0x20F6,0x1D},
+	{0x20F7,0x03},
+	{0x20F8,0x57},
+	{0x20F9,0x00},
+	{0x20FA,0x7B},
+	{0x20FB,0x00},
+	{0x20FC,0xD2},
+	{0x20FD,0x00},
+	{0x20FE,0xF6},
+	{0x20FF,0x00},
+	{0x2100,0x3E},
+	{0x2101,0x01},
+	{0x2102,0x60},
+	{0x2103,0x01},
+	{0x2104,0xC3},
+	{0x2105,0x01},
+	{0x2106,0xE5},
+	{0x2107,0x01},
+	{0x2108,0x85},
+	{0x2109,0x02},
+	{0x210A,0xA9},
+	{0x210B,0x02},
+	{0x210C,0xFF},
+	{0x210D,0x02},
+	{0x210E,0x21},
+	{0x210F,0x03},
+	{0x2110,0xFF},
+	{0x2111,0x03},
+	{0x2112,0x00},
+	{0x2113,0x00},
+	{0x2114,0xFF},
+	{0x2115,0x03},
+	{0x2116,0xFF},
+	{0x2117,0x03},
+	{0x2118,0xFF},
+	{0x2119,0x03},
+	{0x211A,0xFF},
+	{0x211B,0x03},
+	{0x211C,0xFF},
+	{0x211D,0x03},
+	{0x211E,0xFF},
+	{0x211F,0x03},
+	{0x2120,0xFF},
+	{0x2121,0x03},
+	{0x2122,0xFF},
+	{0x2123,0x03},
+	{0x2124,0xFF},
+	{0x2125,0x03},
+	{0x2126,0xFF},
+	{0x2127,0x03},
+	{0x2128,0x7D},
+	{0x2129,0x90},
+	{0x212A,0xD5},
+	{0x212B,0x07},
+	{0x212C,0x64},
+	{0x212D,0x01},
+	{0x2130,0x5F},
+	{0x2131,0x7D},
+	{0x2132,0x05},
+	{0x2134,0x78},
+	{0x2135,0x00},
+	{0x2136,0x76},
+	{0x2137,0x00},
+	{0x2138,0xF3},
+	{0x2139,0x00},
+	{0x213A,0xF1},
+	{0x213B,0x00},
+	{0x213C,0xA6},
+	{0x213D,0x02},
+	{0x213E,0xA4},
+	{0x213F,0x02},
+	{0x2140,0x7D},
+	{0x2141,0x00},
+	{0x2142,0x8D},
+	{0x2143,0x00},
+	{0x2144,0xA1},
+	{0x2145,0x01},
+	{0x2146,0xB1},
+	{0x2147,0x01},
+	{0x2148,0xAB},
+	{0x2149,0x02},
+	{0x214A,0xBB},
+	{0x214B,0x02},
+	{0x214C,0x17},
+	{0x214D,0x5C},
+	{0x214E,0x00},
+	{0x2150,0x00},
+	{0x2151,0x00},
+	{0x2152,0xF8},
+	{0x2153,0x00},
+	{0x2154,0xBE},
+	{0x2155,0x00},
+	{0x2156,0x7D},
+	{0x2157,0x00},
+	{0x2158,0x25},
+	{0x2159,0x00},
+	{0x215A,0x7D},
+	{0x215B,0x00},
+	{0x215C,0x62},
+	{0x215D,0x01},
+	{0x215E,0xFF},
+	{0x215F,0x03},
+	{0x2160,0x26},
+	{0x2161,0x00},
+	{0x2162,0x7D},
+	{0x2163,0x00},
+	{0x2164,0x63},
+	{0x2165,0x01},
+	{0x2166,0xFF},
+	{0x2167,0x03},
+	{0x2168,0xCB},
+	{0x2169,0x02},
+	{0x216A,0xCF},
+	{0x216B,0x02},
+	{0x216C,0xFF},
+	{0x216D,0x03},
+	{0x216E,0xFF},
+	{0x216F,0x03},
+	{0x2170,0xFF},
+	{0x2171,0x03},
+	{0x2172,0xFF},
+	{0x2173,0x03},
+	{0x2174,0xFF},
+	{0x2175,0x03},
+	{0x2176,0xFF},
+	{0x2177,0x03},
+	{0x2178,0x7E},
+	{0x2179,0x00},
+	{0x217A,0xBD},
+	{0x217B,0x00},
+	{0x217C,0xEC},
+	{0x217D,0x01},
+	{0x217E,0x7B},
+	{0x217F,0x02},
+	{0x2180,0xD1},
+	{0x2181,0x02},
+	{0x2182,0x25},
+	{0x2183,0x03},
+	{0x2184,0x7F},
+	{0x2185,0x00},
+	{0x2186,0xBD},
+	{0x2187,0x00},
+	{0x2188,0xED},
+	{0x2189,0x01},
+	{0x218A,0x7B},
+	{0x218B,0x02},
+	{0x218C,0xD2},
+	{0x218D,0x02},
+	{0x218E,0x25},
+	{0x218F,0x03},
+	{0x2190,0xFF},
+	{0x2191,0x03},
+	{0x2192,0xFF},
+	{0x2193,0x03},
+	{0x2194,0xE9},
+	{0x2195,0x01},
+	{0x2196,0x21},
+	{0x2197,0x03},
+	{0x2198,0x17},
+	{0x2199,0xFC},
+	{0x219A,0x7F},
+	{0x219B,0x01},
+	{0x219C,0xFF},
+	{0x219D,0x03},
+	{0x21A0,0x1B},
+	{0x21A1,0x1B},
+	{0x21A2,0x1B},
+	{0x21A3,0x1B},
+	{0x21A4,0x2E},
+	{0x21A5,0x80},
+	{0x21A6,0x00},
+	{0x21A8,0x04},
+	{0x21A9,0x98},
+	{0x21AA,0x60},
+	{0x21AB,0x03},
+	{0x21AC,0x7F},
+	{0x21AD,0x80},
+	{0x21AE,0x09},
+	{0x21B0,0x1C},
+	{0x21B1,0x00},
+	{0x21B2,0xA0},
+	{0x21B3,0x00},
+	{0x21B4,0x0C},
+	{0x21B5,0x00},
+	{0x21B6,0x2D},
+	{0x21B7,0x00},
+	{0x21B8,0x20},
+	{0x21B9,0x00},
+	{0x21BA,0x02},
+	{0x21BB,0x00},
+	{0x21BC,0xCC},
+	{0x21BD,0x00},
+	{0x21BE,0x4A},
+	{0x21BF,0x00},
+	{0x21C0,0xD0},
+	{0x21C1,0x00},
+	{0x21C2,0x44},
+	{0x21C3,0x00},
+	{0x21C4,0x00},
+	{0x21C5,0xE0},
+	{0x21C6,0x00},
+	{0x21C8,0x11},
+	{0x21C9,0x00},
+	{0x21CA,0x02},
+	{0x21CC,0x08},
+	{0x21CD,0xC0},
+	{0x21CE,0x0C},
+	{0x21D0,0x44},
+	{0x21D1,0x00},
+	{0x21D2,0x02},
+	{0x21D4,0x02},
+	{0x21D5,0x20},
+	{0x21D6,0x2C},
+	{0x21D8,0xFE},
+	{0x21D9,0x9D},
+	{0x21DA,0xDF},
+	{0x21DB,0x03},
+	{0x21DC,0x62},
+	{0x21DD,0x01},
+	{0x21DE,0x7F},
+	{0x21DF,0x00},
+	{0x21E0,0xB7},
+	{0x21E1,0x01},
+	{0x21E2,0xB5},
+	{0x21E3,0x01},
+	{0x21E4,0xC1},
+	{0x21E5,0x02},
+	{0x21E6,0xBF},
+	{0x21E7,0x02},
+	{0x21E8,0xB3},
+	{0x21E9,0x0D},
+	{0x21EA,0x00},
+	{0x21EB,0x04},
+	{0x21EC,0x90},
+	{0x21ED,0x07},
+	{0x21EE,0x58},
+	{0x21EF,0x04},
+	{0x21F0,0x54},
+	{0x21F1,0x04},
+	{0x21F4,0x02},
+	{0x21F5,0x00},
+	{0x21F6,0x00},
+	{0x21F8,0x3C},
+	{0x21F9,0x00},
+	{0x21FC,0x28},
+	{0x21FD,0x00},
+	{0x21FE,0x3C},
+	{0x21FF,0x00},
+	{0x2200,0x00},
+	{0x2204,0x4C},
+	{0x2205,0x04},
+	{0x2206,0x65},
+	{0x2207,0x04},
+	{0x2208,0x0A},
+	{0x2209,0x00},
+	{0x220C,0x47},
+	{0x220D,0x00},
+	{0x220E,0x1F},
+	{0x220F,0x00},
+	{0x2210,0x17},
+	{0x2211,0x00},
+	{0x2212,0x0F},
+	{0x2213,0x00},
+	{0x2214,0x17},
+	{0x2215,0x00},
+	{0x2216,0x47},
+	{0x2217,0x00},
+	{0x2218,0x0F},
+	{0x2219,0x00},
+	{0x221A,0x0F},
+	{0x221B,0x00},
+	{0x221C,0x03},
+	{0x2220,0x20},
+	{0x2221,0x20},
+	{0x2222,0x22},
+	{0x2223,0x02},
+	{0x2224,0xA7},
+	{0x2225,0xAA},
+	{0x2226,0x80},
+	{0x2227,0x08},
+	{0x2228,0x01},
+	{0x22B2,0x92},
+	{0x22B4,0x20},
+	{0x22B5,0x00},
+	{0x22B6,0x20},
+	{0x22B7,0x00},
+	{0x22B8,0x20},
+	{0x22B9,0x00},
+	{0x22BA,0x20},
+	{0x22BB,0x00},
+	{0x22BC,0x20},
+	{0x22BD,0x00},
+	{0x22BE,0x20},
+	{0x22BF,0x00},
+	{0x22C0,0x20},
+	{0x22C1,0x00},
+	{0x22C2,0x20},
+	{0x22C3,0x00},
+	{0x22C4,0x20},
+	{0x22C5,0x00},
+	{0x22C6,0x20},
+	{0x22C7,0x00},
+	{0x22C8,0x20},
+	{0x22C9,0x00},
+	{0x22CA,0x20},
+	{0x22CB,0x00},
+	{0x22CC,0x20},
+	{0x22CD,0x00},
+	{0x22CE,0x20},
+	{0x22CF,0x00},
+	{0x22DA,0x00},
+	{0x2308,0x01},
+	{0x2311,0x09},
+	{0x2318,0x40},
+	{0x2319,0xCD},
+	{0x231A,0x54},
+	{0x2324,0x10},
+	{0x2325,0x00},
+	{0x2328,0x00},
+	{0x2354,0x0C},
+	{0x23C0,0x5D},
+	{0x244C,0x00},
+	{0x244D,0x02},
+	{0x244E,0x54},
+	{0x244F,0x02},
+	{0x24A0,0x00},
+	{0x24DA,0x6F},
+	{0x24DB,0x00},
+	{0x24DC,0x62},
+	{0x24DD,0x01},
+	{0x24EA,0x32},
+	{0x24EB,0x00},
+	{0x24EC,0xDC},
+	{0x24ED,0x00},
+	{0x24FA,0x32},
+	{0x24FB,0x00},
+	{0x24FC,0xDD},
+	{0x24FD,0x00},
+	{0x254A,0x15},
+	{0x254B,0x01},
+	{0x255A,0x15},
+	{0x255B,0x01},
+	{0x2560,0x01},
+	{0x2561,0x00},
+	{0x2562,0x2A},
+	{0x2563,0x00},
+	{0x2564,0xF8},
+	{0x2565,0x00},
+	{0x2566,0x15},
+	{0x2567,0x01},
+	{0x2568,0x0C},
+	{0x2569,0x02},
+	{0x256A,0x31},
+	{0x256B,0x02},
+	{0x2578,0x90},
+	{0x2579,0x01},
+	{0x257A,0x92},
+	{0x257B,0x01},
+	{0x257C,0xB8},
+	{0x257D,0x02},
+	{0x257E,0xBA},
+	{0x257F,0x02},
+	{0x2584,0x90},
+	{0x2585,0x01},
+	{0x2586,0x92},
+	{0x2587,0x01},
+	{0x2588,0xB8},
+	{0x2589,0x02},
+	{0x258A,0xBA},
+	{0x258B,0x02},
+	{0x26B8,0x10},
+	{0x26B9,0x00},
+	{0x26BA,0x33},
+	{0x26BB,0x00},
+	{0x26BC,0x89},
+	{0x26BD,0x00},
+	{0x26BE,0xB0},
+	{0x26BF,0x00},
+	{0x26C4,0x4E},
+	{0x26C5,0x00},
+	{0x26C8,0xC9},
+	{0x26C9,0x00},
+	{0x26CC,0x35},
+	{0x26CD,0x01},
+	{0x26D0,0xBA},
+	{0x26D1,0x01},
+	{0x26D4,0x7C},
+	{0x26D5,0x02},
+	{0x26D8,0xF6},
+	{0x26D9,0x02},
+	{0x26DE,0x51},
+	{0x26DF,0x00},
+	{0x26E0,0x7F},
+	{0x26E1,0x00},
+	{0x26E2,0xCC},
+	{0x26E3,0x00},
+	{0x26E4,0xF8},
+	{0x26E5,0x00},
+	{0x26E6,0x38},
+	{0x26E7,0x01},
+	{0x26E8,0x65},
+	{0x26E9,0x01},
+	{0x26EA,0xBD},
+	{0x26EB,0x01},
+	{0x26EE,0x7F},
+	{0x26EF,0x02},
+	{0x26F0,0xAB},
+	{0x26F1,0x02},
+	{0x26F2,0xF9},
+	{0x26F3,0x02},
+	{0x2722,0x59},
+	{0x2723,0x02},
+	{0x2938,0x55},
+	{0x2939,0x00},
+	{0x293A,0x17},
+	{0x293B,0x00},
+	{0x293C,0xD0},
+	{0x293D,0x00},
+	{0x293E,0x91},
+	{0x293F,0x00},
+	{0x2940,0x3C},
+	{0x2941,0x01},
+	{0x2942,0x0C},
+	{0x2943,0x01},
+	{0x2944,0xC1},
+	{0x2945,0x01},
+	{0x2946,0x76},
+	{0x2947,0x01},
+	{0x2948,0x83},
+	{0x2949,0x02},
+	{0x294A,0xFB},
+	{0x294B,0x01},
+	{0x294C,0xFD},
+	{0x294D,0x02},
+	{0x294E,0xBF},
+	{0x294F,0x02},
+	{0x2A06,0xFF},
+	{0x2A07,0x03},
+	{0x2A20,0x00},
+	{0x2A21,0x00},
+	{0x2A22,0x7D},
+	{0x2A23,0x00},
+	{0x2B11,0x19},
+	{0x2B13,0x15},
+	{0x2B14,0x14},
+	{0x2B15,0x13},
+	{0x2B16,0x12},
+	{0x2B17,0x11},
+	{0x2B18,0x10},
+	{0x2B19,0x0F},
+	{0x2B1A,0x0E},
+	{0x2B1B,0x0D},
+	{0x2B1C,0x0C},
+	{0x2B1D,0x0B},
+	{0x2B1E,0x0A},
+	{0x2B1F,0x09},
+	{0x2B20,0x08},
+	{0x2B21,0x07},
+	{0x2B22,0x06},
+	{0x2B23,0x05},
+	{0x2B24,0x04},
+	{0x2B25,0x03},
+	{0x2B26,0x03},
+	{0x2B38,0x01},
+	{0x2B45,0xE3},
+	{0x2B50,0x01},
+	{0x2B51,0x00},
+	{0x2B6D,0x47},
+	{0x2B70,0x02},
+	{0x2B71,0x02},
+	{0x2B72,0x02},
+	{0x2B7F,0x7F},
+	{0x2B80,0x94},
+	{0x2B81,0x06},
+	{0x2B87,0x1B},
+	{0x2B88,0x1B},
+	{0x2B89,0x17},
+	{0x2B8A,0x12},
+	{0x2B8B,0x12},
+	{0x2B8D,0x2B},
+	{0x2B8E,0x2B},
+	{0x2B8F,0x2B},
+	{0x2B90,0x7F},
+	{0x2B91,0x1F},
+	{0x2B94,0x7F},
+	{0x2B95,0x27},
+	{0x2B98,0x7F},
+	{0x2B99,0x57},
+	{0x2BA8,0xBC},
+	{0x2BA9,0x62},
+	{0x2BC1,0x70},
+	{0x2BC5,0x80},
+	{0x2BD5,0x30},
+	{0x2BD6,0xF0},
+	{0x2BD8,0xDB},
+	{0x2BD9,0xF6},
+	{0x2BDA,0x63},
+	{0x2BDB,0x0C},
+	{0x2BDC,0x5C},
+	{0x2C98,0xE1},
+	{0x2C99,0x2E},
+	{0x2C9B,0x86},
+	{0x2CA9,0x80},
+	{0x2CAA,0x01},
+	{0x2D39,0x0E},
+	{0x2D54,0x00},
+	{0x2D5B,0x58},
+	{0x3000,0x00},
+	{0x3001,0x00},
+	{0x3002,0x23},
+	{0x3003,0xA1},
+	{0x3004,0x00},
+	{0x3005,0x20},
+	{0x3006,0x84},
+	{0x3007,0x00},
+	{0x3008,0x06},
+	{0x3009,0xB4},
+	{0x300A,0x1F},
+	{0x300B,0x00},
+	{0x300C,0x00},
+	{0x300D,0x1B},
+	{0x300E,0x90},
+	{0x300F,0x97},
+	{0x3010,0x00},
+	{0x3011,0x00},
+	{0x3012,0x21},
+	{0x3013,0x21},
+	{0x3014,0x00},
+	{0x3015,0x20},
+	{0x3016,0x84},
+	{0x3017,0x00},
+	{0x3018,0x30},
+	{0x3019,0x09},
+	{0x301A,0x46},
+	{0x301B,0x00},
+	{0x3070,0xC1},
+	{0x3071,0x81},
+	{0x3072,0x29},
+	{0x3073,0x81},
+	{0x3410,0x90},
+	{0x3411,0x07},
+	{0x3418,0x48},
+	{0x3419,0x04},
+	{0x34C0,0xD3},
+	{0x34C1,0x00},
+	{0x34C2,0xD3},
+	{0x34C3,0x00},
+	{0x34C4,0xD3},
+	{0x34C5,0x00},
+	{0x34C6,0xD3},
+	{0x34C7,0x00},
+	{0x34C8,0xE2},
+	{0x34C9,0x21},
+	{0x34CA,0xE0},
+	{0x34CB,0x1F},
+	{0x34CC,0x06},
+	{0x34CD,0x20},
+	{0x34CE,0x28},
+	{0x34CF,0x1F},
+	{0x3584,0x00},
+	{0x3586,0x00},
+	{0x3587,0x01},
+	{0x3588,0xE6},
+	{0x3589,0x00},
+	{0x3590,0x00},
+	{0x3591,0x00},
+	{0x3594,0x40},
+	{0x3598,0x03},
+	{0x3599,0x00},
+	{0x359A,0x80},
+	{0x359B,0x00},
+	{0x359C,0x00},
+	{0x359D,0x01},
+	{0x359E,0x00},
+	{0x359F,0x02},
+	{0x35A0,0x00},
+	{0x35A1,0x04},
+	{0x35A2,0x20},
+	{0x35A3,0x00},
+	{0x35A4,0x40},
+	{0x35A5,0x00},
+	{0x35A6,0x80},
+	{0x35A7,0x00},
+	{0x35A8,0x00},
+	{0x35A9,0x01},
+	{0x35AA,0x3A},
+	{0x35AB,0x00},
+	{0x35AC,0x80},
+	{0x35AD,0x00},
+	{0x35AE,0x00},
+	{0x35AF,0x01},
+	{0x35B0,0x00},
+	{0x35B1,0x02},
+	{0x35B2,0x00},
+	{0x35B3,0x04},
+	{0x35B4,0x02},
+	{0x35B5,0x00},
+	{0x35B6,0x04},
+	{0x35B7,0x00},
+	{0x35B8,0x08},
+	{0x35B9,0x00},
+	{0x35BA,0x10},
+	{0x35BB,0x00},
+	{0x35BC,0x03},
+	{0x35BD,0x00},
+	{0x35C8,0x00},
+	{0x35C9,0x01},
+	{0x35CA,0x00},
+	{0x35CB,0x04},
+	{0x35CC,0x00},
+	{0x35CD,0x10},
+	{0x35CE,0x00},
+	{0x35CF,0x40},
+	{0x35D0,0x00},
+	{0x35D1,0x0C},
+	{0x35D2,0x00},
+	{0x35D3,0x0C},
+	{0x35D4,0x00},
+	{0x35D5,0x0C},
+	{0x35D6,0x00},
+	{0x35D7,0x0C},
+	{0x35D8,0x00},
+	{0x35D9,0x00},
+	{0x35DA,0x08},
+	{0x35DB,0x00},
+	{0x35DC,0xD8},
+	{0x35DD,0x0E},
+	{0x35F0,0x00},
+	{0x35F1,0x10},
+	{0x35F2,0x00},
+	{0x35F3,0x10},
+	{0x35F4,0x00},
+	{0x35F5,0x10},
+	{0x35F6,0x00},
+	{0x35F7,0x03},
+	{0x35F8,0x00},
+	{0x35F9,0x01},
+	{0x35FA,0x38},
+	{0x35FB,0x00},
+	{0x35FC,0xB3},
+	{0x35FD,0x01},
+	{0x35FE,0x00},
+	{0x35FF,0x00},
+	{0x3600,0x04},
+	{0x3601,0x06},
+	{0x3604,0x03},
+	{0x3605,0x00},
+	{0x3608,0x03},
+	{0x3609,0x00},
+	{0x360C,0x00},
+	{0x360D,0x00},
+	{0x3610,0x10},
+	{0x3611,0x01},
+	{0x3612,0x00},
+	{0x3613,0x00},
+	{0x3614,0x00},
+	{0x3615,0x00},
+	{0x361C,0x00},
+	{0x361D,0x01},
+	{0x361E,0x00},
+	{0x361F,0x01},
+	{0x3620,0x01},
+	{0x3621,0x00},
+	{0x3622,0xB0},
+	{0x3623,0x04},
+	{0x3624,0xDC},
+	{0x3625,0x05},
+	{0x3626,0x00},
+	{0x3627,0x01},
+	{0x3628,0xFF},
+	{0x3629,0x0F},
+	{0x362A,0x00},
+	{0x362B,0x10},
+	{0x362C,0x00},
+	{0x362D,0x01},
+	{0x3630,0x40},
+	{0x3631,0x00},
+	{0x3632,0x40},
+	{0x3633,0x00},
+	{0x3634,0x40},
+	{0x3635,0x00},
+	{0x3636,0x40},
+	{0x3637,0x00},
+	{0x3638,0x40},
+	{0x3639,0x00},
+	{0x363A,0x40},
+	{0x363B,0x00},
+	{0x363C,0x40},
+	{0x363D,0x00},
+	{0x363E,0x40},
+	{0x363F,0x00},
+	{0x36C4,0x99},
+	{0x36C5,0x09},
+	{0x36C6,0x18},
+	{0x36C7,0x07},
+	{0x36C8,0x65},
+	{0x36C9,0x0E},
+	{0x36CC,0x99},
+	{0x36CD,0x01},
+	{0x36CE,0x47},
+	{0x36CF,0x00},
+	{0x36D0,0x04},
+	{0x36D1,0x00},
+	{0x36D4,0x65},
+	{0x36D5,0x0E},
+	{0x36D6,0xA4},
+	{0x36D7,0x0A},
+	{0x36D8,0x65},
+	{0x36D9,0x0E},
+	{0x36DC,0x65},
+	{0x36DD,0x0E},
+	{0x36DE,0xA4},
+	{0x36DF,0x0A},
+	{0x36E0,0x65},
+	{0x36E1,0x0E},
+	{0x36E4,0x65},
+	{0x36E5,0x0E},
+	{0x36E6,0xA4},
+	{0x36E7,0x0A},
+	{0x36E8,0x65},
+	{0x36E9,0x0E},
+	{0x36EE,0x00},
+	{0x36EF,0x00},
+	{0x36F0,0x00},
+	{0x36F1,0x80},
+	{0x36F8,0x00},
+	{0x3702,0x03},
+	{0x3703,0x04},
+	{0x3704,0x08},
+	{0x370E,0x0E},
+	{0x3718,0x62},
+	{0x3719,0x4A},
+	{0x371A,0x38},
+	{0x371B,0x20},
+	{0x371C,0x64},
+	{0x371D,0x42},
+	{0x371E,0x32},
+	{0x371F,0x1B},
+	{0x3720,0x9C},
+	{0x3721,0xA4},
+	{0x3722,0xAC},
+	{0x3723,0xB4},
+	{0x3748,0xAA},
+	{0x3749,0x96},
+	{0x374A,0x7D},
+	{0x374B,0x69},
+	{0x37C0,0x00},
+	{0x37C1,0x00},
+	{0x37C2,0x00},
+	{0x37C4,0x00},
+	{0x37C5,0x00},
+	{0x37C6,0x00},
+	{0x37C8,0x00},
+	{0x37C9,0x00},
+	{0x37CA,0x00},
+	{0x37CC,0x00},
+	{0x37CD,0x00},
+	{0x37CE,0x00},
+	{0x37D0,0x00},
+	{0x37D1,0x00},
+	{0x37D2,0x00},
+	{0x37D4,0x00},
+	{0x37D5,0x00},
+	{0x37D6,0x00},
+	{0x37D8,0x00},
+	{0x37D9,0x00},
+	{0x37DA,0x00},
+	{0x37DC,0x00},
+	{0x37DD,0x00},
+	{0x37DE,0x00},
+	{0x37E0,0x00},
+	{0x37E1,0x00},
+	{0x37E2,0x00},
+	{0x37E4,0x00},
+	{0x37E5,0x00},
+	{0x37E6,0x00},
+	{0x37E8,0x00},
+	{0x37E9,0x00},
+	{0x37EA,0x00},
+	{0x37EC,0x00},
+	{0x37ED,0x00},
+	{0x37EE,0x00},
+	{0x37F0,0x00},
+	{0x37F4,0x00},
+	{0x37F5,0x1E},
+	{0x37F6,0x34},
+	{0x37F7,0x00},
+	{0x37F8,0xFF},
+	{0x37F9,0xFF},
+	{0x37FA,0x03},
+	{0x37FC,0x00},
+	{0x37FD,0x00},
+	{0x37FE,0x04},
+	{0x3800,0xFF},
+	{0x3801,0xFF},
+	{0x3802,0x03},
+	{0x3804,0x00},
+	{0x3805,0x00},
+	{0x3806,0x04},
+	{0x3808,0x00},
+	{0x3809,0x00},
+	{0x380A,0x00},
+	{0x380C,0x00},
+	{0x380D,0x00},
+	{0x380E,0x00},
+	{0x3810,0x00},
+	{0x3811,0x00},
+	{0x3812,0x00},
+	{0x3814,0x00},
+	{0x3815,0x00},
+	{0x3816,0x00},
+	{0x3818,0x00},
+	{0x3819,0x00},
+	{0x381A,0x00},
+	{0x381C,0x00},
+	{0x381D,0x00},
+	{0x381E,0x00},
+	{0x3820,0x00},
+	{0x3821,0x00},
+	{0x3822,0x00},
+	{0x3824,0x00},
+	{0x3825,0x00},
+	{0x3826,0x00},
+	{0x3828,0x00},
+	{0x3829,0x00},
+	{0x382A,0x00},
+	{0x382C,0x00},
+	{0x382D,0x00},
+	{0x382E,0x00},
+	{0x3830,0x00},
+	{0x3831,0x00},
+	{0x3832,0x00},
+	{0x3834,0x00},
+	{0x3835,0x00},
+	{0x3836,0x00},
+	{0x3838,0x00},
+	{0x3839,0x00},
+	{0x383A,0x00},
+	{0x383B,0x00},
+	{0x383C,0x00},
+	{0x383D,0x00},
+	{0x383E,0x00},
+	{0x383F,0x00},
+	{0x3840,0x00},
+	{0x3841,0x00},
+	{0x3842,0x00},
+	{0x3843,0x00},
+	{0x3844,0x00},
+	{0x3845,0x00},
+	{0x3846,0x00},
+	{0x3847,0x00},
+	{0x3848,0x00},
+	{0x3849,0x00},
+	{0x384A,0x00},
+	{0x384B,0x00},
+	{0x384C,0x00},
+	{0x384D,0x00},
+	{0x384E,0x00},
+	{0x384F,0x00},
+	{0x3850,0xFF},
+	{0x3851,0x0F},
+	{0x3852,0x00},
+	{0x3853,0x10},
+	{0x3854,0xFF},
+	{0x3855,0x0F},
+	{0x3856,0x00},
+	{0x3857,0x10},
+	{0x3858,0xFF},
+	{0x3859,0x0F},
+	{0x385A,0x00},
+	{0x385B,0x10},
+	{0x385C,0x02},
+	{0x385D,0x00},
+	{0x385E,0x06},
+	{0x385F,0x00},
+	{0x3860,0x06},
+	{0x3861,0x00},
+	{0x3862,0x08},
+	{0x3863,0x00},
+	{0x3864,0x02},
+	{0x3865,0x00},
+	{0x38A0,0x01},
+	{0x38A1,0x01},
+	{0x38A2,0x00},
+	{0x38A3,0x01},
+	{0x38A4,0x07},
+	{0x38A5,0x00},
+	{0x38A6,0x04},
+	{0x38A7,0x05},
+	{0x38A8,0x00},
+	{0x38A9,0x00},
+	{0x38AC,0x00},
+	{0x38AD,0x00},
+	{0x38AE,0x01},
+	{0x38B0,0x02},
+	{0x38B2,0x22},
+	{0x38B3,0x00},
+	{0x38B4,0x17},
+	{0x38B5,0x00},
+	{0x38B6,0x11},
+	{0x38B7,0x00},
+	{0x38B8,0x0E},
+	{0x38B9,0x00},
+	{0x38BA,0x2A},
+	{0x38BB,0x00},
+	{0x38BC,0x1C},
+	{0x38BD,0x00},
+	{0x38BE,0x14},
+	{0x38BF,0x00},
+	{0x38C0,0x10},
+	{0x38C1,0x00},
+	{0x38C2,0x31},
+	{0x38C3,0x00},
+	{0x38C4,0x21},
+	{0x38C5,0x00},
+	{0x38C6,0x18},
+	{0x38C7,0x00},
+	{0x38C8,0x12},
+	{0x38C9,0x00},
+	{0x38CA,0x3C},
+	{0x38CB,0x00},
+	{0x38CC,0x29},
+	{0x38CD,0x00},
+	{0x38CE,0x1D},
+	{0x38CF,0x00},
+	{0x38D0,0x15},
+	{0x38D1,0x00},
+	{0x38D2,0x4E},
+	{0x38D3,0x00},
+	{0x38D4,0x35},
+	{0x38D5,0x00},
+	{0x38D6,0x26},
+	{0x38D7,0x00},
+	{0x38D8,0x1A},
+	{0x38D9,0x00},
+	{0x38DA,0x69},
+	{0x38DB,0x00},
+	{0x38DC,0x48},
+	{0x38DD,0x00},
+	{0x38DE,0x33},
+	{0x38DF,0x00},
+	{0x38E0,0x22},
+	{0x38E1,0x00},
+	{0x38E2,0x93},
+	{0x38E3,0x00},
+	{0x38E4,0x64},
+	{0x38E5,0x00},
+	{0x38E6,0x48},
+	{0x38E7,0x00},
+	{0x38E8,0x30},
+	{0x38E9,0x00},
+	{0x38EA,0xD3},
+	{0x38EB,0x00},
+	{0x38EC,0x90},
+	{0x38ED,0x00},
+	{0x38EE,0x69},
+	{0x38EF,0x00},
+	{0x38F0,0x49},
+	{0x38F1,0x00},
+	{0x38F2,0x39},
+	{0x38F3,0x01},
+	{0x38F4,0xD5},
+	{0x38F5,0x00},
+	{0x38F6,0x9F},
+	{0x38F7,0x00},
+	{0x38F8,0x75},
+	{0x38F9,0x00},
+	{0x38FA,0x00},
+	{0x38FB,0x01},
+	{0x38FC,0x00},
+	{0x38FD,0x01},
+	{0x38FE,0x00},
+	{0x38FF,0x01},
+	{0x3900,0x00},
+	{0x3901,0x01},
+	{0x3902,0x70},
+	{0x3903,0x00},
+	{0x3904,0x30},
+	{0x3905,0x00},
+	{0x3906,0x25},
+	{0x3907,0x00},
+	{0x3908,0x20},
+	{0x3909,0x00},
+	{0x390A,0xB2},
+	{0x390B,0x00},
+	{0x390C,0x80},
+	{0x390D,0x00},
+	{0x390E,0x70},
+	{0x390F,0x00},
+	{0x3910,0x50},
+	{0x3911,0x00},
+	{0x3912,0xB2},
+	{0x3913,0x00},
+	{0x3914,0x80},
+	{0x3915,0x00},
+	{0x3916,0x70},
+	{0x3917,0x00},
+	{0x3918,0x50},
+	{0x3919,0x00},
+	{0x391A,0xB2},
+	{0x391B,0x00},
+	{0x391C,0x80},
+	{0x391D,0x00},
+	{0x391E,0x70},
+	{0x391F,0x00},
+	{0x3920,0x50},
+	{0x3921,0x00},
+	{0x3922,0x40},
+	{0x3923,0x00},
+	{0x3924,0x40},
+	{0x3925,0x00},
+	{0x3926,0x40},
+	{0x3927,0x00},
+	{0x3928,0x40},
+	{0x3929,0x00},
+	{0x392A,0x80},
+	{0x392B,0x00},
+	{0x392C,0x80},
+	{0x392D,0x00},
+	{0x392E,0x80},
+	{0x392F,0x00},
+	{0x3930,0x80},
+	{0x3931,0x00},
+	{0x3932,0x80},
+	{0x3933,0x80},
+	{0x3934,0x80},
+	{0x3940,0x01},
+	{0x3941,0x01},
+	{0x3942,0x00},
+	{0x3943,0x01},
+	{0x3944,0x07},
+	{0x3945,0x00},
+	{0x3946,0x04},
+	{0x3947,0x05},
+	{0x3948,0x00},
+	{0x3949,0x00},
+	{0x394C,0x00},
+	{0x394D,0x00},
+	{0x394E,0x01},
+	{0x3950,0x03},
+	{0x3952,0x14},
+	{0x3953,0x00},
+	{0x3954,0x0F},
+	{0x3955,0x00},
+	{0x3956,0x0E},
+	{0x3957,0x00},
+	{0x3958,0x0E},
+	{0x3959,0x00},
+	{0x395A,0x19},
+	{0x395B,0x00},
+	{0x395C,0x11},
+	{0x395D,0x00},
+	{0x395E,0x0F},
+	{0x395F,0x00},
+	{0x3960,0x0E},
+	{0x3961,0x00},
+	{0x3962,0x1C},
+	{0x3963,0x00},
+	{0x3964,0x13},
+	{0x3965,0x00},
+	{0x3966,0x0F},
+	{0x3967,0x00},
+	{0x3968,0x0E},
+	{0x3969,0x00},
+	{0x396A,0x23},
+	{0x396B,0x00},
+	{0x396C,0x15},
+	{0x396D,0x00},
+	{0x396E,0x11},
+	{0x396F,0x00},
+	{0x3970,0x0E},
+	{0x3971,0x00},
+	{0x3972,0x2E},
+	{0x3973,0x00},
+	{0x3974,0x1A},
+	{0x3975,0x00},
+	{0x3976,0x14},
+	{0x3977,0x00},
+	{0x3978,0x0F},
+	{0x3979,0x00},
+	{0x397A,0x3E},
+	{0x397B,0x00},
+	{0x397C,0x23},
+	{0x397D,0x00},
+	{0x397E,0x1A},
+	{0x397F,0x00},
+	{0x3980,0x12},
+	{0x3981,0x00},
+	{0x3982,0x56},
+	{0x3983,0x00},
+	{0x3984,0x31},
+	{0x3985,0x00},
+	{0x3986,0x25},
+	{0x3987,0x00},
+	{0x3988,0x1A},
+	{0x3989,0x00},
+	{0x398A,0x7B},
+	{0x398B,0x00},
+	{0x398C,0x49},
+	{0x398D,0x00},
+	{0x398E,0x39},
+	{0x398F,0x00},
+	{0x3990,0x2C},
+	{0x3991,0x00},
+	{0x3992,0xB4},
+	{0x3993,0x00},
+	{0x3994,0x75},
+	{0x3995,0x00},
+	{0x3996,0x61},
+	{0x3997,0x00},
+	{0x3998,0x53},
+	{0x3999,0x00},
+	{0x399A,0x00},
+	{0x399B,0x01},
+	{0x399C,0x00},
+	{0x399D,0x01},
+	{0x399E,0x00},
+	{0x399F,0x01},
+	{0x39A0,0x00},
+	{0x39A1,0x01},
+	{0x39A2,0x70},
+	{0x39A3,0x00},
+	{0x39A4,0x30},
+	{0x39A5,0x00},
+	{0x39A6,0x25},
+	{0x39A7,0x00},
+	{0x39A8,0x20},
+	{0x39A9,0x00},
+	{0x39AA,0xB2},
+	{0x39AB,0x00},
+	{0x39AC,0x80},
+	{0x39AD,0x00},
+	{0x39AE,0x70},
+	{0x39AF,0x00},
+	{0x39B0,0x80},
+	{0x39B1,0x00},
+	{0x39B2,0xB2},
+	{0x39B3,0x00},
+	{0x39B4,0x80},
+	{0x39B5,0x00},
+	{0x39B6,0x70},
+	{0x39B7,0x00},
+	{0x39B8,0x80},
+	{0x39B9,0x00},
+	{0x39BA,0xB2},
+	{0x39BB,0x00},
+	{0x39BC,0x80},
+	{0x39BD,0x00},
+	{0x39BE,0x70},
+	{0x39BF,0x00},
+	{0x39C0,0x80},
+	{0x39C1,0x00},
+	{0x39C2,0x40},
+	{0x39C3,0x00},
+	{0x39C4,0x40},
+	{0x39C5,0x00},
+	{0x39C6,0x40},
+	{0x39C7,0x00},
+	{0x39C8,0x40},
+	{0x39C9,0x00},
+	{0x39CA,0x80},
+	{0x39CB,0x00},
+	{0x39CC,0x80},
+	{0x39CD,0x00},
+	{0x39CE,0x80},
+	{0x39CF,0x00},
+	{0x39D0,0x80},
+	{0x39D1,0x00},
+	{0x39D2,0x80},
+	{0x39D3,0x80},
+	{0x39D4,0x80},
+	{0x39E0,0x01},
+	{0x39E1,0x00},
+	{0x39E4,0x40},
+	{0x39E5,0x01},
+	{0x39E6,0x01},
+	{0x39E8,0x00},
+	{0x39E9,0x01},
+	{0x39EA,0x00},
+	{0x39EB,0x00},
+	{0x39EC,0x01},
+	{0x39ED,0x00},
+	{0x39EE,0x01},
+	{0x39F0,0x03},
+	{0x39F1,0x04},
+	{0x39F2,0x0E},
+	{0x39F4,0x1C},
+	{0x39F5,0x00},
+	{0x39F6,0x13},
+	{0x39F7,0x00},
+	{0x39F8,0x0D},
+	{0x39F9,0x00},
+	{0x39FA,0x07},
+	{0x39FB,0x00},
+	{0x39FC,0x38},
+	{0x39FD,0x00},
+	{0x39FE,0x1C},
+	{0x39FF,0x00},
+	{0x3A00,0x11},
+	{0x3A01,0x00},
+	{0x3A02,0x08},
+	{0x3A03,0x00},
+	{0x3A04,0x4A},
+	{0x3A05,0x00},
+	{0x3A06,0x23},
+	{0x3A07,0x00},
+	{0x3A08,0x15},
+	{0x3A09,0x00},
+	{0x3A0A,0x09},
+	{0x3A0B,0x00},
+	{0x3A0C,0x65},
+	{0x3A0D,0x00},
+	{0x3A0E,0x2D},
+	{0x3A0F,0x00},
+	{0x3A10,0x1A},
+	{0x3A11,0x00},
+	{0x3A12,0x0B},
+	{0x3A13,0x00},
+	{0x3A14,0x8D},
+	{0x3A15,0x00},
+	{0x3A16,0x3D},
+	{0x3A17,0x00},
+	{0x3A18,0x23},
+	{0x3A19,0x00},
+	{0x3A1A,0x0E},
+	{0x3A1B,0x00},
+	{0x3A1C,0xC5},
+	{0x3A1D,0x00},
+	{0x3A1E,0x55},
+	{0x3A1F,0x00},
+	{0x3A20,0x30},
+	{0x3A21,0x00},
+	{0x3A22,0x13},
+	{0x3A23,0x00},
+	{0x3A24,0x16},
+	{0x3A25,0x01},
+	{0x3A26,0x76},
+	{0x3A27,0x00},
+	{0x3A28,0x42},
+	{0x3A29,0x00},
+	{0x3A2A,0x1A},
+	{0x3A2B,0x00},
+	{0x3A2C,0x88},
+	{0x3A2D,0x01},
+	{0x3A2E,0xA7},
+	{0x3A2F,0x00},
+	{0x3A30,0x5D},
+	{0x3A31,0x00},
+	{0x3A32,0x24},
+	{0x3A33,0x00},
+	{0x3A34,0x2A},
+	{0x3A35,0x02},
+	{0x3A36,0xEB},
+	{0x3A37,0x00},
+	{0x3A38,0x83},
+	{0x3A39,0x00},
+	{0x3A3A,0x32},
+	{0x3A3B,0x00},
+	{0x3A3C,0x00},
+	{0x3A3D,0x01},
+	{0x3A3E,0x00},
+	{0x3A3F,0x01},
+	{0x3A40,0x00},
+	{0x3A41,0x01},
+	{0x3A42,0x00},
+	{0x3A43,0x01},
+	{0x3A44,0x80},
+	{0x3A45,0x00},
+	{0x3A46,0x50},
+	{0x3A47,0x00},
+	{0x3A48,0x30},
+	{0x3A49,0x00},
+	{0x3A4A,0x20},
+	{0x3A4B,0x00},
+	{0x3A4C,0x99},
+	{0x3A4D,0x00},
+	{0x3A4E,0x80},
+	{0x3A4F,0x00},
+	{0x3A50,0x80},
+	{0x3A51,0x00},
+	{0x3A52,0x80},
+	{0x3A53,0x00},
+	{0x3A54,0x99},
+	{0x3A55,0x00},
+	{0x3A56,0x80},
+	{0x3A57,0x00},
+	{0x3A58,0x80},
+	{0x3A59,0x00},
+	{0x3A5A,0x80},
+	{0x3A5B,0x00},
+	{0x3A5C,0x99},
+	{0x3A5D,0x00},
+	{0x3A5E,0x80},
+	{0x3A5F,0x00},
+	{0x3A60,0x80},
+	{0x3A61,0x00},
+	{0x3A62,0x80},
+	{0x3A63,0x00},
+	{0x3A64,0x1C},
+	{0x3A65,0x00},
+	{0x3A66,0x13},
+	{0x3A67,0x00},
+	{0x3A68,0x0D},
+	{0x3A69,0x00},
+	{0x3A6A,0x07},
+	{0x3A6B,0x00},
+	{0x3A6C,0x0C},
+	{0x3A6D,0x00},
+	{0x3A6E,0x09},
+	{0x3A6F,0x00},
+	{0x3A70,0x06},
+	{0x3A71,0x00},
+	{0x3A72,0x03},
+	{0x3A73,0x00},
+	{0x3A74,0x1F},
+	{0x3A75,0x00},
+	{0x3A76,0x1B},
+	{0x3A77,0x00},
+	{0x3A78,0x0F},
+	{0x3A79,0x00},
+	{0x3A7A,0x08},
+	{0x3A7B,0x00},
+	{0x3A7C,0x80},
+	{0x3A7D,0x00},
+	{0x3A7E,0x80},
+	{0x3A7F,0x00},
+	{0x3A80,0x80},
+	{0x3A81,0x00},
+	{0x3A82,0x80},
+	{0x3A83,0x00},
+	{0x3A84,0x09},
+	{0x3A85,0x00},
+	{0x3A86,0x04},
+	{0x3A87,0x00},
+	{0x3A88,0x03},
+	{0x3A89,0x00},
+	{0x3A8A,0x01},
+	{0x3A8B,0x00},
+	{0x3A8C,0x19},
+	{0x3A8D,0x01},
+	{0x3A8E,0xD2},
+	{0x3A8F,0x00},
+	{0x3A90,0x8C},
+	{0x3A91,0x00},
+	{0x3A92,0x64},
+	{0x3A93,0x00},
+	{0x3A94,0xFF},
+	{0x3A95,0x00},
+	{0x3A96,0xD2},
+	{0x3A97,0x00},
+	{0x3A98,0x8C},
+	{0x3A99,0x00},
+	{0x3A9A,0x64},
+	{0x3A9B,0x00},
+	{0x3A9C,0x08},
+	{0x3A9D,0x10},
+	{0x3A9E,0x80},
+	{0x3A9F,0x80},
+	{0x3AA0,0x80},
+	{0x3AA1,0x04},
+	{0x3AA2,0x05},
+	{0x3AC0,0x01},
+	{0x3AC4,0x81},
+	{0x3AC5,0x00},
+	{0x3AC6,0x00},
+	{0x3AC7,0x00},
+	{0x3AC8,0x00},
+	{0x3AC9,0x00},
+	{0x3ACA,0x00},
+	{0x3ACB,0x00},
+	{0x3ACC,0x02},
+	{0x3ACD,0x00},
+	{0x3ACE,0x81},
+	{0x3ACF,0x00},
+	{0x3AD0,0x00},
+	{0x3AD1,0x00},
+	{0x3AD2,0xFD},
+	{0x3AD3,0x03},
+	{0x3AD4,0x02},
+	{0x3AD5,0x00},
+	{0x3AD6,0x00},
+	{0x3AD7,0x00},
+	{0x3AD8,0x81},
+	{0x3AD9,0x00},
+	{0x3ADA,0xFD},
+	{0x3ADB,0x03},
+	{0x3ADC,0xFF},
+	{0x3ADD,0x03},
+	{0x3ADE,0x01},
+	{0x3ADF,0x00},
+	{0x3AE0,0x01},
+	{0x3AE1,0x00},
+	{0x3AE2,0x7E},
+	{0x3AE3,0x00},
+	{0x3AF4,0x00},
+	{0x3AF6,0x40},
+	{0x3AF7,0x1E},
+	{0x3AF8,0x01},
+	{0x3AFA,0x63},
+	{0x3AFB,0x09},
+	{0x3AFC,0x11},
+	{0x3AFD,0x09},
+	{0x3AFE,0x00},
+	{0x3AFF,0x00},
+	{0x3B00,0x00},
+	{0x3B01,0x00},
+	{0x3B02,0x84},
+	{0x3B03,0x06},
+	{0x3B04,0x30},
+	{0x3B05,0x06},
+	{0x3B06,0x00},
+	{0x3B07,0x00},
+	{0x3B08,0x00},
+	{0x3B09,0x00},
+	{0x3B0A,0x00},
+	{0x3B0B,0x00},
+	{0x3B0C,0x00},
+	{0x3B0D,0x00},
+	{0x3B0E,0x00},
+	{0x3B0F,0x00},
+	{0x3B10,0x00},
+	{0x3B11,0x00},
+	{0x3B12,0x00},
+	{0x3B13,0x00},
+	{0x3B14,0x00},
+	{0x3B15,0x00},
+	{0x3B16,0x00},
+	{0x3B17,0x00},
+	{0x3B18,0x00},
+	{0x3B19,0x00},
+	{0x3B1A,0x00},
+	{0x3B1B,0x00},
+	{0x3B1C,0x00},
+	{0x3B1D,0x00},
+	{0x3B1E,0x00},
+	{0x3B1F,0x00},
+	{0x3B20,0x00},
+	{0x3B21,0x00},
+	{0x3B22,0x00},
+	{0x3B23,0x00},
+	{0x3B24,0x00},
+	{0x3B25,0x00},
+	{0x3B26,0x00},
+	{0x3B27,0x00},
+	{0x3B28,0x00},
+	{0x3B29,0x00},
+	{0x3B2A,0x00},
+	{0x3B2C,0x00},
+	{0x3B2E,0x00},
+	{0x3B30,0x00},
+	{0x3B32,0x0C},
+	{0x4000,0xD1},
+	{0x4001,0xC0},
+	{0x4002,0xC0},
+	{0x4003,0xB8},
+	{0x4004,0xC0},
+	{0x4005,0xB8},
+	{0x4006,0xB9},
+	{0x4007,0xB7},
+	{0x4008,0xB0},
+	{0x4009,0xAB},
+	{0x400A,0xAC},
+	{0x400B,0xAB},
+	{0x400C,0xA8},
+	{0x400D,0xA6},
+	{0x400E,0xA6},
+	{0x400F,0xA5},
+	{0x4010,0xA2},
+	{0x4011,0xA0},
+	{0x4012,0xA0},
+	{0x4013,0x9F},
+	{0x4014,0xA4},
+	{0x4015,0xA2},
+	{0x4016,0xA2},
+	{0x4017,0x9C},
+	{0x4018,0xA8},
+	{0x4019,0xA6},
+	{0x401A,0xA8},
+	{0x401B,0xAA},
+	{0x401C,0xB0},
+	{0x401D,0xAE},
+	{0x401E,0xAE},
+	{0x401F,0xAE},
+	{0x4020,0xBA},
+	{0x4021,0xAE},
+	{0x4022,0xAF},
+	{0x4023,0xAE},
+	{0x4024,0xC6},
+	{0x4025,0xBD},
+	{0x4026,0xBD},
+	{0x4027,0xBA},
+	{0x4028,0xB0},
+	{0x4029,0xA9},
+	{0x402A,0xAA},
+	{0x402B,0xA8},
+	{0x402C,0x9F},
+	{0x402D,0x9C},
+	{0x402E,0x9C},
+	{0x402F,0x9B},
+	{0x4030,0x93},
+	{0x4031,0x91},
+	{0x4032,0x92},
+	{0x4033,0x91},
+	{0x4034,0x8D},
+	{0x4035,0x8C},
+	{0x4036,0x8C},
+	{0x4037,0x8C},
+	{0x4038,0x8F},
+	{0x4039,0x8E},
+	{0x403A,0x8E},
+	{0x403B,0x8E},
+	{0x403C,0x98},
+	{0x403D,0x96},
+	{0x403E,0x96},
+	{0x403F,0x95},
+	{0x4040,0xA4},
+	{0x4041,0xA0},
+	{0x4042,0xA0},
+	{0x4043,0x9E},
+	{0x4044,0xB3},
+	{0x4045,0xAE},
+	{0x4046,0xAF},
+	{0x4047,0xAB},
+	{0x4048,0xC2},
+	{0x4049,0xB7},
+	{0x404A,0xB8},
+	{0x404B,0xB5},
+	{0x404C,0xAB},
+	{0x404D,0xA4},
+	{0x404E,0xA5},
+	{0x404F,0xA3},
+	{0x4050,0x99},
+	{0x4051,0x96},
+	{0x4052,0x96},
+	{0x4053,0x96},
+	{0x4054,0x8B},
+	{0x4055,0x8A},
+	{0x4056,0x8A},
+	{0x4057,0x8A},
+	{0x4058,0x82},
+	{0x4059,0x81},
+	{0x405A,0x81},
+	{0x405B,0x81},
+	{0x405C,0x85},
+	{0x405D,0x86},
+	{0x405E,0x85},
+	{0x405F,0x85},
+	{0x4060,0x90},
+	{0x4061,0x90},
+	{0x4062,0x8F},
+	{0x4063,0x8F},
+	{0x4064,0x9D},
+	{0x4065,0x9B},
+	{0x4066,0x9B},
+	{0x4067,0x9A},
+	{0x4068,0xAF},
+	{0x4069,0xAA},
+	{0x406A,0xAC},
+	{0x406B,0xAA},
+	{0x406C,0xC2},
+	{0x406D,0xB7},
+	{0x406E,0xB8},
+	{0x406F,0xB5},
+	{0x4070,0xAB},
+	{0x4071,0xA4},
+	{0x4072,0xA4},
+	{0x4073,0xA3},
+	{0x4074,0x99},
+	{0x4075,0x96},
+	{0x4076,0x96},
+	{0x4077,0x96},
+	{0x4078,0x8B},
+	{0x4079,0x8A},
+	{0x407A,0x8A},
+	{0x407B,0x8A},
+	{0x407C,0x82},
+	{0x407D,0x82},
+	{0x407E,0x82},
+	{0x407F,0x82},
+	{0x4080,0x85},
+	{0x4081,0x86},
+	{0x4082,0x86},
+	{0x4083,0x86},
+	{0x4084,0x90},
+	{0x4085,0x90},
+	{0x4086,0x8F},
+	{0x4087,0x8F},
+	{0x4088,0x9D},
+	{0x4089,0x9B},
+	{0x408A,0x9B},
+	{0x408B,0x99},
+	{0x408C,0xAE},
+	{0x408D,0xAA},
+	{0x408E,0xAA},
+	{0x408F,0xA7},
+	{0x4090,0xC7},
+	{0x4091,0xBA},
+	{0x4092,0xBC},
+	{0x4093,0xB9},
+	{0x4094,0xB1},
+	{0x4095,0xA8},
+	{0x4096,0xA8},
+	{0x4097,0xA7},
+	{0x4098,0x9F},
+	{0x4099,0x9B},
+	{0x409A,0x9B},
+	{0x409B,0x9B},
+	{0x409C,0x93},
+	{0x409D,0x91},
+	{0x409E,0x91},
+	{0x409F,0x91},
+	{0x40A0,0x8D},
+	{0x40A1,0x8C},
+	{0x40A2,0x8C},
+	{0x40A3,0x8C},
+	{0x40A4,0x8E},
+	{0x40A5,0x8E},
+	{0x40A6,0x8D},
+	{0x40A7,0x8D},
+	{0x40A8,0x96},
+	{0x40A9,0x95},
+	{0x40AA,0x95},
+	{0x40AB,0x94},
+	{0x40AC,0xA2},
+	{0x40AD,0x9F},
+	{0x40AE,0x9F},
+	{0x40AF,0x9D},
+	{0x40B0,0xB1},
+	{0x40B1,0xAC},
+	{0x40B2,0xAB},
+	{0x40B3,0xAA},
+	{0x40B4,0xD3},
+	{0x40B5,0xBC},
+	{0x40B6,0xBD},
+	{0x40B7,0xBC},
+	{0x40B8,0xC1},
+	{0x40B9,0xB7},
+	{0x40BA,0xB7},
+	{0x40BB,0xB5},
+	{0x40BC,0xB0},
+	{0x40BD,0xAA},
+	{0x40BE,0xAA},
+	{0x40BF,0xAA},
+	{0x40C0,0xA8},
+	{0x40C1,0xA4},
+	{0x40C2,0xA4},
+	{0x40C3,0xA4},
+	{0x40C4,0xA2},
+	{0x40C5,0x9F},
+	{0x40C6,0x9F},
+	{0x40C7,0x9F},
+	{0x40C8,0xA3},
+	{0x40C9,0xA0},
+	{0x40CA,0xA0},
+	{0x40CB,0xA0},
+	{0x40CC,0xA6},
+	{0x40CD,0xA3},
+	{0x40CE,0xA3},
+	{0x40CF,0xA2},
+	{0x40D0,0xAF},
+	{0x40D1,0xAB},
+	{0x40D2,0xAA},
+	{0x40D3,0xA8},
+	{0x40D4,0xBA},
+	{0x40D5,0xAE},
+	{0x40D6,0xAE},
+	{0x40D7,0xAB},
+	{0x4100,0xBD},
+	{0x4101,0xBA},
+	{0x4102,0xBD},
+	{0x4103,0xB7},
+	{0x4104,0xB7},
+	{0x4105,0xB7},
+	{0x4106,0xB8},
+	{0x4107,0xB5},
+	{0x4108,0xAB},
+	{0x4109,0xAA},
+	{0x410A,0xAC},
+	{0x410B,0xAB},
+	{0x410C,0xA4},
+	{0x410D,0xA5},
+	{0x410E,0xA5},
+	{0x410F,0xA4},
+	{0x4110,0x9F},
+	{0x4111,0xA0},
+	{0x4112,0xA0},
+	{0x4113,0x9F},
+	{0x4114,0xA0},
+	{0x4115,0xA0},
+	{0x4116,0xA0},
+	{0x4117,0x9F},
+	{0x4118,0xA1},
+	{0x4119,0xA1},
+	{0x411A,0xA1},
+	{0x411B,0xA0},
+	{0x411C,0xA7},
+	{0x411D,0xA6},
+	{0x411E,0xA6},
+	{0x411F,0xA6},
+	{0x4120,0xA7},
+	{0x4121,0xA6},
+	{0x4122,0xA6},
+	{0x4123,0xA3},
+	{0x4124,0xB9},
+	{0x4125,0xB9},
+	{0x4126,0xBA},
+	{0x4127,0xB8},
+	{0x4128,0xA6},
+	{0x4129,0xA7},
+	{0x412A,0xA7},
+	{0x412B,0xA6},
+	{0x412C,0x9B},
+	{0x412D,0x9B},
+	{0x412E,0x9B},
+	{0x412F,0x9B},
+	{0x4130,0x91},
+	{0x4131,0x92},
+	{0x4132,0x92},
+	{0x4133,0x91},
+	{0x4134,0x8C},
+	{0x4135,0x8C},
+	{0x4136,0x8C},
+	{0x4137,0x8C},
+	{0x4138,0x8D},
+	{0x4139,0x8D},
+	{0x413A,0x8D},
+	{0x413B,0x8D},
+	{0x413C,0x93},
+	{0x413D,0x93},
+	{0x413E,0x93},
+	{0x413F,0x92},
+	{0x4140,0x9A},
+	{0x4141,0x9A},
+	{0x4142,0x9A},
+	{0x4143,0x99},
+	{0x4144,0xA7},
+	{0x4145,0xA5},
+	{0x4146,0xA6},
+	{0x4147,0xA6},
+	{0x4148,0xB8},
+	{0x4149,0xB4},
+	{0x414A,0xB4},
+	{0x414B,0xB3},
+	{0x414C,0xA3},
+	{0x414D,0xA2},
+	{0x414E,0xA3},
+	{0x414F,0xA2},
+	{0x4150,0x96},
+	{0x4151,0x96},
+	{0x4152,0x96},
+	{0x4153,0x96},
+	{0x4154,0x8A},
+	{0x4155,0x8A},
+	{0x4156,0x8A},
+	{0x4157,0x8A},
+	{0x4158,0x82},
+	{0x4159,0x82},
+	{0x415A,0x82},
+	{0x415B,0x82},
+	{0x415C,0x84},
+	{0x415D,0x85},
+	{0x415E,0x84},
+	{0x415F,0x84},
+	{0x4160,0x8D},
+	{0x4161,0x8D},
+	{0x4162,0x8D},
+	{0x4163,0x8D},
+	{0x4164,0x96},
+	{0x4165,0x96},
+	{0x4166,0x96},
+	{0x4167,0x95},
+	{0x4168,0xA5},
+	{0x4169,0xA2},
+	{0x416A,0xA3},
+	{0x416B,0xA2},
+	{0x416C,0xB7},
+	{0x416D,0xB3},
+	{0x416E,0xB5},
+	{0x416F,0xB4},
+	{0x4170,0xA4},
+	{0x4171,0xA2},
+	{0x4172,0xA3},
+	{0x4173,0xA2},
+	{0x4174,0x97},
+	{0x4175,0x96},
+	{0x4176,0x96},
+	{0x4177,0x96},
+	{0x4178,0x8B},
+	{0x4179,0x8A},
+	{0x417A,0x8A},
+	{0x417B,0x8A},
+	{0x417C,0x81},
+	{0x417D,0x81},
+	{0x417E,0x81},
+	{0x417F,0x81},
+	{0x4180,0x84},
+	{0x4181,0x84},
+	{0x4182,0x84},
+	{0x4183,0x84},
+	{0x4184,0x8C},
+	{0x4185,0x8D},
+	{0x4186,0x8D},
+	{0x4187,0x8D},
+	{0x4188,0x95},
+	{0x4189,0x96},
+	{0x418A,0x96},
+	{0x418B,0x95},
+	{0x418C,0xA1},
+	{0x418D,0xA1},
+	{0x418E,0xA1},
+	{0x418F,0xA0},
+	{0x4190,0xBC},
+	{0x4191,0xB8},
+	{0x4192,0xB8},
+	{0x4193,0xB9},
+	{0x4194,0xA8},
+	{0x4195,0xA5},
+	{0x4196,0xA6},
+	{0x4197,0xA5},
+	{0x4198,0x9C},
+	{0x4199,0x9A},
+	{0x419A,0x9A},
+	{0x419B,0x9A},
+	{0x419C,0x91},
+	{0x419D,0x91},
+	{0x419E,0x91},
+	{0x419F,0x91},
+	{0x41A0,0x8B},
+	{0x41A1,0x8B},
+	{0x41A2,0x8B},
+	{0x41A3,0x8B},
+	{0x41A4,0x8C},
+	{0x41A5,0x8C},
+	{0x41A6,0x8C},
+	{0x41A7,0x8C},
+	{0x41A8,0x91},
+	{0x41A9,0x92},
+	{0x41AA,0x91},
+	{0x41AB,0x91},
+	{0x41AC,0x98},
+	{0x41AD,0x99},
+	{0x41AE,0x99},
+	{0x41AF,0x98},
+	{0x41B0,0xA3},
+	{0x41B1,0xA3},
+	{0x41B2,0xA3},
+	{0x41B3,0xA2},
+	{0x41B4,0xC1},
+	{0x41B5,0xB8},
+	{0x41B6,0xB9},
+	{0x41B7,0xBA},
+	{0x41B8,0xB8},
+	{0x41B9,0xB4},
+	{0x41BA,0xB4},
+	{0x41BB,0xB4},
+	{0x41BC,0xAA},
+	{0x41BD,0xA7},
+	{0x41BE,0xA7},
+	{0x41BF,0xA8},
+	{0x41C0,0xA4},
+	{0x41C1,0xA2},
+	{0x41C2,0xA2},
+	{0x41C3,0xA3},
+	{0x41C4,0x9E},
+	{0x41C5,0x9D},
+	{0x41C6,0x9D},
+	{0x41C7,0x9D},
+	{0x41C8,0x9E},
+	{0x41C9,0x9D},
+	{0x41CA,0x9D},
+	{0x41CB,0x9D},
+	{0x41CC,0x9E},
+	{0x41CD,0x9E},
+	{0x41CE,0x9E},
+	{0x41CF,0x9E},
+	{0x41D0,0xA3},
+	{0x41D1,0xA3},
+	{0x41D2,0xA2},
+	{0x41D3,0xA1},
+	{0x41D4,0xA7},
+	{0x41D5,0xA7},
+	{0x41D6,0xA7},
+	{0x41D7,0xA3},
+	{0x4200,0xCE},
+	{0x4201,0xC0},
+	{0x4202,0xC1},
+	{0x4203,0xB9},
+	{0x4204,0xC3},
+	{0x4205,0xB9},
+	{0x4206,0xBC},
+	{0x4207,0xBD},
+	{0x4208,0xB3},
+	{0x4209,0xAE},
+	{0x420A,0xAF},
+	{0x420B,0xAE},
+	{0x420C,0xAA},
+	{0x420D,0xA8},
+	{0x420E,0xA8},
+	{0x420F,0xA6},
+	{0x4210,0xA4},
+	{0x4211,0xA2},
+	{0x4212,0xA2},
+	{0x4213,0xA0},
+	{0x4214,0xA4},
+	{0x4215,0xA3},
+	{0x4216,0xA2},
+	{0x4217,0xA0},
+	{0x4218,0xA7},
+	{0x4219,0xA5},
+	{0x421A,0xA3},
+	{0x421B,0xA1},
+	{0x421C,0xB0},
+	{0x421D,0xA8},
+	{0x421E,0xA8},
+	{0x421F,0xA6},
+	{0x4220,0xB4},
+	{0x4221,0xAA},
+	{0x4222,0xA5},
+	{0x4223,0xA3},
+	{0x4224,0xC7},
+	{0x4225,0xBC},
+	{0x4226,0xBE},
+	{0x4227,0xBC},
+	{0x4228,0xB0},
+	{0x4229,0xA9},
+	{0x422A,0xA9},
+	{0x422B,0xA8},
+	{0x422C,0xA0},
+	{0x422D,0x9D},
+	{0x422E,0x9D},
+	{0x422F,0x9C},
+	{0x4230,0x94},
+	{0x4231,0x93},
+	{0x4232,0x93},
+	{0x4233,0x92},
+	{0x4234,0x8E},
+	{0x4235,0x8D},
+	{0x4236,0x8D},
+	{0x4237,0x8C},
+	{0x4238,0x8F},
+	{0x4239,0x8E},
+	{0x423A,0x8E},
+	{0x423B,0x8D},
+	{0x423C,0x96},
+	{0x423D,0x94},
+	{0x423E,0x94},
+	{0x423F,0x92},
+	{0x4240,0xA1},
+	{0x4241,0x9C},
+	{0x4242,0x9C},
+	{0x4243,0x99},
+	{0x4244,0xB0},
+	{0x4245,0xA8},
+	{0x4246,0xAB},
+	{0x4247,0xA7},
+	{0x4248,0xC3},
+	{0x4249,0xB7},
+	{0x424A,0xB7},
+	{0x424B,0xBC},
+	{0x424C,0xAB},
+	{0x424D,0xA4},
+	{0x424E,0xA5},
+	{0x424F,0xA5},
+	{0x4250,0x9A},
+	{0x4251,0x97},
+	{0x4252,0x97},
+	{0x4253,0x98},
+	{0x4254,0x8C},
+	{0x4255,0x8B},
+	{0x4256,0x8B},
+	{0x4257,0x8B},
+	{0x4258,0x82},
+	{0x4259,0x82},
+	{0x425A,0x82},
+	{0x425B,0x82},
+	{0x425C,0x85},
+	{0x425D,0x85},
+	{0x425E,0x85},
+	{0x425F,0x84},
+	{0x4260,0x8F},
+	{0x4261,0x8E},
+	{0x4262,0x8E},
+	{0x4263,0x8D},
+	{0x4264,0x9B},
+	{0x4265,0x98},
+	{0x4266,0x98},
+	{0x4267,0x95},
+	{0x4268,0xAE},
+	{0x4269,0xA5},
+	{0x426A,0xA7},
+	{0x426B,0xA2},
+	{0x426C,0xC2},
+	{0x426D,0xB7},
+	{0x426E,0xB8},
+	{0x426F,0xB9},
+	{0x4270,0xAA},
+	{0x4271,0xA4},
+	{0x4272,0xA4},
+	{0x4273,0xA5},
+	{0x4274,0x99},
+	{0x4275,0x96},
+	{0x4276,0x97},
+	{0x4277,0x98},
+	{0x4278,0x8B},
+	{0x4279,0x8A},
+	{0x427A,0x8A},
+	{0x427B,0x8B},
+	{0x427C,0x81},
+	{0x427D,0x81},
+	{0x427E,0x81},
+	{0x427F,0x82},
+	{0x4280,0x84},
+	{0x4281,0x84},
+	{0x4282,0x84},
+	{0x4283,0x84},
+	{0x4284,0x8E},
+	{0x4285,0x8E},
+	{0x4286,0x8D},
+	{0x4287,0x8C},
+	{0x4288,0x9A},
+	{0x4289,0x97},
+	{0x428A,0x97},
+	{0x428B,0x95},
+	{0x428C,0xAA},
+	{0x428D,0xA3},
+	{0x428E,0xA3},
+	{0x428F,0xA2},
+	{0x4290,0xC7},
+	{0x4291,0xBA},
+	{0x4292,0xC0},
+	{0x4293,0xC3},
+	{0x4294,0xB0},
+	{0x4295,0xA7},
+	{0x4296,0xA7},
+	{0x4297,0xA9},
+	{0x4298,0x9F},
+	{0x4299,0x9B},
+	{0x429A,0x9B},
+	{0x429B,0x9D},
+	{0x429C,0x93},
+	{0x429D,0x91},
+	{0x429E,0x91},
+	{0x429F,0x92},
+	{0x42A0,0x8C},
+	{0x42A1,0x8B},
+	{0x42A2,0x8B},
+	{0x42A3,0x8C},
+	{0x42A4,0x8D},
+	{0x42A5,0x8C},
+	{0x42A6,0x8C},
+	{0x42A7,0x8C},
+	{0x42A8,0x94},
+	{0x42A9,0x93},
+	{0x42AA,0x92},
+	{0x42AB,0x91},
+	{0x42AC,0x9E},
+	{0x42AD,0x9B},
+	{0x42AE,0x9B},
+	{0x42AF,0x98},
+	{0x42B0,0xAC},
+	{0x42B1,0xA6},
+	{0x42B2,0xA6},
+	{0x42B3,0xA2},
+	{0x42B4,0xCE},
+	{0x42B5,0xBA},
+	{0x42B6,0xBC},
+	{0x42B7,0xB7},
+	{0x42B8,0xC5},
+	{0x42B9,0xB5},
+	{0x42BA,0xBA},
+	{0x42BB,0xC0},
+	{0x42BC,0xB1},
+	{0x42BD,0xA8},
+	{0x42BE,0xAE},
+	{0x42BF,0xAF},
+	{0x42C0,0xA7},
+	{0x42C1,0xA3},
+	{0x42C2,0xA3},
+	{0x42C3,0xA5},
+	{0x42C4,0xA0},
+	{0x42C5,0x9D},
+	{0x42C6,0x9D},
+	{0x42C7,0x9F},
+	{0x42C8,0xA0},
+	{0x42C9,0x9E},
+	{0x42CA,0x9E},
+	{0x42CB,0x9F},
+	{0x42CC,0xA2},
+	{0x42CD,0xA0},
+	{0x42CE,0xA0},
+	{0x42CF,0xA0},
+	{0x42D0,0xA8},
+	{0x42D1,0xA5},
+	{0x42D2,0xA5},
+	{0x42D3,0xA2},
+	{0x42D4,0xB3},
+	{0x42D5,0xAA},
+	{0x42D6,0xAB},
+	{0x42D7,0xA3},
+	{0x42D8,0x00},
+	{0x42D9,0x00},
+	{0x4300,0xA2},
+	{0x4301,0xAE},
+	{0x4302,0xAD},
+	{0x4303,0xB5},
+	{0x4304,0x95},
+	{0x4305,0x9A},
+	{0x4306,0x98},
+	{0x4307,0x9B},
+	{0x4308,0x8D},
+	{0x4309,0x90},
+	{0x430A,0x8F},
+	{0x430B,0x91},
+	{0x430C,0x86},
+	{0x430D,0x88},
+	{0x430E,0x87},
+	{0x430F,0x89},
+	{0x4310,0x86},
+	{0x4311,0x87},
+	{0x4312,0x86},
+	{0x4313,0x88},
+	{0x4314,0x89},
+	{0x4315,0x88},
+	{0x4316,0x88},
+	{0x4317,0x8E},
+	{0x4318,0x90},
+	{0x4319,0x8F},
+	{0x431A,0x8C},
+	{0x431B,0x8C},
+	{0x431C,0x9C},
+	{0x431D,0x99},
+	{0x431E,0x98},
+	{0x431F,0x99},
+	{0x4320,0xAB},
+	{0x4321,0xB0},
+	{0x4322,0xAD},
+	{0x4323,0xAF},
+	{0x4324,0x9B},
+	{0x4325,0x9F},
+	{0x4326,0x9E},
+	{0x4327,0xA1},
+	{0x4328,0x8E},
+	{0x4329,0x91},
+	{0x432A,0x90},
+	{0x432B,0x93},
+	{0x432C,0x86},
+	{0x432D,0x88},
+	{0x432E,0x87},
+	{0x432F,0x89},
+	{0x4330,0x82},
+	{0x4331,0x84},
+	{0x4332,0x83},
+	{0x4333,0x84},
+	{0x4334,0x82},
+	{0x4335,0x82},
+	{0x4336,0x82},
+	{0x4337,0x83},
+	{0x4338,0x85},
+	{0x4339,0x84},
+	{0x433A,0x84},
+	{0x433B,0x85},
+	{0x433C,0x8A},
+	{0x433D,0x89},
+	{0x433E,0x88},
+	{0x433F,0x89},
+	{0x4340,0x93},
+	{0x4341,0x91},
+	{0x4342,0x91},
+	{0x4343,0x93},
+	{0x4344,0xA0},
+	{0x4345,0x9E},
+	{0x4346,0x9D},
+	{0x4347,0xA1},
+	{0x4348,0x95},
+	{0x4349,0x9B},
+	{0x434A,0x9A},
+	{0x434B,0x9C},
+	{0x434C,0x8A},
+	{0x434D,0x8D},
+	{0x434E,0x8C},
+	{0x434F,0x8D},
+	{0x4350,0x83},
+	{0x4351,0x85},
+	{0x4352,0x84},
+	{0x4353,0x85},
+	{0x4354,0x80},
+	{0x4355,0x81},
+	{0x4356,0x81},
+	{0x4357,0x81},
+	{0x4358,0x80},
+	{0x4359,0x80},
+	{0x435A,0x80},
+	{0x435B,0x80},
+	{0x435C,0x82},
+	{0x435D,0x81},
+	{0x435E,0x81},
+	{0x435F,0x81},
+	{0x4360,0x85},
+	{0x4361,0x84},
+	{0x4362,0x84},
+	{0x4363,0x85},
+	{0x4364,0x8D},
+	{0x4365,0x8B},
+	{0x4366,0x8B},
+	{0x4367,0x8D},
+	{0x4368,0x98},
+	{0x4369,0x98},
+	{0x436A,0x95},
+	{0x436B,0x98},
+	{0x436C,0x95},
+	{0x436D,0x9A},
+	{0x436E,0x99},
+	{0x436F,0x9A},
+	{0x4370,0x8A},
+	{0x4371,0x8D},
+	{0x4372,0x8C},
+	{0x4373,0x8C},
+	{0x4374,0x83},
+	{0x4375,0x85},
+	{0x4376,0x84},
+	{0x4377,0x84},
+	{0x4378,0x80},
+	{0x4379,0x80},
+	{0x437A,0x80},
+	{0x437B,0x80},
+	{0x437C,0x7F},
+	{0x437D,0x7F},
+	{0x437E,0x7F},
+	{0x437F,0x7F},
+	{0x4380,0x81},
+	{0x4381,0x80},
+	{0x4382,0x80},
+	{0x4383,0x81},
+	{0x4384,0x84},
+	{0x4385,0x83},
+	{0x4386,0x83},
+	{0x4387,0x84},
+	{0x4388,0x8B},
+	{0x4389,0x8A},
+	{0x438A,0x8A},
+	{0x438B,0x8C},
+	{0x438C,0x97},
+	{0x438D,0x96},
+	{0x438E,0x96},
+	{0x438F,0x99},
+	{0x4390,0x99},
+	{0x4391,0x9F},
+	{0x4392,0x9E},
+	{0x4393,0x9D},
+	{0x4394,0x8D},
+	{0x4395,0x90},
+	{0x4396,0x90},
+	{0x4397,0x8F},
+	{0x4398,0x85},
+	{0x4399,0x87},
+	{0x439A,0x87},
+	{0x439B,0x86},
+	{0x439C,0x81},
+	{0x439D,0x83},
+	{0x439E,0x82},
+	{0x439F,0x82},
+	{0x43A0,0x80},
+	{0x43A1,0x81},
+	{0x43A2,0x81},
+	{0x43A3,0x81},
+	{0x43A4,0x82},
+	{0x43A5,0x82},
+	{0x43A6,0x82},
+	{0x43A7,0x82},
+	{0x43A8,0x86},
+	{0x43A9,0x85},
+	{0x43AA,0x85},
+	{0x43AB,0x87},
+	{0x43AC,0x8D},
+	{0x43AD,0x8D},
+	{0x43AE,0x8D},
+	{0x43AF,0x90},
+	{0x43B0,0x9A},
+	{0x43B1,0x9A},
+	{0x43B2,0x9B},
+	{0x43B3,0x9D},
+	{0x43B4,0xA0},
+	{0x43B5,0xAD},
+	{0x43B6,0xAC},
+	{0x43B7,0xAA},
+	{0x43B8,0x93},
+	{0x43B9,0x97},
+	{0x43BA,0x97},
+	{0x43BB,0x96},
+	{0x43BC,0x8B},
+	{0x43BD,0x8E},
+	{0x43BE,0x8E},
+	{0x43BF,0x8C},
+	{0x43C0,0x83},
+	{0x43C1,0x85},
+	{0x43C2,0x85},
+	{0x43C3,0x84},
+	{0x43C4,0x82},
+	{0x43C5,0x84},
+	{0x43C6,0x83},
+	{0x43C7,0x83},
+	{0x43C8,0x83},
+	{0x43C9,0x84},
+	{0x43CA,0x84},
+	{0x43CB,0x85},
+	{0x43CC,0x8A},
+	{0x43CD,0x8A},
+	{0x43CE,0x8A},
+	{0x43CF,0x8C},
+	{0x43D0,0x92},
+	{0x43D1,0x93},
+	{0x43D2,0x93},
+	{0x43D3,0x96},
+	{0x43D4,0x9F},
+	{0x43D5,0xA6},
+	{0x43D6,0xA5},
+	{0x43D7,0xAA},
+	{0x4400,0xA1},
+	{0x4401,0xAB},
+	{0x4402,0xA7},
+	{0x4403,0xB0},
+	{0x4404,0x91},
+	{0x4405,0x96},
+	{0x4406,0x94},
+	{0x4407,0x99},
+	{0x4408,0x8A},
+	{0x4409,0x8E},
+	{0x440A,0x8C},
+	{0x440B,0x8F},
+	{0x440C,0x85},
+	{0x440D,0x86},
+	{0x440E,0x86},
+	{0x440F,0x88},
+	{0x4410,0x85},
+	{0x4411,0x86},
+	{0x4412,0x85},
+	{0x4413,0x87},
+	{0x4414,0x88},
+	{0x4415,0x87},
+	{0x4416,0x87},
+	{0x4417,0x89},
+	{0x4418,0x91},
+	{0x4419,0x8F},
+	{0x441A,0x8F},
+	{0x441B,0x90},
+	{0x441C,0x9C},
+	{0x441D,0x9B},
+	{0x441E,0x9A},
+	{0x441F,0x9A},
+	{0x4420,0xB3},
+	{0x4421,0xB1},
+	{0x4422,0xB0},
+	{0x4423,0xB2},
+	{0x4424,0x96},
+	{0x4425,0x9C},
+	{0x4426,0x9A},
+	{0x4427,0x9E},
+	{0x4428,0x8B},
+	{0x4429,0x8F},
+	{0x442A,0x8E},
+	{0x442B,0x91},
+	{0x442C,0x84},
+	{0x442D,0x87},
+	{0x442E,0x86},
+	{0x442F,0x88},
+	{0x4430,0x82},
+	{0x4431,0x83},
+	{0x4432,0x82},
+	{0x4433,0x84},
+	{0x4434,0x82},
+	{0x4435,0x82},
+	{0x4436,0x82},
+	{0x4437,0x83},
+	{0x4438,0x84},
+	{0x4439,0x84},
+	{0x443A,0x84},
+	{0x443B,0x84},
+	{0x443C,0x8B},
+	{0x443D,0x89},
+	{0x443E,0x89},
+	{0x443F,0x89},
+	{0x4440,0x95},
+	{0x4441,0x93},
+	{0x4442,0x93},
+	{0x4443,0x93},
+	{0x4444,0xA2},
+	{0x4445,0xA2},
+	{0x4446,0xA1},
+	{0x4447,0xA0},
+	{0x4448,0x8F},
+	{0x4449,0x97},
+	{0x444A,0x97},
+	{0x444B,0x98},
+	{0x444C,0x87},
+	{0x444D,0x8B},
+	{0x444E,0x8A},
+	{0x444F,0x8B},
+	{0x4450,0x81},
+	{0x4451,0x83},
+	{0x4452,0x83},
+	{0x4453,0x84},
+	{0x4454,0x7F},
+	{0x4455,0x80},
+	{0x4456,0x80},
+	{0x4457,0x81},
+	{0x4458,0x80},
+	{0x4459,0x80},
+	{0x445A,0x80},
+	{0x445B,0x80},
+	{0x445C,0x82},
+	{0x445D,0x81},
+	{0x445E,0x81},
+	{0x445F,0x81},
+	{0x4460,0x87},
+	{0x4461,0x85},
+	{0x4462,0x85},
+	{0x4463,0x86},
+	{0x4464,0x90},
+	{0x4465,0x8E},
+	{0x4466,0x8E},
+	{0x4467,0x8E},
+	{0x4468,0x9B},
+	{0x4469,0x9C},
+	{0x446A,0x9A},
+	{0x446B,0x9A},
+	{0x446C,0x91},
+	{0x446D,0x97},
+	{0x446E,0x95},
+	{0x446F,0x95},
+	{0x4470,0x87},
+	{0x4471,0x8A},
+	{0x4472,0x8A},
+	{0x4473,0x89},
+	{0x4474,0x81},
+	{0x4475,0x83},
+	{0x4476,0x83},
+	{0x4477,0x83},
+	{0x4478,0x7F},
+	{0x4479,0x80},
+	{0x447A,0x80},
+	{0x447B,0x80},
+	{0x447C,0x80},
+	{0x447D,0x80},
+	{0x447E,0x80},
+	{0x447F,0x7F},
+	{0x4480,0x81},
+	{0x4481,0x81},
+	{0x4482,0x81},
+	{0x4483,0x81},
+	{0x4484,0x85},
+	{0x4485,0x85},
+	{0x4486,0x85},
+	{0x4487,0x85},
+	{0x4488,0x8E},
+	{0x4489,0x8D},
+	{0x448A,0x8D},
+	{0x448B,0x8E},
+	{0x448C,0x9D},
+	{0x448D,0x9C},
+	{0x448E,0x9C},
+	{0x448F,0x9C},
+	{0x4490,0x94},
+	{0x4491,0x9B},
+	{0x4492,0x9A},
+	{0x4493,0x97},
+	{0x4494,0x8A},
+	{0x4495,0x8E},
+	{0x4496,0x8E},
+	{0x4497,0x8C},
+	{0x4498,0x84},
+	{0x4499,0x86},
+	{0x449A,0x86},
+	{0x449B,0x84},
+	{0x449C,0x81},
+	{0x449D,0x83},
+	{0x449E,0x83},
+	{0x449F,0x81},
+	{0x44A0,0x81},
+	{0x44A1,0x82},
+	{0x44A2,0x82},
+	{0x44A3,0x81},
+	{0x44A4,0x83},
+	{0x44A5,0x83},
+	{0x44A6,0x83},
+	{0x44A7,0x83},
+	{0x44A8,0x88},
+	{0x44A9,0x88},
+	{0x44AA,0x88},
+	{0x44AB,0x88},
+	{0x44AC,0x91},
+	{0x44AD,0x91},
+	{0x44AE,0x91},
+	{0x44AF,0x92},
+	{0x44B0,0xA0},
+	{0x44B1,0xA0},
+	{0x44B2,0xA0},
+	{0x44B3,0xA0},
+	{0x44B4,0x9E},
+	{0x44B5,0xA9},
+	{0x44B6,0xA8},
+	{0x44B7,0xA3},
+	{0x44B8,0x90},
+	{0x44B9,0x95},
+	{0x44BA,0x95},
+	{0x44BB,0x92},
+	{0x44BC,0x8A},
+	{0x44BD,0x8E},
+	{0x44BE,0x8E},
+	{0x44BF,0x8B},
+	{0x44C0,0x84},
+	{0x44C1,0x86},
+	{0x44C2,0x86},
+	{0x44C3,0x84},
+	{0x44C4,0x84},
+	{0x44C5,0x85},
+	{0x44C6,0x85},
+	{0x44C7,0x84},
+	{0x44C8,0x86},
+	{0x44C9,0x87},
+	{0x44CA,0x87},
+	{0x44CB,0x86},
+	{0x44CC,0x8D},
+	{0x44CD,0x8E},
+	{0x44CE,0x8E},
+	{0x44CF,0x8D},
+	{0x44D0,0x98},
+	{0x44D1,0x98},
+	{0x44D2,0x99},
+	{0x44D3,0x9A},
+	{0x44D4,0xA9},
+	{0x44D5,0xAA},
+	{0x44D6,0xAA},
+	{0x44D7,0xAD},
+	{0x4500,0x9F},
+	{0x4501,0xA8},
+	{0x4502,0xA5},
+	{0x4503,0xAF},
+	{0x4504,0x8F},
+	{0x4505,0x96},
+	{0x4506,0x92},
+	{0x4507,0x94},
+	{0x4508,0x89},
+	{0x4509,0x8D},
+	{0x450A,0x8A},
+	{0x450B,0x8E},
+	{0x450C,0x84},
+	{0x450D,0x85},
+	{0x450E,0x84},
+	{0x450F,0x87},
+	{0x4510,0x84},
+	{0x4511,0x85},
+	{0x4512,0x84},
+	{0x4513,0x86},
+	{0x4514,0x87},
+	{0x4515,0x86},
+	{0x4516,0x86},
+	{0x4517,0x88},
+	{0x4518,0x8F},
+	{0x4519,0x8D},
+	{0x451A,0x8D},
+	{0x451B,0x8F},
+	{0x451C,0x9A},
+	{0x451D,0x9A},
+	{0x451E,0x98},
+	{0x451F,0x9A},
+	{0x4520,0xAF},
+	{0x4521,0xAF},
+	{0x4522,0xB2},
+	{0x4523,0xB1},
+	{0x4524,0x95},
+	{0x4525,0x9B},
+	{0x4526,0x97},
+	{0x4527,0x9C},
+	{0x4528,0x8A},
+	{0x4529,0x8E},
+	{0x452A,0x8D},
+	{0x452B,0x90},
+	{0x452C,0x84},
+	{0x452D,0x86},
+	{0x452E,0x85},
+	{0x452F,0x87},
+	{0x4530,0x81},
+	{0x4531,0x82},
+	{0x4532,0x82},
+	{0x4533,0x83},
+	{0x4534,0x81},
+	{0x4535,0x81},
+	{0x4536,0x81},
+	{0x4537,0x82},
+	{0x4538,0x84},
+	{0x4539,0x83},
+	{0x453A,0x83},
+	{0x453B,0x84},
+	{0x453C,0x8A},
+	{0x453D,0x88},
+	{0x453E,0x88},
+	{0x453F,0x89},
+	{0x4540,0x94},
+	{0x4541,0x92},
+	{0x4542,0x91},
+	{0x4543,0x92},
+	{0x4544,0xA1},
+	{0x4545,0xA0},
+	{0x4546,0x9C},
+	{0x4547,0x9D},
+	{0x4548,0x8F},
+	{0x4549,0x96},
+	{0x454A,0x95},
+	{0x454B,0x92},
+	{0x454C,0x87},
+	{0x454D,0x8A},
+	{0x454E,0x89},
+	{0x454F,0x8A},
+	{0x4550,0x81},
+	{0x4551,0x83},
+	{0x4552,0x82},
+	{0x4553,0x83},
+	{0x4554,0x7F},
+	{0x4555,0x80},
+	{0x4556,0x80},
+	{0x4557,0x81},
+	{0x4558,0x7F},
+	{0x4559,0x80},
+	{0x455A,0x7F},
+	{0x455B,0x80},
+	{0x455C,0x81},
+	{0x455D,0x81},
+	{0x455E,0x81},
+	{0x455F,0x81},
+	{0x4560,0x86},
+	{0x4561,0x85},
+	{0x4562,0x85},
+	{0x4563,0x85},
+	{0x4564,0x8F},
+	{0x4565,0x8D},
+	{0x4566,0x8D},
+	{0x4567,0x8D},
+	{0x4568,0x99},
+	{0x4569,0x9A},
+	{0x456A,0x97},
+	{0x456B,0x99},
+	{0x456C,0x90},
+	{0x456D,0x95},
+	{0x456E,0x93},
+	{0x456F,0x92},
+	{0x4570,0x87},
+	{0x4571,0x8A},
+	{0x4572,0x88},
+	{0x4573,0x87},
+	{0x4574,0x81},
+	{0x4575,0x83},
+	{0x4576,0x82},
+	{0x4577,0x82},
+	{0x4578,0x7F},
+	{0x4579,0x80},
+	{0x457A,0x80},
+	{0x457B,0x80},
+	{0x457C,0x80},
+	{0x457D,0x80},
+	{0x457E,0x80},
+	{0x457F,0x80},
+	{0x4580,0x81},
+	{0x4581,0x81},
+	{0x4582,0x81},
+	{0x4583,0x81},
+	{0x4584,0x85},
+	{0x4585,0x85},
+	{0x4586,0x84},
+	{0x4587,0x85},
+	{0x4588,0x8E},
+	{0x4589,0x8D},
+	{0x458A,0x8C},
+	{0x458B,0x8D},
+	{0x458C,0x9B},
+	{0x458D,0x9B},
+	{0x458E,0x9A},
+	{0x458F,0x98},
+	{0x4590,0x94},
+	{0x4591,0x9A},
+	{0x4592,0x94},
+	{0x4593,0x90},
+	{0x4594,0x8A},
+	{0x4595,0x8D},
+	{0x4596,0x8C},
+	{0x4597,0x89},
+	{0x4598,0x84},
+	{0x4599,0x86},
+	{0x459A,0x85},
+	{0x459B,0x83},
+	{0x459C,0x82},
+	{0x459D,0x83},
+	{0x459E,0x82},
+	{0x459F,0x80},
+	{0x45A0,0x81},
+	{0x45A1,0x82},
+	{0x45A2,0x81},
+	{0x45A3,0x80},
+	{0x45A4,0x83},
+	{0x45A5,0x83},
+	{0x45A6,0x83},
+	{0x45A7,0x83},
+	{0x45A8,0x88},
+	{0x45A9,0x87},
+	{0x45AA,0x87},
+	{0x45AB,0x88},
+	{0x45AC,0x91},
+	{0x45AD,0x90},
+	{0x45AE,0x90},
+	{0x45AF,0x91},
+	{0x45B0,0x9F},
+	{0x45B1,0x9F},
+	{0x45B2,0x9E},
+	{0x45B3,0x9F},
+	{0x45B4,0x9F},
+	{0x45B5,0xA8},
+	{0x45B6,0xA6},
+	{0x45B7,0xA7},
+	{0x45B8,0x8D},
+	{0x45B9,0x95},
+	{0x45BA,0x90},
+	{0x45BB,0x8A},
+	{0x45BC,0x89},
+	{0x45BD,0x8D},
+	{0x45BE,0x88},
+	{0x45BF,0x86},
+	{0x45C0,0x84},
+	{0x45C1,0x86},
+	{0x45C2,0x85},
+	{0x45C3,0x82},
+	{0x45C4,0x84},
+	{0x45C5,0x85},
+	{0x45C6,0x85},
+	{0x45C7,0x83},
+	{0x45C8,0x86},
+	{0x45C9,0x86},
+	{0x45CA,0x86},
+	{0x45CB,0x85},
+	{0x45CC,0x8E},
+	{0x45CD,0x8D},
+	{0x45CE,0x8D},
+	{0x45CF,0x8C},
+	{0x45D0,0x99},
+	{0x45D1,0x98},
+	{0x45D2,0x98},
+	{0x45D3,0x98},
+	{0x45D4,0xA6},
+	{0x45D5,0xA9},
+	{0x45D6,0xA7},
+	{0x45D7,0xAC},
+};
+
+const size_t imx390_mode_1936x1100SP2_len = ARRAY_SIZE(imx390_mode_1936x1100SP2);
diff --git a/drivers/d3/imx390/imx390-mode-1936x1100-SP2.h b/drivers/d3/imx390/imx390-mode-1936x1100-SP2.h
new file mode 100644
index 000000000000..b8a29fd48152
--- /dev/null
+++ b/drivers/d3/imx390/imx390-mode-1936x1100-SP2.h
@@ -0,0 +1,28 @@
+/**
+ * @author Greg Rowe <growe@d3engineering.com>
+ *
+ * imx390 v4l2 driver for Nvidia Jetson
+ *
+ * Copyright (c) 2018-2019, D3 Engineering.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+#ifndef _IMX390_MODE_1936X1100_SP2_H
+#define _IMX390_MODE_1936X1100_SP2_H
+
+#include <linux/regmap.h>
+
+extern const struct reg_sequence imx390_mode_1936x1100SP2[];
+extern const size_t imx390_mode_1936x1100SP2_len;
+
+#endif
diff --git a/drivers/d3/imx390/imx390-modes.c b/drivers/d3/imx390/imx390-modes.c
new file mode 100644
index 000000000000..9e74e71c67f3
--- /dev/null
+++ b/drivers/d3/imx390/imx390-modes.c
@@ -0,0 +1,104 @@
+/**
+ * @author Greg Rowe <growe@d3engineering.com>
+ *
+ * imx390 v4l2 driver for Nvidia Jetson
+ *
+ * Copyright (c) 2018-2019, D3 Engineering.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+#include "imx390-modes.h"
+
+const int imx390_modes_60fps[] = {
+	60,
+};
+
+const int imx390_modes_30fps[] = {
+	30,
+};
+
+
+
+/**
+ * Mode table as expected by Nvidia's camera_common framework
+ */
+const struct camera_common_frmfmt imx390_modes_formats[] = {
+	/* Important: ensure that the order of entries in this table
+	 * matches enum IMX390_MODE */
+
+	/* The imager outputs 1936x1096 but includes 4 lines of SMPG
+	 * data.  SMPG is Safety Mechanism Pattern Generator.  There is
+	 * also 1 line of embedded data that cannot be disabled.  The
+	 * embedded data line does NOT count towards the overall
+	 * dimensions. */
+	{
+		.size = {1936, 1100},
+		.framerates = imx390_modes_30fps,
+		.num_framerates = 1,
+		.hdr_en = 0,
+		.mode = IMX390_MODE_SP1L,
+	},
+	{
+		.size = {1936, 1100},
+		.framerates = imx390_modes_30fps,
+		.num_framerates = 1,
+		.hdr_en = 0,
+		.mode = IMX390_MODE_SP1H,
+	},
+	{
+		.size = {1936, 1100},
+		.framerates = imx390_modes_30fps,
+		.num_framerates = 1,
+		.hdr_en = 0,
+		.mode = IMX390_MODE_SP2,
+	},
+#ifdef CONFIG_D3_IMX390_HDR_ENABLE
+	{
+		.size = {1936, 1100},
+		.framerates = imx390_modes_60fps,
+		.num_framerates = 1,
+		.hdr_en = 1,
+		.mode = IMX390_MODE_HDR,
+	},
+#endif	/* CONFIG_D3_IMX390_HDR_ENABLE */
+};
+const size_t imx390_modes_formats_len = ARRAY_SIZE(imx390_modes_formats);
+
+
+struct imx390_modes_map imx390_modes_map[] = {
+	/* Important: ensure that the order of entries in this table
+	 * matches enum IMX390_MODE */
+	{
+		.desc = "SP1L Linear 30 fps",
+		.n_vals = &imx390_mode_1936x1100SP1L_len,
+		.vals = imx390_mode_1936x1100SP1L
+	},
+	{
+		.desc = "SP1H Linear 30 fps",
+		.n_vals = &imx390_mode_1936x1100SP1H_len,
+		.vals = imx390_mode_1936x1100SP1H
+	},
+	{
+		.desc = "SP2 Linear 30 fps",
+		.n_vals = &imx390_mode_1936x1100SP2_len,
+		.vals = imx390_mode_1936x1100SP2
+	},
+#ifdef CONFIG_D3_IMX390_HDR_ENABLE
+	{
+		.desc = "HDR 60 fps",
+		.n_vals = &imx390_mode_1936x1100HDR_len,
+		.vals = imx390_mode_1936x1100HDR
+	},
+#endif	/* CONFIG_D3_IMX390_HDR_ENABLE */
+};
+const size_t imx390_modes_map_len = ARRAY_SIZE(imx390_modes_map);
diff --git a/drivers/d3/imx390/imx390-modes.h b/drivers/d3/imx390/imx390-modes.h
new file mode 100644
index 000000000000..7b394ae651d2
--- /dev/null
+++ b/drivers/d3/imx390/imx390-modes.h
@@ -0,0 +1,55 @@
+/**
+ * @author Greg Rowe <growe@d3engineering.com>
+ *
+ * imx390 v4l2 driver for Nvidia Jetson - default register settings
+ *
+ * Copyright (c) 2018, D3 Engineering.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+#ifndef _IMX390_MODES_H
+#define _IMX390_MODES_H
+
+#include <media/camera_common.h>
+#ifdef CONFIG_D3_IMX390_HDR_ENABLE
+#	include "imx390-mode-1936x1100-HDR.h"
+#endif	/* CONFIG_D3_IMX390_HDR_ENABLE */
+#include "imx390-mode-1936x1100-SP1L.h"
+#include "imx390-mode-1936x1100-SP1H.h"
+#include "imx390-mode-1936x1100-SP2.h"
+
+
+enum imx390_mode {
+	IMX390_MODE_SP1L,
+	IMX390_MODE_SP1H,
+	IMX390_MODE_SP2,
+#ifdef CONFIG_D3_IMX390_HDR_ENABLE
+	IMX390_MODE_HDR,
+#endif	/* CONFIG_D3_IMX390_HDR_ENABLE */
+	IMX390_MODE_ENDMARKER,
+	IMX390_MODE_DEFAULT = IMX390_MODE_SP1L,
+};
+
+struct imx390_modes_map {
+	const char *desc;
+	const size_t *n_vals;
+	const struct reg_sequence *vals;
+};
+
+extern struct imx390_modes_map imx390_modes_map[];
+extern const size_t imx390_modes_map_len;
+
+extern const struct camera_common_frmfmt imx390_modes_formats[];
+extern const size_t imx390_modes_formats_len;
+
+#endif
diff --git a/drivers/d3/max9296/Kconfig b/drivers/d3/max9296/Kconfig
new file mode 100644
index 000000000000..d38439759486
--- /dev/null
+++ b/drivers/d3/max9296/Kconfig
@@ -0,0 +1,43 @@
+config D3_SERDES_COMMON
+	tristate "GMSL serializers/deserializers"
+	help
+	  Say Y here if you want to add support for the GMSL
+	  serializers/deserializers.
+	  If unsure, say N.
+
+config D3_MAX9296
+	tristate "MAX9296A GMSL2 Deserializer Driver"
+	depends on D3_SERDES_COMMON
+	help
+	  Say Y here if you want to add support for the MAX9296A deserializer.
+	  To compile this driver as a module, choose M here; the module will
+	  be called max9296.
+	  If unsure, say N.
+
+config D3_MAX9286
+	tristate "MAX9286 GMSL1 Deserializer Driver"
+	depends on D3_SERDES_COMMON
+	help
+	  Say Y here if you want to add support for the MAX9286 deserializer.
+	  To compile this driver as a module, chose M here; the module will
+	  be called max9286.
+	  If unsure, say N.
+
+config D3_MAX9295
+	tristate "MAX9295 GMSL2 Serializer Driver"
+	depends on D3_SERDES_COMMON
+	depends on D3_MAX9296
+	help
+	  Say Y here if you want to add support for the MAX9295 GMSL2 serializer.
+	  To compile this driver as a module, chose M here; the module will
+	  be called max9295.
+	  If unsure, say N.
+
+config D3_MAX96705
+	tristate "MAX96705 GMSL1 Serializer Driver"
+	depends on D3_SERDES_COMMON
+	help
+	  Say Y here if you want to add support for the MAX96705 GMSL1 serializer.
+	  To compile this driver as a module, chose M here; the module will
+	  be called max96705.
+	  If unsure, say N.
diff --git a/drivers/d3/max9296/Makefile b/drivers/d3/max9296/Makefile
new file mode 100644
index 000000000000..0f955c254e87
--- /dev/null
+++ b/drivers/d3/max9296/Makefile
@@ -0,0 +1,6 @@
+obj-$(CONFIG_D3_MAX9296)	+= max9296.o
+obj-$(CONFIG_D3_MAX9286)	+= max9286.o
+obj-$(CONFIG_D3_MAX9295)	+= max9295.o
+obj-$(CONFIG_D3_MAX96705)	+= max96705.o
+obj-$(CONFIG_D3_SERDES_COMMON)	+= serdes.o
+
diff --git a/drivers/d3/max9296/max9286.c b/drivers/d3/max9296/max9286.c
new file mode 100644
index 000000000000..ebd76db7e7c5
--- /dev/null
+++ b/drivers/d3/max9296/max9286.c
@@ -0,0 +1,474 @@
+/*
+ * max9286.c - Maxim MAX9286 GMSL1 to CSI-2 Deserializer
+ *
+ * Copyright (c) 2018-2019, D3 Engineering.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/i2c.h>
+#include <linux/i2c-mux.h>
+#include <linux/regmap.h>
+#include <linux/gpio/consumer.h>
+#include <linux/sysfs.h>
+#include <linux/slab.h>
+
+#include <d3/d3-jetson-bsp.h>
+
+#include "max9286.h"
+#include "max96705.h"
+#include "max9286_tables.h"
+#include "max96705_tables.h"
+#include "serdes.h"
+
+#define MAX_DEBUG 1
+#define MAX_DEBUG_GMSL_BACKCHANNEL 0
+
+
+
+enum {
+	CHIP_MAX9286 = 0,
+};
+
+static struct i2c_device_id max9286_idtable[] = {
+	{"max9286", CHIP_MAX9286},
+	{},
+};
+MODULE_DEVICE_TABLE(i2c, max9286_idtable);
+
+static struct of_device_id max9286_of_match[] = {
+	{ .compatible = "maxim,max9286"},
+	{},
+};
+MODULE_DEVICE_TABLE(of, max9286_of_match);
+
+/* TODO: This is shared by 2 functions. refactor. */
+static struct reg_sequence max96705_seraddr[] = {
+	{ MAX96705_REG_SERADDR, MAX96705_REG_SERADDR_DEFAULT },
+};
+
+/* TODO: This is shared by 2 functions. refactor. */
+static struct reg_sequence max96705_imgaddr[] = {
+	{ MAX96705_REG_SRC_A, 0 },
+	{ MAX96705_REG_DST_A, 0 },
+};
+
+/* MAX9286-MAX96705 initialization playlist */
+static const struct serdes_playlist max9286_max96705[] = {
+	/* reverse channel setup */
+	PLAYLIST_INIT('d', max9286_custom_rcs),
+	PLAYLIST_INIT('s', max96705_en_cfg),
+	PLAYLIST_INIT('d', max9286_disable_loc_ack),
+	PLAYLIST_INIT('s', max96705_ser_input),
+	PLAYLIST_INIT('d', max9286_dis_csi),
+	PLAYLIST_INIT('s', max96705_en_dbl_hven_hibw),
+	PLAYLIST_INIT('d', max9286_en_hibw),
+	PLAYLIST_INIT('s', max96705_retime_vs_hs),
+	PLAYLIST_INIT('s', max96705_set_xbar),
+	/* sensor setup */
+	/* post camera setup */
+	PLAYLIST_INIT('s', max96705_en_gmsl),
+	PLAYLIST_INIT('d', max9286_en_csi),
+	/* i2c address remapping */
+	PLAYLIST_INIT('s', max96705_imgaddr),
+	PLAYLIST_INIT('s', max96705_seraddr),
+};
+
+#ifdef MAX_DEBUG
+/* Let some registers be read via debugfs */
+static const struct regmap_range max9286_yes_ranges[] = {
+	regmap_reg_range(0, 0x34),
+	regmap_reg_range(0x41, 0x41),
+	regmap_reg_range(0x49, 0x49),
+	regmap_reg_range(0x5b, 0x64),
+	regmap_reg_range(0x68, 0x71),
+};
+
+static const struct regmap_access_table max9286_regmap_rd_access_table = {
+	.yes_ranges = max9286_yes_ranges,
+	.n_yes_ranges = ARRAY_SIZE(max9286_yes_ranges),
+};
+#endif /* MAX_DEBUG */
+
+static const struct regmap_config max9286_regmap_config = {
+	.reg_bits = 8,
+	.val_bits = 8,
+#ifdef MAX_DEBUG
+	.max_register = 0x71,
+	.rd_table = &max9286_regmap_rd_access_table,
+#endif	/* MAX_DEBUG */
+};
+
+static const struct regmap_config max96705_regmap_config = {
+	.reg_bits = 8,
+	.val_bits = 8,
+};
+
+static const struct regmap_config regmap_config_16bit = {
+	.reg_bits = 16,
+	.val_bits = 16,
+};
+
+/*
+ * Wrapper around regmap_read that prints errors.
+ */
+static int max9286_regmap_read(struct deserializer *priv, u32 reg, u32 *val)
+{
+	struct device *dev = &priv->serdes.client->dev;
+	struct regmap *map = priv->serdes.map;
+	int ret = 0;
+
+	reg &= 0xFF;
+	ret = regmap_read(map, reg, val);
+	if (ret)
+		dev_err(dev, "Failed reading register 0x%x\n", reg);
+	return ret;
+}
+
+/*
+ * Wrapper around regmap_write that prints errors.
+ */
+
+static int max9286_regmap_write(struct deserializer *priv, u32 reg, u32 val)
+{
+	struct device *dev = &priv->serdes.client->dev;
+	struct regmap *map = priv->serdes.map;
+	int ret = 0;
+
+	reg &= 0xFF;
+	val &= 0xFF;
+	ret = regmap_write(map, reg, val);
+	if (ret)
+		dev_err(dev, "Failed writing register 0x%x\n", reg);
+	return ret;
+}
+
+/* Set GMSL link state for 9286 */
+static int max9286_set_link_state(struct deserializer *priv, unsigned link,
+		int state)
+{
+	int ret;
+	u32 reg_val;
+	u8 mask;
+
+	if (link >= MAX9286_NUM_CHANNELS)
+		return -EINVAL;
+	ret = max9286_regmap_read(priv, 0x0A, &reg_val);
+	if (ret != 0)
+		return ret;
+	mask = (MAX9286_REVCCEN0 | MAX9286_FWDCCEN0) << link;
+	reg_val = state ? reg_val | mask : reg_val & ~mask;
+	return  max9286_regmap_write(priv, 0x0A, reg_val);
+}
+
+static inline int max9286_disable_link(struct deserializer *priv, unsigned link)
+{
+	return max9286_set_link_state(priv, link, false);
+}
+
+static inline int max9286_enable_link(struct deserializer *priv, unsigned link)
+{
+	return max9286_set_link_state(priv, link, true);
+}
+
+static int max9286_set_lane_count(struct deserializer *priv)
+{
+	struct device *dev = &priv->serdes.client->dev;
+	unsigned reg_val = 0;
+	unsigned char mask = 0;
+	const unsigned char reg_addr = 0x12;
+	int ret;
+
+	if (priv->serdes.csi_config.num_lanes > 4
+		|| priv->serdes.csi_config.num_lanes == 0) {
+		dev_err(dev, "Invalid number of CSI lanes: %d",
+				priv->serdes.csi_config.num_lanes);
+		return -EINVAL;
+	}
+	mask = (priv->serdes.csi_config.num_lanes - 1) << 6;
+	ret = max9286_regmap_read(priv, reg_addr, &reg_val);
+	if (ret < 0)
+		return ret;
+	reg_val = (reg_val & 0x3F) | mask;
+	return max9286_regmap_write(priv, reg_addr, reg_val);
+}
+
+static int max9286_set_csi_parameters(struct deserializer *priv, struct device_node *node)
+{
+	int ret = 0;
+
+	ret = of_property_read_u32(node, "csi-lane-count",
+			&priv->serdes.csi_config.num_lanes);
+	if (ret == 0)
+		ret = max9286_set_lane_count(priv);
+	return ret;
+}
+
+#define IS_WORTH_RETRYING(ret) ( ret == -ETIMEDOUT \
+		|| ret == -EAGAIN \
+		|| ret == -EREMOTEIO \
+		)
+
+static int max9286_play_init_sequence(struct device *dev,
+		const struct serdes_playlist *pl, unsigned len,
+		struct regmap *des_map, struct regmap *ser_map,
+		struct regmap *sen_map)
+{
+	int ret = 0;
+	int i = 0;
+	const int max_retries = 3;
+
+	for (i = 0; i < len; i++) {
+		unsigned try_cnt = 0;
+		struct regmap *p;
+		p = pl[i].target == 'd' ? des_map
+		  : pl[i].target == 's' ? ser_map
+		  : sen_map;
+#if MAX_DEBUG_GMSL_BACKCHANNEL
+		/* back channel debugging */
+		if (i == 5 || i == 6) {
+			int j;
+			unsigned testval;
+			int testret;
+			int errcount = 0;
+			dev_dbg(dev, "Starting backchannel testing.");
+			for (j = 0; j < 100; j++) {
+				testret = regmap_read(ser_map, 0, &testval);
+				if (testret < 0)
+					errcount++;
+			}
+			dev_dbg(dev, "Backchannel error count: %u", errcount);
+		}
+		/* end back channel debugging */
+#endif		/* MAX_DEBUG_GMSL_BACKCHANNEL */
+		do {
+			ret = regmap_multi_reg_write(p, pl[i].seq, pl[i].len);
+			try_cnt += 1;
+			if (ret < 0) {
+				dev_dbg(dev, "Step: %u, ret: %d, try: %d.\n",
+						i, ret, try_cnt);
+				udelay(200 * try_cnt);
+			}
+		} while (IS_WORTH_RETRYING(ret) && try_cnt < max_retries);
+		if (ret < 0) {
+			dev_err(dev, "Step %d failed. ret: %d\n", i, ret);
+			return ret;
+		}
+	}
+	return ret;
+}
+
+int max9286_gmsl1_init(struct deserializer *priv, struct device_node *node,
+		const struct serdes_playlist *pl, unsigned pl_len)
+{
+	struct device *dev = &priv->serdes.client->dev;
+	struct i2c_client *client = priv->serdes.client;
+	struct i2c_adapter *i2c_parent = to_i2c_adapter(client->dev.parent);
+	struct i2c_client *ser = NULL;
+	struct regmap *ser_map = NULL;
+	struct i2c_client *sen = NULL;
+	struct regmap *sen_map = NULL;
+	unsigned ser_addr = 0x40;
+	unsigned sen_addr = 0x10;
+	const int max_retries = 5;
+	int try_cnt = 0;
+	int ret = 0;
+	u32 ser_addr_map[2] = {0, 0}; /* remapped addr, physical addr */
+	u32 sen_addr_map[2] = {0, 0}; /* remapped addr, physical addr */
+
+	dev_dbg(dev, "GMSL-1 init.\n");
+	if (!i2c_parent) {
+		dev_err(dev, "Oops! the i2c parent is NULL!\n");
+		return 0;
+	}
+
+	/* Serializer i2c address translation first */
+	ret = of_property_read_u32_array(node, "ser-addr", ser_addr_map, 2);
+	if (ret == 0) {
+		max96705_seraddr[0].def = ser_addr_map[0] << 1;
+		ser_addr = ser_addr_map[1];
+		dev_dbg(dev, "0x%x => 0x%x.\n",
+				ser_addr_map[0], ser_addr_map[1]);
+	}
+	ret = of_property_read_u32_array(node, "img-addr", sen_addr_map, 2);
+	if (ret == 0) {
+		max96705_imgaddr[0].def = sen_addr_map[0] << 1;
+		max96705_imgaddr[1].def = sen_addr_map[1] << 1;
+		sen_addr = sen_addr_map[1];
+		dev_dbg(dev, "0x%x => 0x%x.\n",
+				sen_addr_map[0], sen_addr_map[1]);
+	}
+
+	ret = serdes_create_dummy(i2c_parent, ser_addr,
+			&max96705_regmap_config,
+			&ser, &ser_map);
+	if (ret != 0) {
+		dev_err(dev, "Error creating serializer dummy");
+		return ret;
+	}
+	ret = serdes_create_dummy(i2c_parent, sen_addr,
+			&regmap_config_16bit,
+			&sen, &sen_map);
+	if (ret != 0) {
+		dev_err(dev, "Error creating sensor dummy");
+		return ret;
+	}
+
+	do {
+		ret = max9286_play_init_sequence(dev, pl, pl_len,
+				priv->serdes.map, ser_map, sen_map);
+		try_cnt += 1;
+		if (ret < 0) {
+			dev_warn(dev, "Retrying link initialization");
+			//priv->reset(priv);
+			// TODO:
+			// serdes_des_reset(priv);
+		}
+	} while (ret != 0 && try_cnt < max_retries);
+	if (ret < 0) {
+		dev_err(dev, "Link initialization failed.");
+		/* Disable the link so the SER doesn't interfere with
+		 * the other SERs being probed
+		 */
+		max9286_disable_link(priv, MAX9286_CH0);
+	} else {
+		dev_dbg(dev, "Link is up");
+	}
+
+	regmap_exit(sen_map);
+	regmap_exit(ser_map);
+	i2c_unregister_device(ser);
+	i2c_unregister_device(sen);
+	return ret;
+}
+
+/* static int max9286_of_address_translations(struct device_node *node, */
+/* 					   u32 *src, u32 *dst) */
+/* { */
+/* 	u32 reg; */
+/* 	u32 phys_addr; */
+
+/* 	of_property_read_u32(node, "reg", &reg); */
+/* 	of_property_read_u32(node, "physical-addr", &phys_addr); */
+
+/* 	if (!reg || !phys_addr) */
+/* 		return -ENXIO; */
+/* 	if (reg == phys_addr) */
+/* 		return -EINVAL; */
+
+/* 	*src = reg; */
+/* 	*dst = phys_addr; */
+/* 	return 0; */
+/* } */
+
+/* The serializer address is changed by the initial configuration sequence */
+static int max9286_change_device_addr_noop(struct serdes *serdes,
+					   u32 src, u32 dst)
+{
+	return 0;
+}
+
+static int max9286_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	struct deserializer *priv = NULL;
+	int ret = 0;
+
+	dev_dbg(&client->dev, "Probing %s.\n",
+			max9286_idtable[id->driver_data].name);
+
+	if (!IS_ENABLED(CONFIG_OF) || !client->dev.of_node)
+		return -EINVAL;
+
+	priv = devm_kzalloc(&client->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv) {
+		dev_err(&client->dev, "Failed to allocate memory.\n");
+		return -ENOMEM;
+	}
+
+	priv->serdes.client = client;
+	i2c_set_clientdata(client, priv);
+
+	/* TODO: CHANGE THE RESET FUNCTION.
+	 * 9286 apparently can't be reset by setting a bit in a register
+	 */
+	/* TODO Reset it via gpio */
+	//priv->reset = max9286_soft_reset;
+	priv->serdes.map = devm_regmap_init_i2c(client, &max9286_regmap_config);
+	if (IS_ERR(priv->serdes.map)) {
+		dev_err(&client->dev, "Failed to create regmap.\n");
+		return PTR_ERR(priv->serdes.map);
+	}
+
+	ret = serdes_mux_init(&priv->serdes, DES_MAX_CHANNELS);
+	if (ret != 0)
+		return ret;
+
+	ret = serdes_enable_regulators(priv, max9286_disable_link, MAX9286_CH0);
+	if (ret != 0)
+		return ret;
+	max9286_set_csi_parameters(priv, client->dev.of_node);
+	max9286_enable_link(priv, MAX9286_CH0);
+
+	ret = max9286_gmsl1_init(priv, client->dev.of_node,
+			max9286_max96705, ARRAY_SIZE(max9286_max96705));
+	if (ret != 0)
+		return ret;
+
+	dev_dbg(&client->dev, "Scanning for children nodes in DT..\n");
+	/* Scan the device tree for i2c slave buses */
+	ret = serdes_of_scan_links(&priv->serdes,
+			MAX9286_NUM_CHANNELS, max9286_change_device_addr_noop);
+	if (ret == 0) {
+		dev_info(&client->dev, "probed");
+	}
+	return ret;
+}
+
+static int max9286_remove(struct i2c_client *client)
+{
+	struct deserializer *priv = NULL;
+
+	dev_info(&client->dev, "Removing MAX929x.");
+
+	priv = i2c_get_clientdata(client);
+	if (priv->reset_gpio)
+		gpiod_put(priv->reset_gpio);
+
+	serdes_disable_regulators(priv);
+
+	/* TODO: Also, remove all the serializers */
+	return 0;
+}
+
+static struct i2c_driver max9286_driver = {
+	.driver = {
+		.name = "max9286",
+		.owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(max9286_of_match),
+	},
+	.probe = max9286_probe,
+	.remove = max9286_remove,
+	.id_table = max9286_idtable,
+};
+
+module_i2c_driver(max9286_driver);
+
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Catalin Petrescu <cpetrescu@d3engineering.com>");
+MODULE_DESCRIPTION("Maxim MAX9286/MAX96705 GMSL1 Deserializer/Serializer driver");
+MODULE_VERSION(D3_JETSON_BSP_VERSION);
+
diff --git a/drivers/d3/max9296/max9286.h b/drivers/d3/max9296/max9286.h
new file mode 100644
index 000000000000..b70567856f6e
--- /dev/null
+++ b/drivers/d3/max9296/max9286.h
@@ -0,0 +1,44 @@
+/*
+ * max9286.h - Maxim MAX9286 GMSL1 Deserializer tables
+ *
+ * Copyright (c) 2018, D3 Engineering.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef _MAX9286_H_
+#define _MAX9286_H_
+
+#define MAX9286_VERSION "0.3.0"
+enum {
+	MAX9286_CH0,
+	MAX9286_CH1,
+	MAX9286_CH2,
+	MAX9286_CH3,
+	MAX9286_NUM_CHANNELS,
+};
+
+/* The maximum number of I2C address translations that the chip can do */
+#define MAX9286_I2C_TRANS_MAX 2U
+
+/* Register 0x0A */
+#define MAX9286_REVCCEN0 (1 << 0)
+#define MAX9286_REVCCEN1 (1 << 1)
+#define MAX9286_REVCCEN2 (1 << 2)
+#define MAX9286_REVCCEN3 (1 << 3)
+#define MAX9286_FWDCCEN0 (1 << 4)
+#define MAX9286_FWDCCEN1 (1 << 5)
+#define MAX9286_FWDCCEN2 (1 << 6)
+#define MAX9286_FWDCCEN3 (1 << 7)
+
+#endif /* _MAX9286_H_ */
diff --git a/drivers/d3/max9296/max9286_tables.h b/drivers/d3/max9296/max9286_tables.h
new file mode 100644
index 000000000000..6be5750b0a85
--- /dev/null
+++ b/drivers/d3/max9296/max9286_tables.h
@@ -0,0 +1,50 @@
+/*
+ * max9286_tables.h - Maxim MAX9286 GMSL1 to CSI-2 Deserializer
+ *
+ * Copyright (c) 2018, D3 Engineering.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef _MAX9286_TABLES_H_
+#define _MAX9286_TABLES_H_
+
+#include "max9286.h"
+
+/* MAX9286 */
+static const struct reg_sequence max9286_custom_rcs[] = {
+	{0x3F,0x4F},      //Enable Custom Reverse Channel & First Pulse Length
+	{0x3B,0x1E,2000}, //Reverse Channel Amplitude to mid level and transition time
+};
+
+static const struct reg_sequence max9286_disable_loc_ack[] = {
+	{0x34,0x35}, // Disable local ACK
+};
+
+static const struct reg_sequence max9286_dis_csi[] = {
+	{0x3B,0x19,2000}, // Reverse Channel Amplitude level
+	{0x15,0x03},      // Disable CSI output
+	{0x12,0x77},      // 2 CSI Lanes, CSI DBL, GMSL DBL, RAW12
+	{0x01,0xE2},      // Disable frame sync
+	{0x00,0x01},      // Enable GMSL Link 0
+};
+
+static const struct reg_sequence max9286_en_hibw[] = {
+	{0x1C,0x06,16000} // HIBW
+};
+
+static const struct reg_sequence max9286_en_csi[] = {
+	{0x15,0x0B},
+};
+
+#endif /* _MAX9286_TABLES_H_ */
diff --git a/drivers/d3/max9296/max9295.c b/drivers/d3/max9296/max9295.c
new file mode 100644
index 000000000000..1926ad02e105
--- /dev/null
+++ b/drivers/d3/max9296/max9295.c
@@ -0,0 +1,481 @@
+/*
+ * max9295.c - Maxim MAX9295 GMSL2 to CSI-2 Serializer
+ *
+ * Copyright (c) 2018,2019 D3 Engineering.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/i2c.h>
+#include <linux/i2c-mux.h>
+#include <linux/regmap.h>
+#include <linux/sysfs.h>
+#include <linux/slab.h>
+
+#include <d3/d3-jetson-bsp.h>
+
+#define MAX_DEBUG 1
+#define MAX_DEBUG_GMSL_BACKCHANNEL 0
+
+#include "max9295.h"
+#include "max9295_tables.h"
+#include "serdes.h"
+
+enum {
+	CHIP_MAX9295 = 0,
+};
+
+static struct i2c_device_id max9295_idtable[] = {
+	{"max9295", CHIP_MAX9295},
+	{},
+};
+MODULE_DEVICE_TABLE(i2c, max9295_idtable);
+
+static struct of_device_id max9295_of_match[] = {
+	{ .compatible = "maxim,max9295"},
+	{},
+};
+MODULE_DEVICE_TABLE(of, max9295_of_match);
+
+/* I2C address translation related structures */
+struct max9295_addr_map_list {
+	u32 src;
+	u32 dst;
+	struct list_head list;
+};
+
+const static struct ser_i2c_map_regs max9295_i2c_map_regs[] = {
+	{MAX9295_REG_SRC_A, MAX9295_REG_DST_A},
+	{MAX9295_REG_SRC_B, MAX9295_REG_DST_B}
+};
+
+#ifdef MAX_DEBUG
+/* Let some registers be read via debugfs */
+static const struct regmap_range max9295_yes_ranges[] = {
+	regmap_reg_range(0, 6),
+	regmap_reg_range(0xD, 0x13),
+	regmap_reg_range(0x18, 0x25),
+	regmap_reg_range(0x40, 0x47), /* I2C */
+	regmap_reg_range(0x1D9, 0x1DA),
+	regmap_reg_range(0x2D6, 0x2D8), /* GPIOs */
+	regmap_reg_range(0x308, 0x328),
+	regmap_reg_range(0x314, 0x314),
+	regmap_reg_range(0x316, 0x316),
+	regmap_reg_range(0x330, 0x334),
+	regmap_reg_range(0x40A, 0x40A),
+	regmap_reg_range(0x44A, 0x44A),
+	regmap_reg_range(0x48A, 0x48A),
+	regmap_reg_range(0x4CA, 0x4CA),
+	regmap_reg_range(0x540, 0x541), /* CFG0, CFG1 */
+	regmap_reg_range(0xB04, 0xB08), /* HIM, DBL, HVEN */
+	regmap_reg_range(0xB0D, 0xB1D), /* I2C_LOC_ACK */
+	regmap_reg_range(0xF03, 0xF04), /* GMSL1 ERR */
+	regmap_reg_range(0x14C4, 0x14C4),
+	regmap_reg_range(0x14C5, 0x14C5),
+};
+
+static const struct regmap_access_table max9295_regmap_rd_access_table = {
+	.yes_ranges = max9295_yes_ranges,
+	.n_yes_ranges = ARRAY_SIZE(max9295_yes_ranges),
+};
+#endif /* MAX_DEBUG */
+
+static const struct regmap_config max9295_regmap_config = {
+	.reg_bits = 16,
+	.val_bits = 8,
+#ifdef MAX_DEBUG
+	.max_register = 0x1f17,
+	.rd_table = &max9295_regmap_rd_access_table,
+#endif  /* MAX_DEBUG */
+};
+
+/*
+ * Wrapper around regmap_read that prints errors.
+ */
+/* static int max9295_regmap_read(struct serializer *priv, u32 reg, u32 *val) */
+/* { */
+/* 	struct device *dev = &priv->client->dev; */
+/* 	struct regmap *map = priv->map; */
+/* 	int ret = 0; */
+
+/* 	reg &= 0xFFFF; */
+/* 	ret = regmap_read(map, reg, val); */
+/* 	if (ret) */
+/* 		dev_err(dev, "Failed reading register 0x%x\n", reg); */
+/* 	return ret; */
+/* } */
+
+/*
+ * Wrapper around regmap_write that prints errors.
+ */
+
+static int max9295_regmap_write(struct serdes *serdes, u32 reg, u32 val)
+{
+	struct device *dev = &serdes->client->dev;
+	struct regmap *map = serdes->map;
+	int ret = 0;
+
+	reg &= 0xFFFF;
+	val &= 0xFF;
+	ret = regmap_write(map, reg, val);
+	if (ret)
+		dev_err(dev, "Failed writing register 0x%x\n", reg);
+	return ret;
+}
+
+/* One-shot reset; resets the GMSL link but keeps the register settings */
+/* static int max9295_one_shot_reset(struct serializer *priv) */
+/* { */
+/* 	const struct reg_sequence one_shot_reset[] = { */
+/* 		{ 0x0010, 0x30, 100000 }, */
+/* 	}; */
+
+/* 	return regmap_multi_reg_write(priv->map, one_shot_reset, */
+/* 			ARRAY_SIZE(one_shot_reset)); */
+/* } */
+
+/* static int max9295_set_lane_count(struct serializer *priv) */
+/* { */
+/* 	struct device *dev = &priv->client->dev; */
+/* 	unsigned reg_val = 0; */
+/* 	unsigned regs[] = { 0x40A, 0x44A, 0x48A, 0x4CA }; /\* MIPI_TX10 *\/ */
+/* 	int i = 0; */
+
+/* 	/\* The MAX9296 register documentation is poorly written. Until it gets */
+/* 	 * better, the values that go in the MIPI_TX10 are a sort of best guess. */
+/* 	 *\/ */
+/* 	switch (priv->csi_config.num_lanes) { */
+/* 	case 1: */
+/* 		reg_val = 0; */
+/* 		break; */
+/* 	case 2: */
+/* 		reg_val = 0x40; */
+/* 		break; */
+/* 	case 4: */
+/* 		reg_val = 0xC0; */
+/* 		break; */
+/* 	default: */
+/* 		dev_err(dev, "Invalid number of CSI lanes: %d", */
+/* 				priv->csi_config.num_lanes); */
+/* 		return -EINVAL; */
+/* 	} */
+
+/* 	for (i = 0; i < ARRAY_SIZE(regs); i++) */
+/* 		max9295_regmap_write(priv, regs[i], reg_val); */
+/* 	return 0; */
+/* } */
+
+/* static int max9295_set_csi_freq(struct serializer *priv) */
+/* { */
+/* 	unsigned f = 16; /\* frequency as multiple of 100MHz *\/ */
+/* 	unsigned reg_val = 0; */
+/* 	unsigned regs[] = { */
+/* 		MAX9295_REG_BACKTOP22, /\* phy0 *\/ */
+/* 		MAX9295_REG_BACKTOP25, /\* phy1 *\/ */
+/* 		MAX9295_REG_BACKTOP28, /\* phy2 *\/ */
+/* 		MAX9295_REG_BACKTOP31, /\* phy3 *\/ */
+/* 	}; */
+/* 	int i = 0; */
+/* 	int ret = 0; */
+
+/* 	if (priv->csi_config.freq_mhz != 0) { */
+/* 		f = (priv->csi_config.freq_mhz / 100 ) & 0x1F; */
+/* 		for (i = 0; i < ARRAY_SIZE(regs); i++) { */
+/* 			ret = max9295_regmap_read(priv, regs[i], &reg_val); */
+/* 			if (ret) */
+/* 				continue; */
+/* 			reg_val &= 0xE0; */
+/* 			reg_val |= f; */
+/* 			max9295_regmap_write(priv, regs[i], reg_val); */
+/* 		} */
+/* 	} */
+/* 	return 0; */
+/* } */
+
+/* static int max9295_set_csi_parameters(struct serializer *priv, struct device_node *node) */
+/* { */
+/* 	int ret; */
+
+/* 	ret = of_property_read_u32(node, "csi-lane-count", */
+/* 			&priv->csi_config.num_lanes); */
+/* 	if (ret == 0) */
+/* 		max9295_set_lane_count(priv); */
+/* 	ret = of_property_read_u32(node, "csi-tx-speed-mbps", */
+/* 			&priv->csi_config.freq_mhz); */
+/* 	if (ret == 0) */
+/* 		max9295_set_csi_freq(priv); */
+/* 	return 0; */
+/* } */
+
+/* TODO: set_gmsl_bit_rates needs to be refactored so it handles both
+ * max9296 and max9295.
+ */
+static int max9295_set_gmsl_bit_rates(struct serdes *serdes)
+{
+	struct device *dev = &serdes->client->dev;
+	struct reg_sequence set_gmsl_speed[] = {
+		{.reg = 0x01, .def = 0, .delay_us = 0},
+		{.reg = 0x10, .def = 0x31, .delay_us = 100000},
+	};
+	u8 enc_forward = 0; /* encoded rate */
+	u8 enc_back = 0;
+	int ret = 0;
+
+	dev_dbg(dev, "Setting bit rates.");
+	switch(serdes->serial_config.back_bit_rate) {
+	case (187):
+		enc_forward = MAX9295_BACK_RATE_187_5MHZ;
+		break;
+	case (375):
+		enc_forward = MAX9295_BACK_RATE_375MHZ;
+		break;
+	case (750):
+		enc_forward = MAX9295_BACK_RATE_750MHZ;
+		break;
+	case (1500):
+		enc_forward = MAX9295_BACK_RATE_1500MHZ;
+		break;
+	default:
+		dev_err(dev, "Invalid GMSL TX rate: %d",
+				serdes->serial_config.back_bit_rate);
+		return -1;
+
+	}
+	switch(serdes->serial_config.forward_bit_rate) {
+	case (1500):
+		enc_back = MAX9295_FORWARD_RATE_1500MHZ;
+		break;
+	case (3000):
+		enc_back = MAX9295_FORWARD_RATE_3000MHZ;
+		break;
+	case (6000):
+		enc_back = MAX9295_FORWARD_RATE_6000MHZ;
+		break;
+	default:
+		dev_err(dev, "Invalid GMSL RX rate: %d",
+				serdes->serial_config.forward_bit_rate);
+		return -1;
+
+	}
+	set_gmsl_speed[0].def = MAX9295_GMSL_RATE(enc_forward, enc_back);
+	dev_dbg(dev, "Setting GMSL rate to: 0x%x",
+			set_gmsl_speed[0].def);
+	ret = regmap_multi_reg_write(serdes->map, set_gmsl_speed,
+			ARRAY_SIZE(set_gmsl_speed));
+	return ret;
+}
+
+/* Search the device tree for i2c address translations */
+int max9295_get_child_addr(struct device_node *node,
+		struct list_head *list)
+{
+	struct device_node *link = NULL;
+	struct device_node *child = NULL;
+	unsigned reg = 0;
+	unsigned addr =  0;
+	struct max9295_addr_map_list *tmp;
+	int ret = 0;
+	int found = false;
+
+	for_each_available_child_of_node(node, link) {
+		if (strcmp(link->name, "link"))
+			continue;
+		for_each_available_child_of_node(link, child) {
+			ret = of_property_read_u32(child, "physical-addr",
+					&addr);
+			if (ret != 0)
+				continue;
+			ret = of_property_read_u32(child, "reg", &reg);
+			if (ret != 0)
+				continue;
+			tmp = (struct max9295_addr_map_list *)
+				kzalloc(sizeof(struct max9295_addr_map_list), GFP_KERNEL);
+			tmp->src = reg;
+			tmp->dst = addr;
+			list_add(&tmp->list, list);
+			found = true;
+		}
+	}
+	return found;
+}
+
+/*
+ * Set up an I2C address translation by setting the SRC_[AB], DST_[AB]registers
+ * MAX9295 has two pairs of registers, therefore it can do up to 2 translations
+ * @priv: max9295 private data
+ * @src: the address the client will appear to have after translation
+ * @dst: the actual address of the client
+ *
+ * Return: 0 if the translation was set up successfully, -1 if otherwise.
+ */
+static int max9295_add_i2c_translation(struct serdes *serdes, u32 src, u32 dst)
+{
+	int i = serdes->num_i2c_maps;
+
+	if (i < MAX9295_I2C_TRANS_MAX) {
+		max9295_regmap_write(serdes, max9295_i2c_map_regs[i].src,
+				     src << 1);
+		max9295_regmap_write(serdes, max9295_i2c_map_regs[i].dst,
+				     dst << 1);
+		serdes->num_i2c_maps++;
+		return 0;
+	}
+	return -1;
+}
+
+int max9295_gmsl2_init(struct serdes *serdes, struct device_node *node)
+{
+	unsigned gmsl_bit_rates[2] = {0, 0};
+	int ret;
+
+	ret = of_property_read_u32_array(node, "gmsl-bit-rates",
+			gmsl_bit_rates, 2);
+	if (ret == 0) {
+		serdes->serial_config.forward_bit_rate = gmsl_bit_rates[0];
+		serdes->serial_config.back_bit_rate = gmsl_bit_rates[1];
+		return max9295_set_gmsl_bit_rates(serdes);
+	}
+	return 0;
+}
+
+/* static int max9295_of_address_translations(struct device_node *node, */
+/* 		u32 *src, u32 *dst) */
+/* { */
+/* 	u32 reg; */
+/* 	u32 phys_addr; */
+
+/* 	of_property_read_u32(node, "reg", &reg); */
+/* 	of_property_read_u32(node, "physical-addr", &phys_addr); */
+
+/* 	if (!reg || !phys_addr) */
+/* 		return -ENXIO; */
+/* 	if (reg == phys_addr) */
+/* 		return -EINVAL; */
+
+/* 	*src = reg; */
+/* 	*dst = phys_addr; */
+/* 	return 0; */
+/* } */
+
+static int max9295_probe(struct i2c_client *client,
+			 const struct i2c_device_id *id)
+{
+	struct i2c_adapter *adap = to_i2c_adapter(client->dev.parent);
+	struct serializer *priv = NULL;
+	int ret = 0;
+
+	dev_dbg(&client->dev, "Probing %s.\n",
+			max9295_idtable[id->driver_data].name);
+
+	if (!IS_ENABLED(CONFIG_OF) || !client->dev.of_node)
+		return -EINVAL;
+
+	priv = devm_kzalloc(&client->dev, sizeof(struct serializer), GFP_KERNEL);
+	if (!priv) {
+		dev_err(&client->dev, "failed to allocate memory!\n");
+		return -ENOMEM;
+	}
+
+	priv->serdes.client = client;
+	i2c_set_clientdata(client, priv);
+
+	priv->serdes.map = devm_regmap_init_i2c(client, &max9295_regmap_config);
+	if (IS_ERR(priv->serdes.map)) {
+		dev_err(&client->dev, "Failed to create regmap.\n");
+		return PTR_ERR(priv->serdes.map);
+	}
+
+	ret = serdes_mux_init(&priv->serdes, SER_MAX_CHANNELS);
+	if (ret != 0) {
+		return ret;
+	}
+
+	ret = regmap_multi_reg_write(priv->serdes.map,
+				     max9295_init_seq,
+				     ARRAY_SIZE(max9295_init_seq));
+	if (ret < 0) {
+		dev_err(&client->dev, "Failed to write registers.\n");
+		return ret;
+	}
+
+	// No priv, no flags (look for i2c-mux in dts)
+	priv->serdes.mux_core = i2c_mux_alloc(adap,
+					      &client->dev,
+					      SER_MAX_CHANNELS,
+					      0, 0,
+					      serdes_select_i2c_chan,
+					      serdes_deselect_i2c_chan);
+
+	if (!priv->serdes.mux_core) {
+		dev_err(&client->dev, "failed to allocate mux core");
+		return -ENOMEM;
+	}
+
+
+	dev_dbg(&client->dev, "Scanning for children nodes in DT..\n");
+
+	/* Scan the device tree for i2c slave buses */
+	return serdes_of_scan_links(&priv->serdes,
+				    MAX9295_NUM_CHANNELS,
+				    max9295_add_i2c_translation);
+
+}
+/* static int max9295_chip_9295_init(struct serializer *priv) */
+/* { */
+/* 	struct device *dev = &priv->client->dev; */
+/* 	struct device_node *node = dev->of_node; */
+/* 	LIST_HEAD(addr_list); */
+/* 	struct max9295_addr_map_list *p; */
+/* 	int ret; */
+
+/* 	ret = max9295_get_child_addr(node, &addr_list); */
+/* 	list_for_each_entry(p, &addr_list, list) { */
+/* 		dev_dbg(dev, "Test: 0x%x -> 0x%x.\n", p->src, p->dst); */
+/* 		max9295_add_i2c_translation(priv, p->src, p->dst); */
+/* 		/\* TODO: detelte the list elements and free the memory *\/ */
+/* #if 0 */
+/* 		list_del(&p->list); */
+/* 		kfree(p); */
+/* #endif */
+/* 	} */
+/* 	return 0; */
+/* } */
+
+static int max9295_remove(struct i2c_client *client)
+{
+	dev_info(&client->dev, "Removing MAX9295.");
+	return 0;
+}
+
+static struct i2c_driver max9295_driver = {
+	.driver = {
+		.name = "max9295",
+		.owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(max9295_of_match),
+	},
+	.probe = max9295_probe,
+	.remove = max9295_remove,
+	.id_table = max9295_idtable,
+};
+
+module_i2c_driver(max9295_driver);
+
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Catalin Petrescu <cpetrescu@d3engineering.com>");
+MODULE_DESCRIPTION("Maxim MAX9295A CSI-2/parallel to GMSL2 Serializer driver");
+MODULE_VERSION(D3_JETSON_BSP_VERSION);
+
diff --git a/drivers/d3/max9296/max9295.h b/drivers/d3/max9296/max9295.h
new file mode 100644
index 000000000000..42e66ea23a12
--- /dev/null
+++ b/drivers/d3/max9296/max9295.h
@@ -0,0 +1,77 @@
+/*
+ * max9295.h - Maxim 9295 registers and constants.
+ *
+ * Copyright (c) 2018, 2019, D3 Engineering.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef _MAX9295_H_
+#define _MAX9295_H_
+
+enum {
+	MAX9295_CH0,
+	MAX9295_NUM_CHANNELS,
+};
+
+/* The maximum number of I2C address translations that the chip can do */
+#define MAX9295_I2C_TRANS_MAX 2U
+
+#define MAX9295_BACK_RATE_OFFSET 0U
+#define MAX9295_FORWARD_RATE_OFFSET 2U
+
+#define MAX9295_FORWARD_RATE_MASK (3U << MAX9295_FORWARD_RATE_OFFSET)
+#define MAX9295_BACK_RATE_MASK (3U << MAX9295_BACK_RATE_OFFSET)
+
+#define MAX9295_BACK_RATE_187_5MHZ 0U
+#define MAX9295_BACK_RATE_375MHZ   1U
+#define MAX9295_BACK_RATE_750MHZ   2U
+#define MAX9295_BACK_RATE_1500MHZ  3U
+#define MAX9295_BACK_RATE_DEFAULT MAX9295_BACK_RATE_187_5MHZ
+
+#define MAX9295_FORWARD_RATE_1500MHZ 0U
+#define MAX9295_FORWARD_RATE_3000MHZ 1U
+#define MAX9295_FORWARD_RATE_6000MHZ 2U
+#define MAX9295_FORWARD_RATE_DEFAULT MAX9295_FORWARD_RATE_6000MHZ
+
+#define MAX9295_GMSL_RATE(BACK_RATE, FORWARD_RATE) \
+	(((BACK_RATE) << MAX9295_BACK_RATE_OFFSET) & MAX9295_BACK_RATE_MASK) | \
+	(((FORWARD_RATE) << MAX9295_FORWARD_RATE_OFFSET) & MAX9295_FORWARD_RATE_MASK)
+
+#define MAX9295_GMSL_RATE_DEFAULT \
+	MAX9295_GMSL_RATE(MAX9295_BACK_RATE_DEFAULT, MAX9295_FORWARD_RATE_DEFAULT)
+
+#define MAX9295_FWDCCEN (1 << 0)
+#define MAX9295_REVCCEN (1 << 1)
+
+/* Registers */
+#define MAX9295_REG_REG0 0x0
+#define MAX9295_REG_REG1 0x1
+
+#define MAX9295_REG_CTRL0 0x10
+
+#define MAX9295_REG_SRC_A 0x42
+#define MAX9295_REG_DST_A 0x43
+#define MAX9295_REG_SRC_B 0x44
+#define MAX9295_REG_DST_B 0x45
+
+#define MAX9295_REG_BACKTOP22 0x31D
+#define MAX9295_REG_BACKTOP25 0x320
+#define MAX9295_REG_BACKTOP28 0x323
+#define MAX9295_REG_BACKTOP31 0x326
+
+#define MAX9295_REG_GMSL1_4_A 0x0B04
+#define MAX9295_REG_GMSL1_4_B 0x0C04
+
+#endif /* _MAX9295_H_ */
+
diff --git a/drivers/d3/max9296/max9295_tables.h b/drivers/d3/max9296/max9295_tables.h
new file mode 100644
index 000000000000..228dc621086f
--- /dev/null
+++ b/drivers/d3/max9296/max9295_tables.h
@@ -0,0 +1,102 @@
+/*
+ * max9295_tables.h - Maxim MAX9295 CSI-2 to GMSL2 Serializer
+ *
+ * Copyright (c) 2018, 2019, D3 Engineering.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef _MAX9295_TABLES_H_
+#define _MAX9295_TABLES_H_
+
+#include "max9295.h"
+
+static struct reg_sequence max9295_init_seq[] = {
+	{ .reg = 0x0001, .def = 0x08, .delay_us = 0, }, /* link speed 6Gbps */
+	{ .reg = 0x0010, .def = 0x21, .delay_us = 100000, }, /* Reset one shot */
+	{ .reg = 0x0330, .def = 0x00, .delay_us = 0 }, /* MIPI_RX0 Set PHY to 1x4 mode*/
+	{ .reg = 0x0332, .def = 0xBE, .delay_us = 0 }, /* [E0] MIPI_RX2 Lane Mapping Register 1 Swap lanes 0 & 1 for HAS000302*/
+	{ .reg = 0x0333, .def = 0xE1, .delay_us = 0 }, /* [04] MIPI_RX3 Lane Mapping Register 2 Swap lanes 2 & 3 for HAS000302*/
+	{ .reg = 0x0331, .def = 0x33, .delay_us = 0 }, /* MIPI_RX1 Enable Port A & B as they are shared in MAX9295A*/
+	{ .reg = 0x0308, .def = 0x6F, .delay_us = 0 }, /* FRONTTOP_0 CSI Port selection Port B active in 1 x 4 mode*/
+	{ .reg = 0x0311, .def = 0x20, .delay_us = 0 }, /* FRONTTOP_9 Start video pipe Y*/
+	{ .reg = 0x0314, .def = 0x22, .delay_us = 0 }, /* FRONTTOP_12 Pipe X unused*/
+	{ .reg = 0x0316, .def = 0x6C, .delay_us = 0 }, /* FRONTTOP_14 Datatype RAW12*/
+	{ .reg = 0x0318, .def = 0x22, .delay_us = 0 }, /* FRONTTOP_16 Pipe Z unused*/
+	{ .reg = 0x031A, .def = 0x22, .delay_us = 0 }, /* FRONTTOP_18 Pipe U unused*/
+	{ .reg = 0x02d6, .def = 0x94, .delay_us = 0 }, /* GPIO8 (Frame Sync Output): Enable GPIO RX from deserializer */
+	{ .reg = 0x02d7, .def = 0xb8, .delay_us = 0 }, /* GPIO8 (Frame Sync Output): Set TX ID to 0x18 */
+	{ .reg = 0x02d8, .def = 0x18, .delay_us = 0 }, /* GPIO8 (Frame Sync Output): Set RX ID to 0x18 */
+	{ .reg = 0x0002, .def = 0xF3, .delay_us = 0 }, /* REG2 Make sure all pipes start transmission*/
+};
+
+/* static struct reg_sequence max9295_set_gmsl_speed[] = { */
+/* 	{.reg = 0x01, .def = MAX9295_GMSL_RATE_DEFAULT, .delay_us = 0}, */
+/* 	{.reg = 0x10, .def = 0x21, .delay_us = 100000}, */
+/* }; */
+
+/* static struct reg_sequence max9295_assign_address_40[] = { */
+/* 	{ .reg = 0x0010, .def = 0x31, .delay_us = 100000 }, */
+/* 	{ .reg = 0x006B, .def = 0x10 }, */
+/* 	{ .reg = 0x0073, .def = 0x11 }, */
+/* 	{ .reg = 0x007B, .def = 0x30 }, */
+/* 	{ .reg = 0x0083, .def = 0x30 }, */
+/* 	{ .reg = 0x0093, .def = 0x30 }, */
+/* 	{ .reg = 0x009B, .def = 0x30 }, */
+/* 	{ .reg = 0x00A3, .def = 0x30 }, */
+/* 	{ .reg = 0x00AB, .def = 0x30 }, */
+/* 	{ .reg = 0x008B, .def = 0x30 }, */
+/* }; */
+
+/* static struct reg_sequence max9295_assign_address_42[] = { */
+/* 	{ .reg = 0x0010, .def = 0x31, .delay_us = 100000 }, */
+/* 	{ .reg = 0x006B, .def = 0x10 }, */
+/* 	{ .reg = 0x0073, .def = 0x10 }, */
+/* 	{ .reg = 0x007B, .def = 0x31 }, */
+/* 	{ .reg = 0x0083, .def = 0x31 }, */
+/* 	{ .reg = 0x0093, .def = 0x31 }, */
+/* 	{ .reg = 0x009B, .def = 0x31 }, */
+/* 	{ .reg = 0x00A3, .def = 0x31 }, */
+/* 	{ .reg = 0x00AB, .def = 0x31 }, */
+/* 	{ .reg = 0x008B, .def = 0x31 }, */
+/* }; */
+
+/* static struct reg_sequence max9295_assign_address_60[] = { */
+/* 	{ .reg = 0x0010, .def = 0x31, .delay_us = 100000 }, */
+/* 	{ .reg = 0x006B, .def = 0x12 }, */
+/* 	{ .reg = 0x0073, .def = 0x13 }, */
+/* 	{ .reg = 0x007B, .def = 0x32 }, */
+/* 	{ .reg = 0x0083, .def = 0x32 }, */
+/* 	{ .reg = 0x0093, .def = 0x32 }, */
+/* 	{ .reg = 0x009B, .def = 0x32 }, */
+/* 	{ .reg = 0x00A3, .def = 0x32 }, */
+/* 	{ .reg = 0x00AB, .def = 0x32 }, */
+/* 	{ .reg = 0x008B, .def = 0x32 }, */
+/* }; */
+
+/* static struct reg_sequence max9295_assign_address_62[] = { */
+/* 	{ .reg = 0x0010, .def = 0x31, .delay_us = 100000 }, */
+/* 	{ .reg = 0x006B, .def = 0x12 }, */
+/* 	{ .reg = 0x0073, .def = 0x13 }, */
+/* 	{ .reg = 0x007B, .def = 0x33 }, */
+/* 	{ .reg = 0x0083, .def = 0x33 }, */
+/* 	{ .reg = 0x0093, .def = 0x33 }, */
+/* 	{ .reg = 0x009B, .def = 0x33 }, */
+/* 	{ .reg = 0x00A3, .def = 0x33 }, */
+/* 	{ .reg = 0x00AB, .def = 0x33 }, */
+/* 	{ .reg = 0x008B, .def = 0x33 }, */
+/* }; */
+
+/* End I2C address reassignment stuff. */
+
+#endif /* _MAX9295_TABLES_H_ */
diff --git a/drivers/d3/max9296/max9296.c b/drivers/d3/max9296/max9296.c
new file mode 100644
index 000000000000..a664cd6d291c
--- /dev/null
+++ b/drivers/d3/max9296/max9296.c
@@ -0,0 +1,817 @@
+/*
+ * max9296.c - Maxim MAX9296 GMSL2/GMSL1 to CSI-2 Deserializer
+ *
+ * Copyright (c) 2018-2019, D3 Engineering.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+#define MAX_DEBUG 1
+#define MAX_DEBUG_GMSL_BACKCHANNEL 0
+
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/i2c.h>
+#include <linux/i2c-mux.h>
+#include <linux/regmap.h>
+#include <linux/gpio/consumer.h>
+#include <linux/sysfs.h>
+#include <linux/slab.h>
+
+#include <d3/d3-jetson-bsp.h>
+
+#include "max9296.h"
+#include "max96705.h"
+#include "max9296_tables.h"
+#include "max96705_tables.h"
+
+#include "serdes.h"
+
+enum {
+	CHIP_MAX9296 = 0,
+};
+
+static struct i2c_device_id max9296_idtable[] = {
+	{"max9296", CHIP_MAX9296},
+	{},
+};
+MODULE_DEVICE_TABLE(i2c, max9296_idtable);
+
+static struct of_device_id max9296_of_match[] = {
+	{ .compatible = "maxim,max9296"},
+	{},
+};
+MODULE_DEVICE_TABLE(of, max9296_of_match);
+
+/* I2C address translation related structures */
+struct max929x_addr_map_list {
+	u32 src;
+	u32 dst;
+	struct list_head list;
+};
+
+struct max929x_i2c_map_regs {
+	unsigned int src;
+	unsigned int dst;
+};
+
+/* TODO: This is shared by 2 functions. refactor. */
+static struct reg_sequence max96705_seraddr[] = {
+	{ MAX96705_REG_SERADDR, MAX96705_REG_SERADDR_DEFAULT },
+};
+
+/* TODO: This is shared by 2 functions. refactor. */
+static struct reg_sequence max96705_imgaddr[] = {
+	{ MAX96705_REG_SRC_A, 0 },
+	{ MAX96705_REG_DST_A, 0 },
+};
+
+/* MAX9296-MAX96705 initialization playlist */
+static const struct serdes_playlist max9296_max96705[] = {
+	/* reverse channel setup */
+	PLAYLIST_INIT('d', max9296_custom_rcs),
+	PLAYLIST_INIT('s', max96705_en_him),
+	PLAYLIST_INIT('d', max9296_en_him),
+	PLAYLIST_INIT('s', max96705_en_cfg),
+	PLAYLIST_INIT('d', max9296_dis_locack),
+	/* pre camera setup */
+	PLAYLIST_INIT('d', max9296_dis_csi),
+	PLAYLIST_INIT('s', max96705_en_dbl_hven),
+	PLAYLIST_INIT('d', max9296_en_dbl_hven),
+	/* sensor setup */
+	/* post camera setup */
+	PLAYLIST_INIT('s', max96705_en_link),
+	PLAYLIST_INIT('d', max9296_en_csi),
+	/* i2c address remapping */
+	PLAYLIST_INIT('s', max96705_imgaddr),
+	PLAYLIST_INIT('s', max96705_seraddr),
+};
+
+#ifdef MAX_DEBUG
+/* Let some registers be read via debugfs */
+static const struct regmap_range max9296_yes_ranges[] = {
+	regmap_reg_range(0, 6),
+	regmap_reg_range(0xD, 0x13),
+	regmap_reg_range(0x18, 0x25),
+	regmap_reg_range(0x40, 0x47), /* I2C */
+	regmap_reg_range(0x1D9, 0x1DA),
+	regmap_reg_range(0x2B0, 0x2B2), /* GPIOs */
+	regmap_reg_range(0x308, 0x328),
+	regmap_reg_range(0x314, 0x314),
+	regmap_reg_range(0x316, 0x316),
+	regmap_reg_range(0x330, 0x334),
+	regmap_reg_range(0x40A, 0x40A),
+	regmap_reg_range(0x44A, 0x44A),
+	regmap_reg_range(0x48A, 0x48A),
+	regmap_reg_range(0x4CA, 0x4CA),
+	regmap_reg_range(0x540, 0x541), /* CFG0, CFG1 */
+	regmap_reg_range(0xB04, 0xB08), /* HIM, DBL, HVEN */
+	regmap_reg_range(0xB0D, 0xB1D), /* I2C_LOC_ACK */
+	regmap_reg_range(0xF03, 0xF04), /* GMSL1 ERR */
+	regmap_reg_range(0x14C4, 0x14C4),
+	regmap_reg_range(0x14C5, 0x14C5),
+};
+
+static const struct regmap_access_table max9296_regmap_rd_access_table = {
+	.yes_ranges = max9296_yes_ranges,
+	.n_yes_ranges = ARRAY_SIZE(max9296_yes_ranges),
+};
+#endif /* MAX_DEBUG */
+
+static const struct regmap_config max9296_regmap_config = {
+	.reg_bits = 16,
+	.val_bits = 8,
+#ifdef MAX_DEBUG
+	.max_register = 0x1f17,
+	.rd_table = &max9296_regmap_rd_access_table,
+#endif
+};
+
+static const struct regmap_config max96705_regmap_config = {
+	.reg_bits = 8,
+	.val_bits = 8,
+};
+
+static const struct regmap_config regmap_config_16bit = {
+	.reg_bits = 16,
+	.val_bits = 16,
+};
+
+/*
+ * Wrapper around regmap_read that prints errors.
+ */
+static int max9296_regmap_read(struct deserializer *priv, u32 reg, u32 *val)
+{
+	struct device *dev = &priv->serdes.client->dev;
+	struct regmap *map = priv->serdes.map;
+	int ret = 0;
+
+	reg &= 0xFFFF;
+	ret = regmap_read(map, reg, val);
+	if (ret)
+		dev_err(dev, "Failed reading register 0x%x\n", reg);
+	return ret;
+}
+
+/*
+ * Wrapper around regmap_write that prints errors.
+ */
+
+static int max9296_regmap_write(struct deserializer *priv, u32 reg, u32 val)
+{
+	struct device *dev = &priv->serdes.client->dev;
+	struct regmap *map = priv->serdes.map;
+	int ret = 0;
+
+	reg &= 0xFFFF;
+	val &= 0xFF;
+	ret = regmap_write(map, reg, val);
+	if (ret)
+		dev_err(dev, "Failed writing register 0x%x\n", reg);
+	return ret;
+}
+
+/* Set GMSL link state for 9296 */
+static int max9296_set_link_state(struct deserializer* priv, unsigned link,
+		int state)
+{
+	int ret;
+	u32 reg_val;
+	const u16 regs[] = {MAX9296_REG_GMSL1_4_A, MAX9296_REG_GMSL1_4_B};
+	u8 mask;
+
+	if (link >= MAX9296_NUM_CHANNELS)
+		return -EINVAL;
+	ret = max9296_regmap_read(priv, regs[link], &reg_val);
+	if (ret != 0)
+		return ret;
+	mask = MAX9296_REVCCEN | MAX9296_FWDCCEN;
+	reg_val = state? reg_val | mask : reg_val & ~mask;
+	return max9296_regmap_write(priv, regs[link], reg_val);
+}
+
+static inline int max9296_disable_link(struct deserializer *priv, unsigned link)
+{
+	return max9296_set_link_state(priv, link, false);
+}
+
+static inline int max9296_enable_link(struct deserializer *priv, unsigned link)
+{
+	return max9296_set_link_state(priv, link, true);
+}
+
+/* Reset all */
+static int max9296_soft_reset(struct deserializer *priv) {
+	const struct reg_sequence soft_reset[] = {
+		{ 0x0010, 0x80, 200000 },
+	};
+	return regmap_multi_reg_write(priv->serdes.map, soft_reset,
+			ARRAY_SIZE(soft_reset));
+}
+
+/* One-shot reset; resets the GMSL link but keeps the register settings */
+/* static int max9296_one_shot_reset(struct deserializer *priv) */
+/* { */
+/* 	const struct reg_sequence one_shot_reset[] = { */
+/* 		{ 0x0010, 0x30, 100000 }, */
+/* 	}; */
+
+/* 	return regmap_multi_reg_write(priv->map, one_shot_reset, */
+/* 			ARRAY_SIZE(one_shot_reset)); */
+/* } */
+
+static int max9296_set_lane_count(struct deserializer *priv)
+{
+	struct device *dev = &priv->serdes.client->dev;
+	unsigned reg_val = 0;
+	unsigned regs[] = { 0x40A, 0x44A, 0x48A, 0x4CA }; /* MIPI_TX10 */
+	int i = 0;
+
+	/* The MAX9296 register documentation is poorly written. Until it gets
+	 * better, the values that go in the MIPI_TX10 are a sort of best guess.
+	 */
+	switch (priv->serdes.csi_config.num_lanes) {
+	case 1:
+		reg_val = 0;
+		break;
+	case 2:
+		reg_val = 0x40;
+		break;
+	case 4:
+		reg_val = 0xC0;
+		break;
+	default:
+		dev_err(dev, "Invalid number of CSI lanes: %d",
+				priv->serdes.csi_config.num_lanes);
+		return -EINVAL;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(regs); i++)
+		max9296_regmap_write(priv, regs[i], reg_val);
+	return 0;
+}
+
+static int max9296_set_csi_freq(struct deserializer *priv)
+{
+	unsigned f = 16; /* frequency as multiple of 100MHz */
+	unsigned reg_val = 0;
+	unsigned regs[] = {
+		MAX9296_REG_BACKTOP22, /* phy0 */
+		MAX9296_REG_BACKTOP25, /* phy1 */
+		MAX9296_REG_BACKTOP28, /* phy2 */
+		MAX9296_REG_BACKTOP31, /* phy3 */
+	};
+	int i = 0;
+	int ret = 0;
+
+	if (priv->serdes.csi_config.freq_mhz != 0) {
+		f = (priv->serdes.csi_config.freq_mhz / 100 ) & 0x1F;
+		for (i = 0; i < ARRAY_SIZE(regs); i++) {
+			ret = max9296_regmap_read(priv, regs[i], &reg_val);
+			if (ret)
+				continue;
+			reg_val &= 0xE0;
+			reg_val |= f;
+			max9296_regmap_write(priv, regs[i], reg_val);
+		}
+	}
+	return 0;
+}
+
+static int max9296_set_csi_parameters(struct deserializer *priv, struct device_node *node)
+{
+	int ret;
+
+	ret = of_property_read_u32(node, "csi-lane-count",
+				   &priv->serdes.csi_config.num_lanes);
+	if (ret == 0)
+		max9296_set_lane_count(priv);
+	ret = of_property_read_u32(node, "csi-tx-speed-mbps",
+			&priv->serdes.csi_config.freq_mhz);
+	if (ret == 0)
+		max9296_set_csi_freq(priv);
+	return 0;
+}
+
+/* TODO: set_gmsl_bit_rates needs to be refactored so it handles both
+ * max9296 and max9295.
+ */
+static int max9296_set_gmsl_bit_rates(struct deserializer *priv)
+{
+	struct device *dev = &priv->serdes.client->dev;
+	struct reg_sequence set_gmsl_speed[] = {
+		{.reg = 0x01, .def = 0, .delay_us = 0},
+		{.reg = 0x10, .def = 0x31, .delay_us = 100000},
+	};
+	u8 enc_back = 0; /* encoded rate */
+	u8 enc_forward = 0;
+	int ret = 0;
+
+	dev_dbg(dev, "Setting bit rates.");
+	switch(priv->serdes.serial_config.back_bit_rate) {
+	case (187):
+		enc_back = MAX9296_BACK_RATE_187_5MHZ;
+		break;
+	case (375):
+		enc_back = MAX9296_BACK_RATE_375MHZ;
+		break;
+	case (750):
+		enc_back = MAX9296_BACK_RATE_750MHZ;
+		break;
+	case (1500):
+		enc_back = MAX9296_BACK_RATE_1500MHZ;
+		break;
+	default:
+		dev_err(dev, "Invalid GMSL TX rate: %d",
+				priv->serdes.serial_config.back_bit_rate);
+		return -1;
+
+	}
+	switch(priv->serdes.serial_config.forward_bit_rate) {
+	case (1500):
+		enc_forward = MAX9296_FORWARD_RATE_1500MHZ;
+		break;
+	case (3000):
+		enc_forward = MAX9296_FORWARD_RATE_3000MHZ;
+		break;
+	case (6000):
+		enc_forward = MAX9296_FORWARD_RATE_6000MHZ;
+		break;
+	default:
+		dev_err(dev, "Invalid GMSL RX rate: %d",
+				priv->serdes.serial_config.forward_bit_rate);
+		return -1;
+
+	}
+	set_gmsl_speed[0].def = MAX9296_GMSL_RATE(enc_back, enc_forward);
+	dev_dbg(dev, "Setting GMSL rate to: 0x%x",
+			set_gmsl_speed[0].def);
+	ret = regmap_multi_reg_write(priv->serdes.map, set_gmsl_speed,
+			ARRAY_SIZE(set_gmsl_speed));
+	return ret;
+}
+
+/* Search the device tree for i2c address translations */
+int max9296_get_child_addr(struct device_node *node,
+		struct list_head *list)
+{
+	struct device_node *link = NULL;
+	struct device_node *child = NULL;
+	unsigned reg = 0;
+	unsigned addr =  0;
+	struct max929x_addr_map_list *tmp;
+	int ret = 0;
+	int found = false;
+
+	for_each_available_child_of_node(node, link) {
+		if (strcmp(link->name, "link"))
+			continue;
+		for_each_available_child_of_node(link, child) {
+			ret = of_property_read_u32(child, "physical-addr",
+					&addr);
+			if (ret != 0)
+				continue;
+			ret = of_property_read_u32(child, "reg", &reg);
+			if (ret != 0)
+				continue;
+			tmp = (struct max929x_addr_map_list *)
+				kzalloc(sizeof(struct max929x_addr_map_list), GFP_KERNEL);
+			tmp->src = reg;
+			tmp->dst = addr;
+			list_add(&tmp->list, list);
+			found = true;
+		}
+	}
+	return found;
+}
+
+/*
+ * Change the I2C address of a MAX9295 serializer.
+ * When the deserializer can't perform the address translation (and MAX9296
+ * seems to be unable to), an alternative is to set change the I2C address by
+ * writing the DEV_ADDR register (reg 0) of the serializer.
+ * It is a multi step process, so use it only when the other method doesn't
+ * work.
+ * @priv: max9296 private data
+ * @src: the address the client will appear to have after translation
+ * @dst: the actual address of the client
+ *
+ * Return: 0 if the translation was set up successfully, -1 if otherwise.
+ */
+static int max9296_change_device_addr(struct deserializer *priv, u32 src, u32 dst)
+{
+	struct device *dev = &priv->serdes.client->dev;
+	struct i2c_adapter *adapter =
+		to_i2c_adapter(priv->serdes.client->dev.parent);
+	struct i2c_client *r_client = NULL;
+	struct i2c_client *v_client = NULL;
+	struct regmap *r_map = NULL;
+	struct regmap *v_map = NULL;
+	struct reg_sequence *seq = NULL;
+	unsigned seq_len = 0;
+	int ret = 0;
+
+	dev_dbg(dev, "%s.\n", __func__);
+	if (priv->link_type == LINK_TYPE_GMSL1) {
+		dev_dbg(dev, "Don't rewrite addresses for GMSL1!");
+		return 0;
+	}
+	ret = serdes_create_dummy(adapter, dst,
+			&max9296_regmap_config,
+			&r_client, &r_map);
+	if (ret != 0) {
+		dev_err(dev, "Error creating dummy device: 0x%x.\n", dst);
+		/*TODO: What if the dummy device is created, then regmap
+		 * initialization fails?
+		 */
+		return ret;
+	}
+
+	ret = serdes_create_dummy(adapter, src,
+			&max9296_regmap_config,
+			&v_client, &v_map);
+	if (ret != 0) {
+		dev_err(dev, "Error creating dummy device: 0x%0x.\n", src);
+		goto dev_addr_exit2;
+	}
+	/* steps 1,2 */
+	ret = regmap_multi_reg_write(priv->serdes.map,
+				     max9296_enable_link_a_only,
+				     ARRAY_SIZE(max9296_enable_link_a_only));
+	if(ret < 0) {
+		dev_err(dev, "Step 1 failed %d\n", ret);
+		goto dev_addr_exit1;
+	}
+
+	/* Write DEV_ADDR on MAX9295 client */
+	ret = regmap_write(r_map, MAX9296_REG_REG0, src << 1);
+	if (ret < 0) {
+		dev_err(dev, "Failed writing DEV_ADDR: %d\n", ret);
+		goto dev_addr_exit1;
+	}
+	/* write magic */
+	switch(src) {
+	case 0x40:
+		seq = max9295_assign_address_40;
+		seq_len = ARRAY_SIZE(max9295_assign_address_40);
+		break;
+	case 0x42:
+		seq = max9295_assign_address_42;
+		seq_len = ARRAY_SIZE(max9295_assign_address_42);
+		break;
+	case 0x60:
+		seq = max9295_assign_address_60;
+		seq_len = ARRAY_SIZE(max9295_assign_address_60);
+		break;
+	case 0x62:
+		seq = max9295_assign_address_62;
+		seq_len = ARRAY_SIZE(max9295_assign_address_62);
+		break;
+	default:
+		dev_err(dev, "Invalid address: 0x%x\n", src);
+		goto dev_addr_exit1;
+	}
+
+	ret = regmap_multi_reg_write(v_map, seq, seq_len);
+	if(ret < 0) {
+		dev_err(dev, "Step 7 failed %d\n", ret);
+		goto dev_addr_exit1;
+	}
+
+	ret = regmap_multi_reg_write(priv->serdes.map, max9296_enable_link_both,
+				     ARRAY_SIZE(max9296_enable_link_both));
+	if(ret < 0) {
+		dev_err(dev, "Step 9 failed %d\n", ret);
+		goto dev_addr_exit1;
+	}
+
+dev_addr_exit1:
+	if (v_map)
+		regmap_exit(v_map);
+	i2c_unregister_device(v_client);
+dev_addr_exit2:
+	if (r_map)
+		regmap_exit(r_map);
+	i2c_unregister_device(r_client);
+	return ret;
+}
+
+#define IS_WORTH_RETRYING(ret) ( ret == -ETIMEDOUT \
+		|| ret == -EAGAIN \
+		|| ret == -EREMOTEIO \
+		)
+
+static int max9296_play_init_sequence(struct device *dev,
+		const struct serdes_playlist *pl, unsigned len,
+		struct regmap *des_map, struct regmap *ser_map,
+		struct regmap *sen_map)
+{
+	int ret = 0;
+	int i = 0;
+	const int max_retries = 3;
+
+	for (i = 0; i < len; i++) {
+		unsigned try_cnt = 0;
+		struct regmap *p;
+		p = pl[i].target == 'd' ? des_map
+		  : pl[i].target == 's' ? ser_map
+		  : sen_map;
+#if MAX_DEBUG_GMSL_BACKCHANNEL
+		/* back channel debugging */
+		if (i == 5 || i == 6) {
+			int j;
+			unsigned testval;
+			int testret;
+			int errcount = 0;
+			dev_dbg(dev, "Starting backchannel testing.");
+			for (j = 0; j < 100; j++) {
+				testret = regmap_read(ser_map, 0, &testval);
+				if (testret < 0)
+					errcount++;
+			}
+			dev_dbg(dev, "Backchannel error count: %u", errcount);
+		}
+		/* end back channel debugging */
+#endif
+		do {
+			ret = regmap_multi_reg_write(p, pl[i].seq, pl[i].len);
+			try_cnt += 1;
+			if (ret < 0) {
+				dev_dbg(dev, "Step: %u, ret: %d, try: %d.\n",
+						i, ret, try_cnt);
+				udelay(200 * try_cnt);
+			}
+		} while (IS_WORTH_RETRYING(ret) && try_cnt < max_retries);
+		if (ret < 0) {
+			dev_err(dev, "Step %d failed. ret: %d\n", i, ret);
+			return ret;
+		}
+	}
+	return ret;
+}
+
+int max9296_gmsl1_init(struct deserializer *priv, struct device_node *node,
+		const struct serdes_playlist *pl, unsigned pl_len)
+{
+	struct device *dev = &priv->serdes.client->dev;
+	struct i2c_client *client = priv->serdes.client;
+	struct i2c_adapter *i2c_parent = to_i2c_adapter(client->dev.parent);
+	struct i2c_client *ser = NULL;
+	struct regmap *ser_map = NULL;
+	struct i2c_client *sen = NULL;
+	struct regmap *sen_map = NULL;
+	unsigned ser_addr = 0x40;
+	unsigned sen_addr = 0x10;
+	const int max_retries = 5;
+	int try_cnt = 0;
+	int ret = 0;
+	u32 ser_addr_map[2] = {0, 0}; /* remapped addr, physical addr */
+	u32 sen_addr_map[2] = {0, 0}; /* remapped addr, physical addr */
+
+	dev_dbg(dev, "GMSL-1 init.\n");
+	if (!i2c_parent) {
+		dev_err(dev, "Oops! the i2c parent is NULL!\n");
+		return 0;
+	}
+
+	/* Serializer i2c address translation first */
+	ret = of_property_read_u32_array(node, "ser-addr", ser_addr_map, 2);
+	if (ret == 0) {
+		max96705_seraddr[0].def = ser_addr_map[0] << 1;
+		ser_addr = ser_addr_map[1];
+		dev_dbg(dev, "0x%x => 0x%x.\n",
+				ser_addr_map[0], ser_addr_map[1]);
+	}
+	ret = of_property_read_u32_array(node, "img-addr", sen_addr_map, 2);
+	if (ret == 0) {
+		max96705_imgaddr[0].def = sen_addr_map[0] << 1;
+		max96705_imgaddr[1].def = sen_addr_map[1] << 1;
+		sen_addr = sen_addr_map[1];
+		dev_dbg(dev, "0x%x => 0x%x.\n",
+				sen_addr_map[0], sen_addr_map[1]);
+	}
+
+	ret = serdes_create_dummy(i2c_parent, ser_addr,
+			&max96705_regmap_config,
+			&ser, &ser_map);
+	if (ret != 0) {
+		dev_err(dev, "Error creating serializer dummy");
+		return ret;
+	}
+	ret = serdes_create_dummy(i2c_parent, sen_addr,
+			&regmap_config_16bit,
+			&sen, &sen_map);
+	if (ret != 0) {
+		dev_err(dev, "Error creating sensor dummy");
+		return ret;
+	}
+
+	do {
+		ret = max9296_play_init_sequence(dev, pl, pl_len,
+						 priv->serdes.map,
+						 ser_map, sen_map);
+		try_cnt += 1;
+		if (ret < 0) {
+			dev_warn(dev, "Retrying link initialization");
+			max9296_soft_reset(priv);
+		}
+	} while (ret != 0 && try_cnt < max_retries);
+	if (ret < 0) {
+		dev_err(dev, "Link initialization failed.");
+		/* Disable the link so the SER doesn't interfere with
+		 * the other SERs being probed
+		 */
+		max9296_disable_link(priv, MAX9296_CH0);
+	} else {
+		dev_dbg(dev, "Link is up");
+	}
+
+	regmap_exit(sen_map);
+	regmap_exit(ser_map);
+	i2c_unregister_device(ser);
+	i2c_unregister_device(sen);
+	return ret;
+}
+
+int max9296_gmsl2_init(struct deserializer *priv, struct device_node *node)
+{
+	unsigned gmsl_bit_rates[2] = {0, 0};
+	int ret;
+
+	dev_dbg(&priv->serdes.client->dev, "%s.\n", __func__);
+	ret = of_property_read_u32_array(node, "gmsl-bit-rates",
+			gmsl_bit_rates, 2);
+	if (ret == 0) {
+		priv->serdes.serial_config.forward_bit_rate = gmsl_bit_rates[0];
+		priv->serdes.serial_config.back_bit_rate = gmsl_bit_rates[1];
+		ret = max9296_set_gmsl_bit_rates(priv);
+		if (ret != 0) {
+			return ret;
+		}
+	}
+
+	ret = regmap_multi_reg_write(priv->serdes.map, max9296_set_gpios,
+				     ARRAY_SIZE(max9296_set_gpios));
+	return ret;
+}
+
+/* static int max9296_of_address_translations(struct device_node *node, */
+/* 		u32 *src, u32 *dst) */
+/* { */
+/* 	u32 reg; */
+/* 	u32 phys_addr; */
+
+/* 	of_property_read_u32(node, "reg", &reg); */
+/* 	of_property_read_u32(node, "physical-addr", &phys_addr); */
+
+/* 	if (!reg || !phys_addr) */
+/* 		return -ENXIO; */
+/* 	if (reg == phys_addr) */
+/* 		return -EINVAL; */
+
+/* 	*src = reg; */
+/* 	*dst = phys_addr; */
+/* 	return 0; */
+/* } */
+
+/*
+ * Scan the children node in the device for client buses. Create an I2C adapter
+ * for each link found.
+ *
+ * @priv: max9296 private data
+ */
+
+static int max9296_serializer_is_gmsl1(struct device_node *node)
+{
+	struct device_node *link = NULL;
+	struct device_node *client = NULL;
+	const char *compatible;
+	int is_gmsl1 = 0;
+	int ret;
+
+	for_each_available_child_of_node(node, link) {
+		if (strcmp(link->name, "link"))
+			continue;
+		for_each_available_child_of_node(link, client) {
+			ret = of_property_read_string(client, "compatible",
+					&compatible);
+			if (!ret) {
+				ret = strcmp(compatible, "maxim,max96705");
+				if (ret == 0)
+					is_gmsl1 = 1;
+			}
+		}
+	}
+	return is_gmsl1;
+}
+
+static int max9296_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	struct deserializer *priv = NULL;
+	int ret = 0;
+
+	dev_dbg(&client->dev, "Probing %s.\n",
+			max9296_idtable[id->driver_data].name);
+
+	if (!IS_ENABLED(CONFIG_OF) || !client->dev.of_node)
+		return -EINVAL;
+
+	priv = devm_kzalloc(&client->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv) {
+		dev_err(&client->dev, "Failed to allocate memory.\n");
+		return -ENOMEM;
+	}
+
+	priv->serdes.client = client;
+	i2c_set_clientdata(client, priv);
+
+	/* Do chip specific initialization */
+	//pr_info("dev: %p, parent: %p\n", dev, dev->parent);
+	/* @todo make a serdes common init routine */
+	priv->serdes.map = devm_regmap_init_i2c(client, &max9296_regmap_config);
+	if (IS_ERR(priv->serdes.map)) {
+		dev_err(&client->dev, "Failed to create regmap.\n");
+		return PTR_ERR(priv->serdes.map);
+	}
+
+	// No priv, no flags (look for i2c-mux in dts)
+	ret = serdes_mux_init(&priv->serdes, DES_MAX_CHANNELS);
+	if (ret != 0) {
+		return ret;
+	}
+
+
+	ret = serdes_enable_regulators(priv, max9296_disable_link, MAX9296_CH0);
+	if (ret != 0)
+		return ret;
+
+	max9296_set_csi_parameters(priv, client->dev.of_node);
+	max9296_enable_link(priv, MAX9296_CH0);
+
+	priv->link_type = max9296_serializer_is_gmsl1(client->dev.of_node)
+		? LINK_TYPE_GMSL1 : LINK_TYPE_GMSL2;
+	if (priv->link_type == LINK_TYPE_GMSL1)
+		ret = max9296_gmsl1_init(priv, client->dev.of_node,
+				max9296_max96705, ARRAY_SIZE(max9296_max96705));
+	else
+		ret = max9296_gmsl2_init(priv, client->dev.of_node);
+	if (ret != 0)
+		return ret;
+
+	dev_dbg(&client->dev, "Scanning for children nodes in DT..\n");
+	/* Scan the device tree for i2c slave buses */
+	if ((ret = serdes_of_scan_links(
+		     &priv->serdes,
+		     MAX9296_NUM_CHANNELS,
+		     (i2c_translation_func_t)max9296_change_device_addr)) == 0)
+
+		dev_info(&client->dev, "probed");
+
+	return ret;
+}
+
+static int max9296_remove(struct i2c_client *client)
+{
+	struct deserializer *priv = NULL;
+
+	dev_info(&client->dev, "Removing MAX929x.");
+
+	priv = i2c_get_clientdata(client);
+
+	serdes_disable_regulators(priv);
+	i2c_mux_del_adapters(priv->serdes.mux_core);
+
+	/* TODO: Also, remove all the serializers */
+	return 0;
+}
+
+static struct i2c_driver max9296_driver = {
+	.driver = {
+		.name = "max9296",
+		.owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(max9296_of_match),
+	},
+	.probe = max9296_probe,
+	.remove = max9296_remove,
+	.id_table = max9296_idtable,
+};
+
+module_i2c_driver(max9296_driver);
+
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Catalin Petrescu <cpetrescu@d3engineering.com>");
+MODULE_DESCRIPTION("Maxim MAX9296A Dual GMSL2/GMSL1 to CSI-2 Deserializer driver");
+MODULE_VERSION(D3_JETSON_BSP_VERSION);
+
diff --git a/drivers/d3/max9296/max9296.h b/drivers/d3/max9296/max9296.h
new file mode 100644
index 000000000000..54fc039e6bbb
--- /dev/null
+++ b/drivers/d3/max9296/max9296.h
@@ -0,0 +1,79 @@
+/*
+ * max9296.h - Maxim 9296 registers and constants.
+ *
+ * Copyright (c) 2018, 2019, D3 Engineering.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef _MAX9296_H_
+#define _MAX9296_H_
+
+
+enum {
+	MAX9296_CH0,
+	MAX9296_CH1,
+	MAX9296_NUM_CHANNELS,
+};
+
+/* The maximum number of I2C address translations that the chip can do */
+#define MAX9296_I2C_TRANS_MAX 2U
+
+#define MAX9296_FORWARD_RATE_OFFSET 0U
+#define MAX9296_BACK_RATE_OFFSET 2U
+
+#define MAX9296_FORWARD_RATE_MASK (3U << MAX9296_FORWARD_RATE_OFFSET)
+#define MAX9296_BACK_RATE_MASK (3U << MAX9296_BACK_RATE_OFFSET)
+
+#define MAX9296_BACK_RATE_187_5MHZ 0U
+#define MAX9296_BACK_RATE_375MHZ   1U
+#define MAX9296_BACK_RATE_750MHZ   2U
+#define MAX9296_BACK_RATE_1500MHZ  3U
+#define MAX9296_BACK_RATE_DEFAULT MAX9296_BACK_RATE_187_5MHZ
+
+#define MAX9296_FORWARD_RATE_1500MHZ 0U
+#define MAX9296_FORWARD_RATE_3000MHZ 1U
+#define MAX9296_FORWARD_RATE_6000MHZ 2U
+#define MAX9296_FORWARD_RATE_DEFAULT MAX9296_FORWARD_RATE_6000MHZ
+
+#define MAX9296_GMSL_RATE(BACK_RATE, FORWARD_RATE) \
+	(((BACK_RATE) << MAX9296_BACK_RATE_OFFSET) & MAX9296_BACK_RATE_MASK) | \
+	(((FORWARD_RATE) << MAX9296_FORWARD_RATE_OFFSET) & MAX9296_FORWARD_RATE_MASK)
+
+#define MAX9296_GMSL_RATE_DEFAULT \
+	MAX9296_GMSL_RATE(MAX9296_BACK_RATE_DEFAULT, MAX9296_FORWARD_RATE_DEFAULT)
+
+#define MAX9296_FWDCCEN (1 << 0)
+#define MAX9296_REVCCEN (1 << 1)
+
+/* Registers */
+#define MAX9296_REG_REG0 0x0
+#define MAX9296_REG_REG1 0x1
+
+#define MAX9296_REG_CTRL0 0x10
+
+#define MAX9296_REG_SRC_A 0x42
+#define MAX9296_REG_DST_A 0x43
+#define MAX9296_REG_SRC_B 0x44
+#define MAX9296_REG_DST_B 0x45
+
+#define MAX9296_REG_BACKTOP22 0x31D
+#define MAX9296_REG_BACKTOP25 0x320
+#define MAX9296_REG_BACKTOP28 0x323
+#define MAX9296_REG_BACKTOP31 0x326
+
+#define MAX9296_REG_GMSL1_4_A 0x0B04
+#define MAX9296_REG_GMSL1_4_B 0x0C04
+
+#endif /* _MAX9296_H_ */
+
diff --git a/drivers/d3/max9296/max9296_tables.h b/drivers/d3/max9296/max9296_tables.h
new file mode 100644
index 000000000000..61399b0489ee
--- /dev/null
+++ b/drivers/d3/max9296/max9296_tables.h
@@ -0,0 +1,201 @@
+/*
+ * max9296_tables.h - Maxim MAX9296 GMSL2/GMSL1 to CSI-2 Deserializer
+ *
+ * Copyright (c) 2018, D3 Engineering.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef _MAX9296_TABLES_H_
+#define _MAX9296_TABLES_H_
+
+#include "max9295.h"
+#include "max9296.h"
+#include "max96705.h"
+
+/* Reverse channel setup */
+static const struct reg_sequence max9296_custom_rcs[] = {
+	{ 0x0006, 0x1F }, /* Enable GMSL1 mode on both links */
+	{ 0x0010, 0x30, 100000 }, /* One-shot reset */
+	{ 0x0B0D, 0x80 },	// I2C_LOC_ACK = 1
+	{ 0x14C5, 0x8F, 5000 },	// First pulse length
+	{ 0x14C4, 0xA0, 5000 },	// Rise and fall time
+};
+
+static const struct reg_sequence max9296_en_him[] = {
+	{ 0x0B06, 0xEF, 5000 },	// HIM = 1
+	{ 0x14C4, 0xB0, 5000 }, // Rise and fall times
+	{ 0x14C5, 0xAD, 5000 }, // First pulse length
+	{ 0x14C6, 0x12, 5000 },
+	{ 0x0F05, 0x22, 5000 }, // I2C standard-mode speed, timeout: 2ms
+	{ 0x0B05, 0x79, 5000 }, // NO_REM_MST, HVTR_MODE, EN_EQ, EQTUNE: 9.7dB
+};
+
+static const struct reg_sequence max9296_dis_locack[] = {
+	{ 0x0B0D, 0x00 },	// I2C_LOC_ACK = 0
+};
+
+/* Pre-Camera Setup */
+static const struct reg_sequence max9296_dis_csi[] = {
+	{ 0x0313,0x00 },	// Disable CSI output
+	{ 0x0F00,0x01, 16000 },	// Enable GMSL1 link A
+};
+
+static const struct reg_sequence max9296_en_dbl_hven[] = {
+	{ 0x0B07, 0x84, 16000 }, // DBL, HVEN
+};
+
+static const struct reg_sequence max9296_en_csi[] = {
+	{ 0x0B07, 0x8C, 16000 },	// HIBW
+	{ 0x0320, 0x30 },	// MIPI port A output is 1600Mbps (800MHz)
+	{ 0x044A, 0x50 },	// 2 lanes on MIPI port A
+	{ 0x01DA, 0x18 },	// Copy HS to DE in pipe X
+	{ 0x0314, 0x00 },	// VC = 0 (default)
+	{ 0x0316, 0x2C },	// DT = 0x2C
+	{ 0x0313, 0x60 },	// BPP = 12
+	{ 0x031D, 0x6F },	// Enable BPP/DT/VC.
+	{ 0x0B96, 0x3B },	// Enable GMSL1 to GMSL2 color mapping, set to RAW12 single
+	{ 0x0BA7, 0x45 },	// Shift HVD out of the way
+	{ 0x040B, 0x07 },	// Enable 3 mappings for Pipe X
+	{ 0x040D, 0x2C },	// Pipe X video data source
+	{ 0x040E, 0x2C },	// Pipe X video data destination
+	{ 0x040F, 0x00 },	// Pipe X Frame Start Source
+	{ 0x0410, 0x00 },	// Pipe X Frame Start Destination
+	{ 0x0411, 0x01 },	// Pipe X Frame End Source
+	{ 0x0412, 0x01 },	// Pipe X Frame End Destination
+	{ 0x042D, 0x15 },	// Pipe X mappings to DPHY1 (master for port A)
+	{ 0x0313, 0x62 },	// Enable CSI
+};
+
+static struct reg_sequence max9296_set_gpios[] = {
+	{ .reg = 0x02b0, .def = 0x83, .delay_us = 0 }, /* GPIO0 (Frame Sync Input): Enable GPIO TX to serializer */
+	{ .reg = 0x02b1, .def = 0xb8, .delay_us = 0 }, /* GPIO0 (Frame Sync Input): Set TX ID to 0x18 */
+	{ .reg = 0x02b2, .def = 0x18, .delay_us = 0 }, /* GPIO0 (Frame Sync Input): Set RX ID to 0x18 */
+};
+
+
+/* static struct reg_sequence max9296_init_seq[] = { */
+/* 	{ .reg = 0x0001, .def = 0x02, .delay_us = 0 }, /\* link speed = 6Gbps *\/ */
+/* 	{ .reg = 0x0010, .def = 0x31, .delay_us = 100000 }, /\* RESET_ONE_SHOT | AUTO_LINK *\/ */
+/* 	{ .reg = 0x0330, .def = 0x04, .delay_us = 0 }, /\* MIPI_PHY0 set des in 2 x 4 mode*\/ */
+/* 	{ .reg = 0x0333, .def = 0x4E, .delay_us = 0 }, /\* MIPI_PHY3 Lane Mapping register 1*\/ */
+/* 	{ .reg = 0x0334, .def = 0xE4, .delay_us = 0 }, /\* MIPI_PHY4 Lane Mapping register 2*\/ */
+/* 	{ .reg = 0x040A, .def = 0x00, .delay_us = 0 }, /\* MIPI_TX10 PHY0 Lane Count Register not used in 2 x 4*\/ */
+/* 	{ .reg = 0x044A, .def = 0x40, .delay_us = 0 }, /\* MIPI_TX10 PHY1 Lane Count Register in Port A*\/ */
+/* 	{ .reg = 0x048A, .def = 0x40, .delay_us = 0 }, /\* MIPI_TX10 PHY2 Lane Count Register in Port B*\/ */
+/* 	{ .reg = 0x04CA, .def = 0x00, .delay_us = 0 }, /\* MIPI_TX10 PHY3 Lane Count register unused in 2 x 4*\/ */
+/* 	{ .reg = 0x031D, .def = 0x30, .delay_us = 0 }, /\* BACKTOP22 PHY0 MIPI Clock Rate not used in 2 x 4*\/ */
+/* 	{ .reg = 0x0320, .def = 0x30, .delay_us = 0 }, /\* BACKTOP25 PHY1 MIPI Clock Rate Port A = 600 MHz*\/ */
+/* 	{ .reg = 0x0323, .def = 0x30, .delay_us = 0 }, /\* BACKTOP28 PHY2 MIPI Clock Rate Port B*\/ */
+/* 	{ .reg = 0x0326, .def = 0x30, .delay_us = 0 }, /\* BACKTOP31 PHY3 MIPI Clock Rate not used in 2 x 4*\/ */
+/* 	{ .reg = 0x0050, .def = 0x00, .delay_us = 0 }, /\* RX0 Pipe X Stream Select*\/ */
+/* 	{ .reg = 0x0051, .def = 0x01, .delay_us = 100 }, /\* RX0 Pipe Y Stream Select*\/ */
+/* 	{ .reg = 0x0313, .def = 0x02, .delay_us = 0 }, /\* BACKTOP12 Enable MAX9296 MIPI CSI *\/ */
+/* }; */
+
+/* static struct reg_sequence max9295_init_seq[] = { */
+/* 	{ .reg = 0x0001, .def = 0x08, .delay_us = 0, }, /\* link speed 6Gbps *\/ */
+/* 	{ .reg = 0x0010, .def = 0x21, .delay_us = 100000, }, /\* Reset one shot *\/ */
+/* 	{ .reg = 0x0330, .def = 0x00, .delay_us = 0 }, /\* MIPI_RX0 Set PHY to 1x4 mode*\/ */
+/* 	{ .reg = 0x0332, .def = 0xBE, .delay_us = 0 }, /\* [E0] MIPI_RX2 Lane Mapping Register 1 Swap lanes 0 & 1 for HAS000302*\/ */
+/* 	{ .reg = 0x0333, .def = 0xE1, .delay_us = 0 }, /\* [04] MIPI_RX3 Lane Mapping Register 2 Swap lanes 2 & 3 for HAS000302*\/ */
+/* 	{ .reg = 0x0331, .def = 0x33, .delay_us = 0 }, /\* MIPI_RX1 Enable Port A & B as they are shared in MAX9295A*\/ */
+/* 	{ .reg = 0x0308, .def = 0x6F, .delay_us = 0 }, /\* FRONTTOP_0 CSI Port selection Port B active in 1 x 4 mode*\/ */
+/* 	{ .reg = 0x0311, .def = 0x20, .delay_us = 0 }, /\* FRONTTOP_9 Start video pipe Y*\/ */
+/* 	{ .reg = 0x0314, .def = 0x22, .delay_us = 0 }, /\* FRONTTOP_12 Pipe X unused*\/ */
+/* 	{ .reg = 0x0316, .def = 0x6C, .delay_us = 0 }, /\* FRONTTOP_14 Datatype RAW12*\/ */
+/* 	{ .reg = 0x0318, .def = 0x22, .delay_us = 0 }, /\* FRONTTOP_16 Pipe Z unused*\/ */
+/* 	{ .reg = 0x031A, .def = 0x22, .delay_us = 0 }, /\* FRONTTOP_18 Pipe U unused*\/ */
+/* 	{ .reg = 0x0002, .def = 0xF3, .delay_us = 0 }, /\* REG2 Make sure all pipes start transmission*\/ */
+/* }; */
+
+/* static struct reg_sequence max9296_set_gmsl_speed[] = { */
+/* 	{.reg = 0x01, .def = MAX9296_GMSL_RATE_DEFAULT, .delay_us = 0}, */
+/* 	{.reg = 0x10, .def = 0x31, .delay_us = 100000}, */
+/* }; */
+
+/* static struct reg_sequence max9295_set_gmsl_speed[] = { */
+/* 	{.reg = 0x01, .def = MAX9295_GMSL_RATE_DEFAULT, .delay_us = 0}, */
+/* 	{.reg = 0x10, .def = 0x21, .delay_us = 100000}, */
+/* }; */
+
+/* Begin I2C address reassignment stuff. */
+static struct reg_sequence max9296_enable_link_a_only[] = {
+	{ .reg = 0x0010, .def = 0x01, .delay_us = 0 },
+	{ .reg = 0x0010, .def = 0x21, .delay_us = 100000 },
+};
+
+/* static struct reg_sequence max9296_enable_link_b_only[] = { */
+/* 	{ .reg = 0x0010, .def = 0x02, .delay_us = 0 }, */
+/* 	{ .reg = 0x0010, .def = 0x22, .delay_us = 100000 }, */
+/* }; */
+
+static struct reg_sequence max9296_enable_link_both[] = {
+	{ .reg = 0x0010, .def = 0x03, .delay_us = 0 },
+	{ .reg = 0x0010, .def = 0x23, .delay_us = 100000 },
+};
+
+static struct reg_sequence max9295_assign_address_40[] = {
+	{ .reg = 0x0010, .def = 0x31, .delay_us = 100000 },
+	{ .reg = 0x006B, .def = 0x10 },
+	{ .reg = 0x0073, .def = 0x11 },
+	{ .reg = 0x007B, .def = 0x30 },
+	{ .reg = 0x0083, .def = 0x30 },
+	{ .reg = 0x0093, .def = 0x30 },
+	{ .reg = 0x009B, .def = 0x30 },
+	{ .reg = 0x00A3, .def = 0x30 },
+	{ .reg = 0x00AB, .def = 0x30 },
+	{ .reg = 0x008B, .def = 0x30 },
+};
+
+static struct reg_sequence max9295_assign_address_42[] = {
+	{ .reg = 0x0010, .def = 0x31, .delay_us = 100000 },
+	{ .reg = 0x006B, .def = 0x10 },
+	{ .reg = 0x0073, .def = 0x10 },
+	{ .reg = 0x007B, .def = 0x31 },
+	{ .reg = 0x0083, .def = 0x31 },
+	{ .reg = 0x0093, .def = 0x31 },
+	{ .reg = 0x009B, .def = 0x31 },
+	{ .reg = 0x00A3, .def = 0x31 },
+	{ .reg = 0x00AB, .def = 0x31 },
+	{ .reg = 0x008B, .def = 0x31 },
+};
+
+static struct reg_sequence max9295_assign_address_60[] = {
+	{ .reg = 0x0010, .def = 0x31, .delay_us = 100000 },
+	{ .reg = 0x006B, .def = 0x12 },
+	{ .reg = 0x0073, .def = 0x13 },
+	{ .reg = 0x007B, .def = 0x32 },
+	{ .reg = 0x0083, .def = 0x32 },
+	{ .reg = 0x0093, .def = 0x32 },
+	{ .reg = 0x009B, .def = 0x32 },
+	{ .reg = 0x00A3, .def = 0x32 },
+	{ .reg = 0x00AB, .def = 0x32 },
+	{ .reg = 0x008B, .def = 0x32 },
+};
+
+static struct reg_sequence max9295_assign_address_62[] = {
+	{ .reg = 0x0010, .def = 0x31, .delay_us = 100000 },
+	{ .reg = 0x006B, .def = 0x12 },
+	{ .reg = 0x0073, .def = 0x13 },
+	{ .reg = 0x007B, .def = 0x33 },
+	{ .reg = 0x0083, .def = 0x33 },
+	{ .reg = 0x0093, .def = 0x33 },
+	{ .reg = 0x009B, .def = 0x33 },
+	{ .reg = 0x00A3, .def = 0x33 },
+	{ .reg = 0x00AB, .def = 0x33 },
+	{ .reg = 0x008B, .def = 0x33 },
+};
+/* End I2C address reassignment stuff. */
+
+#endif /* _MAX9296_TABLES_H_ */
diff --git a/drivers/d3/max9296/max96705.c b/drivers/d3/max9296/max96705.c
new file mode 100644
index 000000000000..3f77d6e96144
--- /dev/null
+++ b/drivers/d3/max9296/max96705.c
@@ -0,0 +1,278 @@
+/*
+ * max96705.c - Maxim MAX96705 GMSL1 Serializer
+ *
+ * Copyright (c) 2018,2019 D3 Engineering.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#define MAX_DEBUG 1
+#define MAX_DEBUG_GMSL_BACKCHANNEL 0
+
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/i2c.h>
+#include <linux/i2c-mux.h>
+#include <linux/regmap.h>
+#include <linux/sysfs.h>
+#include <linux/slab.h>
+
+#include <d3/d3-jetson-bsp.h>
+
+#include "max96705.h"
+#include "max96705_tables.h"
+#include "serdes.h"
+
+enum {
+	CHIP_MAX96705 = 0,
+};
+
+static struct i2c_device_id max96705_idtable[] = {
+	{"max96705", CHIP_MAX96705},
+	{},
+};
+MODULE_DEVICE_TABLE(i2c, max96705_idtable);
+
+static struct of_device_id max96705_of_match[] = {
+	{ .compatible = "maxim,max96705"},
+	{},
+};
+MODULE_DEVICE_TABLE(of, max96705_of_match);
+
+/* I2C address translation related structures */
+struct max96705_addr_map_list {
+	u32 src;
+	u32 dst;
+	struct list_head list;
+};
+
+const static struct ser_i2c_map_regs max96705_i2c_map_regs[] = {
+	{MAX96705_REG_SRC_A, MAX96705_REG_DST_A},
+	{MAX96705_REG_SRC_B, MAX96705_REG_DST_B}
+};
+
+#ifdef MAX_DEBUG
+/* Let some registers be read via debugfs */
+static const struct regmap_range max96705_yes_ranges[] = {
+	regmap_reg_range(0, 0x9a),
+};
+
+static const struct regmap_access_table max96705_regmap_rd_access_table = {
+	.yes_ranges = max96705_yes_ranges,
+	.n_yes_ranges = ARRAY_SIZE(max96705_yes_ranges),
+};
+#endif /* MAX_DEBUG */
+
+static const struct regmap_config max96705_regmap_config = {
+	.reg_bits = 8,
+	.val_bits = 8,
+#ifdef MAX_DEBUG
+	.max_register = 0xff,
+	.rd_table = &max96705_regmap_rd_access_table,
+#endif /* MAX_DEBUG */
+};
+
+/*
+ * Wrapper around regmap_read that prints errors.
+ */
+/* static int max96705_regmap_read(struct serializer *priv, u32 reg, u32 *val) */
+/* { */
+/* 	struct device *dev = &priv->client->dev; */
+/* 	struct regmap *map = priv->map; */
+/* 	int ret = 0; */
+
+/* 	reg &= 0xFFFF; */
+/* 	ret = regmap_read(map, reg, val); */
+/* 	if (ret) */
+/* 		dev_err(dev, "Failed reading register 0x%x\n", reg); */
+/* 	return ret; */
+/* } */
+
+/*
+ * Wrapper around regmap_write that prints errors.
+ */
+
+static int max96705_regmap_write(struct serdes *serdes, u32 reg, u32 val)
+{
+	struct device *dev = &serdes->client->dev;
+	struct regmap *map = serdes->map;
+	int ret = 0;
+
+	reg &= 0xFFFF;
+	val &= 0xFF;
+	ret = regmap_write(map, reg, val);
+	if (ret)
+		dev_err(dev, "Failed writing register 0x%x\n", reg);
+	return ret;
+}
+
+/* One-shot reset; resets the GMSL link but keeps the register settings */
+/* static int max96705_one_shot_reset(struct serializer *priv) */
+/* { */
+/* 	const struct reg_sequence one_shot_reset[] = { */
+/* 		{ 0x0010, 0x30, 100000 }, */
+/* 	}; */
+
+/* 	return regmap_multi_reg_write(priv->map, one_shot_reset, */
+/* 			ARRAY_SIZE(one_shot_reset)); */
+/* } */
+
+/* Search the device tree for i2c address translations */
+int max96705_get_child_addr(struct device_node *node,
+		struct list_head *list)
+{
+	struct device_node *link = NULL;
+	struct device_node *child = NULL;
+	unsigned reg = 0;
+	unsigned addr =  0;
+	struct max96705_addr_map_list *tmp;
+	int ret = 0;
+	int found = false;
+
+	for_each_available_child_of_node(node, link) {
+		if (strcmp(link->name, "link"))
+			continue;
+		for_each_available_child_of_node(link, child) {
+			ret = of_property_read_u32(child, "physical-addr",
+					&addr);
+			if (ret != 0)
+				continue;
+			ret = of_property_read_u32(child, "reg", &reg);
+			if (ret != 0)
+				continue;
+			tmp = (struct max96705_addr_map_list *)
+				kzalloc(sizeof(struct max96705_addr_map_list), GFP_KERNEL);
+			tmp->src = reg;
+			tmp->dst = addr;
+			list_add(&tmp->list, list);
+			found = true;
+		}
+	}
+	return found;
+}
+
+/*
+ * Set up an I2C address translation by setting the SRC_[AB], DST_[AB]registers
+ * MAX96705 has two pairs of registers, therefore it can do up to 2 translations
+ * @priv: max96705 private data
+ * @src: the address the client will appear to have after translation
+ * @dst: the actual address of the client
+ *
+ * Return: 0 if the translation was set up successfully, -1 if otherwise.
+ */
+static int max96705_add_i2c_translation(struct serdes *serdes, u32 src, u32 dst)
+{
+	int i = serdes->num_i2c_maps;
+
+	if (i < MAX96705_I2C_TRANS_MAX) {
+		max96705_regmap_write(serdes, max96705_i2c_map_regs[i].src,
+				src << 1);
+		max96705_regmap_write(serdes, max96705_i2c_map_regs[i].dst,
+				dst << 1);
+		serdes->num_i2c_maps++;
+		return 0;
+	}
+	return -1;
+}
+
+/* static int max96705_of_address_translations(struct device_node *node, */
+/* 		u32 *src, u32 *dst) */
+/* { */
+/* 	u32 reg; */
+/* 	u32 phys_addr; */
+
+/* 	of_property_read_u32(node, "reg", &reg); */
+/* 	of_property_read_u32(node, "physical-addr", &phys_addr); */
+
+/* 	if (!reg || !phys_addr) */
+/* 		return -ENXIO; */
+/* 	if (reg == phys_addr) */
+/* 		return -EINVAL; */
+
+/* 	*src = reg; */
+/* 	*dst = phys_addr; */
+/* 	return 0; */
+/* } */
+
+static int max96705_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	struct serializer *priv = NULL;
+	int ret = 0;
+
+	dev_dbg(&client->dev, "Probing MAX96705.\n");
+
+	if (!IS_ENABLED(CONFIG_OF) || !client->dev.of_node)
+		return -EINVAL;
+
+	priv = devm_kzalloc(&client->dev, sizeof(struct serializer), GFP_KERNEL);
+	if (!priv) {
+		dev_err(&client->dev, "failed to allocate memory!\n");
+		return -ENOMEM;
+	}
+
+	priv->serdes.client = client;
+	i2c_set_clientdata(client, priv);
+
+	priv->serdes.map = devm_regmap_init_i2c(client, &max96705_regmap_config);
+	if (IS_ERR(priv->serdes.map)) {
+		dev_err(&client->dev, "Failed to create regmap.\n");
+		return PTR_ERR(priv->serdes.map);
+	}
+
+	ret = serdes_mux_init(&priv->serdes, SER_MAX_CHANNELS);
+	if (ret != 0) {
+		return ret;
+	}
+
+
+#if 0
+	ret = regmap_multi_reg_write(priv->map, max96705_init_seq, ARRAY_SIZE(max96705_init_seq));
+	if (ret < 0) {
+		dev_err(&client->dev, "Failed to write registers.\n");
+		return ret;
+	}
+#endif
+	dev_dbg(&client->dev, "Scanning for children nodes in DT..\n");
+	/* Scan the device tree for i2c slave buses */
+	return serdes_of_scan_links(&priv->serdes,
+				    MAX96705_NUM_CHANNELS,
+				    max96705_add_i2c_translation);
+}
+
+static int max96705_remove(struct i2c_client *client)
+{
+	dev_info(&client->dev, "Removing MAX96705.");
+	return 0;
+}
+
+static struct i2c_driver max96705_driver = {
+	.driver = {
+		.name = "max96705",
+		.owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(max96705_of_match),
+	},
+	.probe = max96705_probe,
+	.remove = max96705_remove,
+	.id_table = max96705_idtable,
+};
+
+module_i2c_driver(max96705_driver);
+
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Catalin Petrescu <cpetrescu@d3engineering.com>");
+MODULE_DESCRIPTION("Maxim MAX96705 GMSL1 Serializer driver");
+MODULE_VERSION(D3_JETSON_BSP_VERSION);
+
diff --git a/drivers/d3/max9296/max96705.h b/drivers/d3/max9296/max96705.h
new file mode 100644
index 000000000000..5d657d5ef393
--- /dev/null
+++ b/drivers/d3/max9296/max96705.h
@@ -0,0 +1,39 @@
+/*
+ * max96705.h - Maxim MAX96705 Serializer tables
+ *
+ * Copyright (c) 2018, D3 Engineering.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef _MAX96705_H_
+#define _MAX96705_H_
+
+
+enum {
+	MAX96705_CH0,
+	MAX96705_NUM_CHANNELS
+};
+
+#define MAX96705_I2C_TRANS_MAX 2U
+
+#define MAX96705_REG_SERADDR 0x0
+#define MAX96705_REG_SRC_A 0x9
+#define MAX96705_REG_DST_A 0xA
+#define MAX96705_REG_SRC_B 0xB
+#define MAX96705_REG_DST_B 0xC
+
+#define MAX96705_REG_SERADDR_DEFAULT 0x80
+
+
+#endif /* _MAX96705_H_ */
diff --git a/drivers/d3/max9296/max96705_tables.h b/drivers/d3/max9296/max96705_tables.h
new file mode 100644
index 000000000000..d7b09f7334ac
--- /dev/null
+++ b/drivers/d3/max9296/max96705_tables.h
@@ -0,0 +1,148 @@
+/*
+ * max96705_tables.h - Maxim MAX9286 GMSL1 Serializer
+ *
+ * Copyright (c) 2018, D3 Engineering.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef _MAX96705_TABLES_H_
+#define _MAX96705_TABLES_H_
+
+#include "max96705.h"
+
+static const struct reg_sequence max96705_ser_input[] = {
+	{0x08,0x01,2000}, // Serializer input gain and thresholds
+	{0x97,0x5F,2000},
+};
+
+static const struct reg_sequence max96705_en_dbl_hven_hibw[] = {
+	{0x07,0xC4,16000}, // DBL, HVEN, HIBW
+};
+
+static const struct reg_sequence max96705_retime_vs_hs[] = {
+	{0x44,0x00}, /* 24-bit, VS delay in pixel cycle times from */
+	{0x45,0x9C}, /* the VS input */
+	{0x46,0x80},
+	{0x47,0x00}, /* 24-bit, VS high in pixel cycle times */
+	{0x48,0xB0},
+	{0x49,0x00},
+	{0x43,0x21}, /* GEN_VS, GEN_HS, VS_TRIG falling edge */
+	{0x67,0xC4},
+};
+
+static const struct reg_sequence max96705_set_xbar[] = {
+	{0x20,0x0B},
+	{0x21,0x0A},
+	{0x22,0x09},
+	{0x23,0x08},
+	{0x24,0x07},
+	{0x25,0x06},
+	{0x26,0x05},
+	{0x27,0x04},
+	{0x28,0x03},
+	{0x29,0x02},
+	{0x2A,0x01},
+	{0x2B,0x00},
+	{0x30,0x1B},
+	{0x31,0x1A},
+	{0x32,0x19},
+	{0x33,0x18},
+	{0x34,0x17},
+	{0x35,0x16},
+	{0x36,0x15},
+	{0x37,0x14},
+	{0x38,0x13},
+	{0x39,0x12},
+	{0x3A,0x11},
+	{0x3B,0x10},
+};
+
+static const struct reg_sequence max96705_en_gmsl[] = {
+	{0x04,0x87,16000},
+};
+
+static const struct reg_sequence max96705_en_him[] = {
+	{ 0x4D, 0xC0, 5000 },	// HIM = 1, coax mode
+};
+
+static const struct reg_sequence max96705_en_cfg[] = {
+	{ 0x04, 0x43, 5000 },	// Enable config link
+};
+
+static const struct reg_sequence max96705_en_dbl_hven[] = {
+	{ 0x07, 0x84, 16000 },	// DBL, HVEN
+};
+
+/* Crossbar Setup */
+static const struct reg_sequence max96705_crossbar[] = {
+	{0x20,0x40},
+	{0x21,0x40},
+	{0x22,0x40},
+	{0x23,0x40},
+	{0x24,0x00},
+	{0x25,0x01},
+	{0x26,0x02},
+	{0x27,0x03},
+	{0x28,0x04},
+	{0x29,0x05},
+	{0x2A,0x06},
+	{0x2B,0x07},
+	{0x30,0x40},
+	{0x31,0x40},
+	{0x32,0x40},
+	{0x33,0x40},
+	{0x34,0x10},
+	{0x35,0x11},
+	{0x36,0x12},
+	{0x37,0x13},
+	{0x38,0x14},
+	{0x39,0x15},
+	{0x3A,0x16},
+	{0x3B,0x17},
+};
+
+static const struct reg_sequence max96705_xb_flip_bit_order[] = {
+	{0x20,0x0B},
+	{0x21,0x0A},
+	{0x22,0x09},
+	{0x23,0x08},
+	{0x24,0x07},
+	{0x25,0x06},
+	{0x26,0x05},
+	{0x27,0x04},
+	{0x28,0x03},
+	{0x29,0x02},
+	{0x2A,0x01},
+	{0x2B,0x00},
+	{0x30,0x1B},
+	{0x31,0x1A},
+	{0x32,0x19},
+	{0x33,0x18},
+	{0x34,0x17},
+	{0x35,0x16},
+	{0x36,0x15},
+	{0x37,0x14},
+	{0x38,0x13},
+	{0x39,0x12},
+	{0x3A,0x11},
+	{0x3B,0x10},
+};
+
+/* Post-Camera Setup */
+static const struct reg_sequence max96705_en_link[] = {
+	{ 0x04, 0x87, 16000 },	// Enable GMSL link
+	{ 0x07, 0xC4, 16000 },	// DBL,HIBW,HVEN
+};
+
+#endif /* _MAX96705_TABLES_H_ */
diff --git a/drivers/d3/max9296/serdes.c b/drivers/d3/max9296/serdes.c
new file mode 100644
index 000000000000..37af466a1a8d
--- /dev/null
+++ b/drivers/d3/max9296/serdes.c
@@ -0,0 +1,446 @@
+/*
+ * serdes.c
+ *
+ * Copyright (c) 2018,2019 D3 Engineering.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#define MAX_DEBUG 1
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/i2c-mux.h>
+#include <linux/list.h>
+#include <linux/regmap.h>
+#include <linux/regulator/consumer.h>
+
+#include <d3/d3-jetson-bsp.h>
+
+#include "serdes.h"
+
+int serdes_get_reset_gpio(struct deserializer *des)
+{
+	struct device *dev = &des->serdes.client->dev;
+
+	des->reset_gpio = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+	if (IS_ERR(des->reset_gpio)) {
+		dev_dbg(dev, "%s failed....", of_node_full_name(dev->of_node));
+		return PTR_ERR(des->reset_gpio);
+	}
+	return 0;
+}
+EXPORT_SYMBOL(serdes_get_reset_gpio);
+
+static void serdes_set_gpio(struct gpio_desc *gpio, int state)
+{
+	if (gpiod_cansleep(gpio))
+		gpiod_set_value_cansleep(gpio, state);
+	else
+		gpiod_set_value(gpio, state);
+}
+EXPORT_SYMBOL(serdes_set_gpio);
+
+void serdes_des_reset(struct deserializer *priv)
+{
+	serdes_set_gpio(priv->reset_gpio, 1);
+	usleep_range(1000, 2000);
+	serdes_set_gpio(priv->reset_gpio, 0);
+}
+EXPORT_SYMBOL(serdes_des_reset);
+
+int serdes_get_reset_gpio_and_reset(struct deserializer *des)
+{
+	int ret;
+	ret = serdes_get_reset_gpio(des);
+	if (ret < 0)
+		return ret;
+	serdes_des_reset(des);
+	usleep_range(1000, 50*1000);
+	return 0;
+}
+EXPORT_SYMBOL(serdes_get_reset_gpio_and_reset);
+
+int serdes_enable_regulator(struct device *dev, const char *reg_name,
+		struct regulator **preg)
+{
+	int ret = 0;
+	struct regulator *r = NULL;
+
+	dev_dbg(dev, "Enabling regulator: %s.\n", reg_name);
+	r = devm_regulator_get(dev, reg_name);
+	if (IS_ERR(r)) {
+		return PTR_ERR(r);
+	}
+	else {
+		*preg = r;
+		ret = regulator_enable(r);
+		if (ret != 0) {
+			dev_err(dev, "Error: Can't enable regulator: %s.\n",
+				reg_name);
+			return ret;
+		}
+	}
+	return 0;
+}
+EXPORT_SYMBOL(serdes_enable_regulator);
+
+
+int serdes_enable_regulators(struct deserializer *priv,
+		int (*disable_link)(struct deserializer*, unsigned), unsigned link)
+{
+	struct device *dev = &priv->serdes.client->dev;
+	int ret = 0;
+
+	if (priv->regulator_enabled == false) {
+		ret = serdes_enable_regulator(dev, DES_VDD_REGULATOR_NAME,
+				&priv->vdd_regulator);
+
+		/* While probing the deserializers, we need to wait
+		 * for the GMSL regulators to come up. It may seem
+		 * like the deserializers can be initialized before
+		 * the GMSL buses are powered, but if we need to
+		 * reassign the addresses of the serializers, we need
+		 * to be able to talk to them.
+		 */
+		if (ret == -EPROBE_DEFER) {
+			dev_info(dev, "Vdd regulator is not ready. Deferring.");
+			return ret;
+		}
+		ret = serdes_get_reset_gpio_and_reset(priv);
+		if (ret < 0) {
+			dev_err(dev, "Can't reset deserializer. %d\n", ret);
+			return ret;
+		}
+		dev_dbg(dev, "Vdd regulator ready.\n");
+		/* verify that the chip is present */
+		ret = i2c_smbus_write_byte(priv->serdes.client, 0);
+		if (ret < 0) {
+			dev_err(dev, "failed to write to device.\n");
+			return -EPROBE_DEFER;
+		}
+
+		/* Prevent spurious i2c commmunication */
+		disable_link(priv, link);
+		priv->regulator_enabled = true;
+	}
+	ret = serdes_enable_regulator(dev, DES_POC_REGULATOR_NAME,
+			&priv->poc_regulator);
+	if (ret == -EPROBE_DEFER) {
+		dev_info(dev, "PoC regulator is not ready. Deferring.");
+		return ret;
+	}
+	return ret;
+}
+EXPORT_SYMBOL(serdes_enable_regulators);
+
+int serdes_disable_regulators(struct deserializer *priv)
+{
+	struct device *dev = &priv->serdes.client->dev;
+	int ret = 0;
+
+	dev_dbg(dev, "Disabling PoC regulator.\n");
+	ret = regulator_disable(priv->poc_regulator);
+	if (ret != 0) {
+		dev_err(dev, "Can't disable PoC regulator.\n");
+		return ret;
+	}
+	dev_dbg(dev, "Disabling Vdd regulator.\n");
+	ret = regulator_disable(priv->vdd_regulator);
+	if (ret != 0) {
+		dev_err(dev, "Can't disable Vdd regulator.\n");
+		return ret;
+	}
+	return 0;
+}
+EXPORT_SYMBOL(serdes_disable_regulators);
+
+/* Do-nothing select function for the virtual i2c adapters */
+int serdes_select_i2c_chan(struct i2c_mux_core *core, u32 chan)
+{
+	return 0;
+}
+EXPORT_SYMBOL(serdes_select_i2c_chan);
+
+/* Do-nothing deselect function for the virtual i2c adapters */
+int serdes_deselect_i2c_chan(struct i2c_mux_core *core, u32 chan)
+
+{
+	return 0;
+}
+EXPORT_SYMBOL(serdes_deselect_i2c_chan);
+
+/* Create dummy i2c device and a regmap */
+int  serdes_create_dummy(struct i2c_adapter *adapter, unsigned addr,
+		const struct regmap_config *regmap_config,
+		struct i2c_client **serp, struct regmap **mapp)
+{
+	struct i2c_client *client = NULL;
+	struct regmap *map = NULL;
+
+	client = i2c_new_dummy(adapter, addr);
+	if (IS_ERR(client))
+		return PTR_ERR(client);
+	map = regmap_init_i2c(client, regmap_config);
+	if (IS_ERR(map))
+		return PTR_ERR(map);
+	*serp = client;
+	*mapp = map;
+	return 0;
+}
+EXPORT_SYMBOL(serdes_create_dummy);
+
+int serdes_of_scan_link_clients(struct serdes *serdes,
+				struct device_node *link,
+				i2c_translation_func_t add_i2c_translation)
+{
+	struct device *dev = &serdes->client->dev;
+	struct device_node *child = NULL;
+	int ret = 0;
+
+	if (!link) {
+		dev_err(dev, "link is NULL.\n");
+		return -EINVAL;
+	}
+
+	dev_dbg(dev, "%s.\n", __func__);
+	for_each_available_child_of_node(link, child) {
+		u32 reg = 0;
+		u32 phys_addr = 0;
+
+		dev_dbg(dev, "Found: %s\n",of_node_full_name(child));
+		of_property_read_u32(child, "reg", &reg);
+		of_property_read_u32(child, "physical-addr", &phys_addr);
+
+		if (!reg || !phys_addr) {
+			dev_warn(dev, "Register or physical address can't be zero");
+			continue;
+		}
+		if (reg == phys_addr) {
+			dev_warn(dev, "Ignoring translation, reg and phys_addr have the same value!");
+			continue;
+		}
+		/* Call the chip-specific translation function */
+		ret = add_i2c_translation(serdes, reg, phys_addr);
+		if (ret == 0) {
+			dev_dbg(dev, "Reassigning I2C address: 0x%x => 0x%x\n",
+				phys_addr, reg);
+		}
+		else {
+			dev_warn(dev, "I2C address translation failed.\n");
+		}
+	}
+	return ret;
+}
+EXPORT_SYMBOL(serdes_of_scan_link_clients);
+
+/*
+ * Scan the children node in the device for client buses. Create an I2C adapter
+ * for each link found.
+ *
+ * @priv: serializer/deserializer private data
+ * @max_links: number of GMSL links that the chip has
+ * @add_i2c_translation: callback that does the chip-specific i2c addr. translation
+ */
+int serdes_of_scan_links(struct serdes *serdes,
+			 unsigned max_links,
+			 i2c_translation_func_t add_i2c_translation)
+{
+	struct device *dev = &serdes->client->dev;
+	struct device_node *node = dev->of_node;
+	struct device_node *link = NULL;
+	int force_nr = 1; /* I2C virtual adapter number */
+	int chan_id = 0;
+	int ret = 0;
+
+	if (!node) {
+		dev_err(dev, "of_node is NULL.\n");
+		return -EINVAL;
+	}
+
+	for_each_available_child_of_node(node, link) {
+		if (strcmp(link->name, "link")) {
+			dev_dbg(dev, "Ignoring node %s\n",
+				of_node_full_name(link));
+			continue;
+		}
+
+		/* Get bus number */
+		force_nr = 0;
+		ret = of_property_read_u32(link, "bus-number", &force_nr);
+
+		dev_dbg(dev, "%s: bus number: %u",
+			of_node_full_name(link), force_nr);
+
+		serdes_of_scan_link_clients(serdes, link, add_i2c_translation);
+
+		if (chan_id < max_links) {
+			ret = i2c_mux_add_adapter(serdes->mux_core,
+						  force_nr, 0, 0);
+			if (ret) {
+				dev_err(dev,
+					"failed to register multiplexed"
+					" adapter %d bus-num %d\n",
+					chan_id, force_nr);
+				return ret;
+			}
+			chan_id++;
+		}
+		else
+			dev_warn(dev, "Too many link nodes!");
+	}
+	return 0;
+}
+EXPORT_SYMBOL(serdes_of_scan_links);
+
+
+int serdes_mux_init(struct serdes *serdes, unsigned max_channels)
+{
+	struct device *dev = &serdes->client->dev;
+	struct i2c_adapter *adap = to_i2c_adapter(dev->parent);
+	// No priv, no flags (look for i2c-mux in dts)
+	serdes->mux_core = i2c_mux_alloc(adap,
+					 dev,
+					 max_channels,
+					 0, 0,
+					 serdes_select_i2c_chan,
+					 serdes_deselect_i2c_chan);
+
+	if (!serdes->mux_core) {
+		dev_err(dev, "failed to allocate mux core");
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(serdes_mux_init);
+
+#if 0
+int serdes_get_client_nodes(struct device_node *node, struct serdes_node_list *list)
+{
+	struct device_node *link = NULL;
+	struct device_node *client = NULL;
+	struct serdes_node_list *tmp;
+	int clients_found = 0;
+
+	for_each_available_child_of_node(node, link) {
+		if (strcmp(link->name, "link"))
+			continue;
+		for_each_available_child_of_node(link, client) {
+			tmp = (struct serdes_node_list *)
+				kzalloc(sizeof(struct serdes_node_list),
+						GFP_KERNEL);
+			list_add(&tmp->list, &list->list);
+			clients_found += 1;
+		}
+	}
+	return clients_found;
+}
+EXPORT_SYMBOL(serdes_get_client_nodes);
+
+int serdes_serializer_is_gmsl1(struct serdes_node_list *list)
+{
+	int is_gmsl1 = 0;
+	struct serdes_node_list *s;
+	struct serdes_node_list *tmp;
+	LIST_HEAD(h);
+
+	list_for_each_entry_safe(s, tmp, &h, list){
+		const char **p;
+		int ret;
+		pr_info("Node name %s.\n", s->node->name);
+		ret = of_property_read_string(s->node, "compatible", p);
+		if (!ret) {
+			ret = strcmp(*p, "maxim,max96705");
+			if (ret == 0)
+				is_gmsl1 = 1;
+		}
+		list_del(&s->list);
+		kfree(s);
+	}
+	return is_gmsl1;
+}
+#endif
+
+#if 0
+int serdes_get_addrs(struct device_node *node, u32 *out_src, u32 *out_dst)
+{
+	u32 addr;
+	u32 reg;
+	int ret = of_property_read_u32(node, "physical-addr", &addr);
+	if (ret < 0)
+		return ret;
+	ret = of_property_read_u32(node, "reg", &reg);
+	if (ret < 0)
+		return ret;
+	*out_src = reg;
+	*out_dst = addr;
+	return ret;
+}
+#endif
+
+#if 0
+/* Search the device tree for i2c address translations */
+int max9296_get_child_addr(struct device_node *node,
+		struct list_head *list)
+{
+	struct device_node *link = NULL;
+	struct device_node *child = NULL;
+	unsigned reg = 0;
+	unsigned addr =  0;
+	struct max9286_addr_map_list *tmp;
+	int ret = 0;
+	int found = false;
+
+	for_each_available_child_of_node(node, link) {
+		if (strcmp(link->name, "link"))
+			continue;
+		for_each_available_child_of_node(link, child) {
+			ret = of_property_read_u32(child, "physical-addr",
+					&addr);
+			if (ret != 0)
+				continue;
+			ret = of_property_read_u32(child, "reg", &reg);
+			if (ret != 0)
+				continue;
+			tmp = (struct max9286_addr_map_list *)
+				kzalloc(sizeof(struct max9286_addr_map_list), GFP_KERNEL);
+			tmp->src = reg;
+			tmp->dst = addr;
+			list_add(&tmp->list, list);
+			found = true;
+		}
+	}
+	return found;
+}
+#endif
+
+static int __init serdes_init(void)
+{
+	pr_info("Serdes module loaded.");
+	return 0;
+}
+
+static void __exit serdes_exit(void)
+{
+	return;
+}
+
+module_init(serdes_init);
+module_exit(serdes_exit);
+
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Catalin Petrescu <cpetrescu@d3engineering.com>");
+MODULE_DESCRIPTION("Common serializer / deserializer code");
+MODULE_VERSION(D3_JETSON_BSP_VERSION);
diff --git a/drivers/d3/max9296/serdes.h b/drivers/d3/max9296/serdes.h
new file mode 100644
index 000000000000..34f200a7b3a2
--- /dev/null
+++ b/drivers/d3/max9296/serdes.h
@@ -0,0 +1,124 @@
+/*
+ * serdes.h
+ *
+ * Copyright (c) 2018,2019 D3 Engineering.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef _SERDES_H_
+#define MAX_DEBUG 1
+#define _SERDES_H_
+
+#include <linux/types.h>
+#include <linux/module.h>
+#include <linux/i2c.h>
+#include <linux/regmap.h>
+#include <linux/gpio/consumer.h>
+
+#define DES_MAX_CHANNELS 4
+#define SER_MAX_CHANNELS 1
+
+#define DES_VDD_REGULATOR_NAME "vdd"
+#define DES_POC_REGULATOR_NAME "gmsl"
+
+
+enum link_type {
+	LINK_TYPE_GMSL1 = 0,
+	LINK_TYPE_GMSL2,
+	LINK_TYPE_FPDLINK,
+};
+
+struct csi_config {
+	unsigned num_lanes;
+	unsigned freq_mhz;
+};
+
+struct serial_config {
+	unsigned forward_bit_rate; /* forward channel bit rate */
+	unsigned back_bit_rate; /* back channel bit rate */
+};
+
+struct serdes {
+	struct i2c_client *client;
+	struct regmap *map;
+	struct i2c_mux_core *mux_core;
+	unsigned num_i2c_maps; /* Number of active i2c address translations */
+	struct csi_config csi_config; /* CSI configuration */
+	struct serial_config serial_config; /* GMSL configuration */
+};
+
+struct deserializer {
+	struct serdes serdes;
+
+	struct gpio_desc *reset_gpio;
+	struct regulator *vdd_regulator; /* feeds the deserializer */
+	struct regulator *poc_regulator; /* feeds the serializer, imager */
+	int irq;
+	bool regulator_enabled;
+	enum link_type link_type;
+	unsigned fsync_mode;
+};
+
+struct serializer {
+	struct serdes serdes;
+};
+
+/* The deserializer register pairs that set the i2c address translations */
+struct ser_i2c_map_regs {
+	unsigned src;
+	unsigned dst;
+};
+
+#if 0
+struct serdes_node_list {
+	struct device_node *node;
+	struct list_head list;
+};
+#endif
+
+/* Structure that allows me to send a configuration sequence to
+ * deserializer, serializer and imager.
+ */
+struct serdes_playlist {
+	const char target; /* 'd': deserializer. 's': serializer, 'i': imager */
+	const struct reg_sequence *seq;
+	unsigned len;
+};
+
+#define PLAYLIST_INIT(to, seq_name) {.target = (to), .seq = (seq_name), \
+	.len = ARRAY_SIZE(seq_name)}
+
+typedef int (*i2c_translation_func_t)(struct serdes *serdes, u32 src, u32 dst);
+
+
+extern int serdes_get_reset_gpio_and_reset(struct deserializer *serdes);
+extern int serdes_enable_regulator(struct device *dev, const char *reg_name,
+		struct regulator **preg);
+extern int serdes_enable_regulators(struct deserializer *priv,
+		int (*disable_link)(struct deserializer*, unsigned), unsigned link);
+extern int serdes_disable_regulators(struct deserializer *priv);
+
+extern int serdes_select_i2c_chan(struct i2c_mux_core *core, u32 chan);
+extern int serdes_deselect_i2c_chan(struct i2c_mux_core *core, u32 chan);
+
+extern int serdes_create_dummy(struct i2c_adapter *adapter, unsigned addr,
+		const struct regmap_config *regmap_config,
+		struct i2c_client **serp, struct regmap **mapp);
+
+extern int serdes_of_scan_links(struct serdes *serdes,
+                                unsigned max_links,
+                                i2c_translation_func_t add_i2c_translation);
+
+extern int serdes_mux_init(struct serdes *serdes, unsigned max_channels);
+#endif /* _SERDES_H_ */
diff --git a/drivers/d3/ov10640/Kconfig b/drivers/d3/ov10640/Kconfig
new file mode 100644
index 000000000000..4d2c109953be
--- /dev/null
+++ b/drivers/d3/ov10640/Kconfig
@@ -0,0 +1,10 @@
+config D3_OV10640
+	depends on OF
+	tristate "OV10640 Camera Driver"
+	help
+	  D3 OV10640 Camera Driver for Nvidia Tegra systems including Jetson Tx2.
+config D3_OV10640_HDR_ENABLE
+    bool "OV10640 HDR Mode"
+    depends on D3_OV10640
+    help
+      Enable HDR mode for D3 ov10640 driver
diff --git a/drivers/d3/ov10640/Makefile b/drivers/d3/ov10640/Makefile
new file mode 100644
index 000000000000..09966577d22f
--- /dev/null
+++ b/drivers/d3/ov10640/Makefile
@@ -0,0 +1,3 @@
+# -*-makefile-*-
+ov10640-objs := ov10640_main.o ov10640_ctrls.o ov10640_tables.o
+obj-$(CONFIG_D3_OV10640) += ov10640.o
diff --git a/drivers/d3/ov10640/ov10640.h b/drivers/d3/ov10640/ov10640.h
new file mode 100644
index 000000000000..e8516ed55164
--- /dev/null
+++ b/drivers/d3/ov10640/ov10640.h
@@ -0,0 +1,67 @@
+/**
+ * @author Josh Watts <jwatts@d3engineering.com>
+ *
+ * ov10640 v4l2 driver for Nvidia Jetson
+ *
+ * Copyright (c) 2019, D3 Engineering.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+#ifndef _OV10640_H
+#define _OV10640_H
+
+#include <linux/i2c.h>
+
+/**
+ * If @p expr evalutes to non-zero assign it to @p err and return @p err
+ */
+#define TRY(err, expr) do {\
+		err = expr; \
+		if (err) { \
+			return err; \
+		} \
+	} while (false)
+
+#define TRY_MEM(mem, expr) do {\
+		mem = expr; \
+		if (IS_ERR(mem)) \
+			return PTR_ERR(mem); \
+	} while (false)
+
+struct ov10640
+{
+	struct camera_common_power_rail	power;
+
+	struct i2c_client *client;
+	struct device *dev;
+	struct regmap *map;
+
+	struct camera_common_data *s_data;
+	struct camera_common_pdata *pdata;
+
+	struct media_pad pad;
+	struct v4l2_ctrl_handler ctrl_handler;
+	struct v4l2_subdev *subdev;
+	struct v4l2_ctrl **ctrls;
+	int numctrls;
+
+	bool group_hold;
+
+	int frame_sync_mode;
+
+	struct i2c_client *deserializer;
+	bool hflip;
+	bool vflip;
+};
+
+#endif
diff --git a/drivers/d3/ov10640/ov10640_ctrls.c b/drivers/d3/ov10640/ov10640_ctrls.c
new file mode 100644
index 000000000000..a04c47951d98
--- /dev/null
+++ b/drivers/d3/ov10640/ov10640_ctrls.c
@@ -0,0 +1,614 @@
+/**
+ * @author Josh Watts <jwatts@d3engineering.com>
+ * @author Greg Rowe <growe@d3engineering.com>
+ *
+ * ov10640 v4l2 driver for Nvidia Jetson
+ *
+ * Copyright (c) 2019, D3 Engineering.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+#include <linux/kernel.h>
+#include <media/camera_common.h>
+
+#include "ov10640_tables.h"
+#include "ov10640_ctrls.h"
+#include "ov10640_reg.h"
+
+/* V4l2 control ids */
+enum {
+	OV10640_CID_BASE = (TEGRA_CAMERA_CID_BASE + 230),
+	OV10640_CID_DGAIN,
+	OV10640_CID_EXPOSURE,
+	OV10640_CID_FLIP_MIRROR,
+	OV10640_CID_FSYNC_ENABLE,
+};
+
+#define OV10640_MAX_DGAIN	(0x3FFF)
+#define OV10640_MIN_DGAIN	(0x0001)
+#define OV10640_DEF_DGAIN	(256)
+
+#define OV10640_MAX_EXPO	(33698LL)
+#define OV10640_MIN_EXPO	(20LL)
+#define OV10640_DEF_EXPO	(20LL)
+
+/* #define OV10640_MAX_EXPO	(32640LL) */
+/* #define OV10640_MIN_EXPO	(640LL) */
+/* #define OV10640_DEF_EXPO	(640LL) */
+
+/* 8 row periods */
+#define OV10640_MAX_EXPO_SHORT	(33698LL)
+/* 1/32 row period */
+#define OV10640_MIN_EXPO_SHORT	(20LL)
+/* 1/32 row period */
+#define OV10640_DEF_EXPO_SHORT	(20LL)
+
+#define FIXED_POINT_BITS	(22)
+#define DGAIN_FIXED_BITS	(8)
+
+
+/* static int ov10640_read_u16(struct ov10640 *self, unsigned reg_h, */
+/* 			    unsigned int *val) */
+/* { */
+/* 	int err; */
+/* 	uint8_t temp[2]; */
+
+/* 	err = regmap_bulk_read(self->map, reg_h, temp, 2); */
+/* 	if (err) */
+/* 		return err; */
+
+/* 	*val = ((temp[0] & 0xFF) << 8) | (temp[1] & 0xFF); */
+
+/* 	return 0; */
+/* } */
+
+static int ov10640_write_u16(struct ov10640 *self, u16 reg_h, u16 val)
+{
+	uint8_t temp[2];
+
+	temp[0] = (val >> 8) & 0xFF;
+	temp[1] = val & 0xFF;
+
+	return regmap_bulk_write(self->map, reg_h, temp, 2);
+}
+
+static int ov10640_group_reg_write(struct ov10640 *self, unsigned int reg,
+				   unsigned int val)
+{
+	if (self->group_hold)
+		reg |= (1 << 15);
+
+	return regmap_write(self->map, reg, val);
+}
+
+static int ov10640_group_reg_write_u16(struct ov10640 *self, unsigned int reg_h,
+				       unsigned int val)
+{
+	if (self->group_hold)
+		reg_h |= (1 << 15);
+
+	return ov10640_write_u16(self, reg_h, val);
+}
+
+/**
+ * Puts the sensor in (or takes out of) register group hold. This
+ * means that you can make changes to the sensor through multiple
+ * registers and have all of the changes activate at the same time.
+ *
+ * @param self driver instance
+ * @param val boolean enable or disable
+ *
+ * @return 0 on success
+ */
+static int ov10640_group_hold_enable(struct ov10640 *self, s32 val)
+{
+	if (self->group_hold == !!val)
+		return 0;
+
+	if (val)
+		regmap_write(self->map, OV10640_REG_GROUP_CTRL,
+			     OV10640_REG_GROUP_CTRL_PRE_SOF | OV10640_REG_GROUP_CTRL_1ST_GRP(0));
+	else
+		regmap_write(self->map, OV10640_REG_OPERATION_CTRL,
+			     OV10640_REG_OPERATION_CTRL_SINGLE_START);
+
+	self->group_hold = !!val;
+
+	return 0;
+}
+
+
+
+
+static int ov10640_gain_set(struct ov10640 *self, s64 val)
+{
+	u8 gain_exp = 0;
+	s64 dgain_fixed = 0;
+	u8 cgain = 0;
+	u16 raw_gain = 0;
+	u16 raw_dig_gain = 0;
+	u8 raw_dig_gain_l = 0, raw_dig_gain_h = 0;
+	int err = 0;
+
+	if (val >= 8 * FIXED_POINT_SCALING_FACTOR) {
+		gain_exp = 3;
+		/* cgain = 1; */
+	} else if (val >= 4 * FIXED_POINT_SCALING_FACTOR) {
+		gain_exp = 2;
+		/* cgain = 1; */
+	} else if (val > 2 * FIXED_POINT_SCALING_FACTOR) {
+		gain_exp = 1;
+		/* cgain = 1; */
+	} else if (val >= 1 * FIXED_POINT_SCALING_FACTOR) {
+		gain_exp = 0;
+		/* cgain = 1; */
+	} else {
+		gain_exp = 0;
+		cgain = 0;
+	}
+
+	raw_dig_gain = OV10640_DEF_DGAIN;
+
+	// scale analog gain using digital gain to achieve an overall
+	// gain of "val"
+	dgain_fixed = val / (1 << gain_exp);
+
+	dev_dbg_ratelimited(self->dev,
+			    "Changing gain to: %lli == %lli\n",
+			    val, dgain_fixed * (1 << gain_exp));
+
+	dgain_fixed = (dgain_fixed >> (FIXED_POINT_BITS - DGAIN_FIXED_BITS));
+	raw_dig_gain = dgain_fixed & 0x3FFF;
+	raw_dig_gain_l = raw_dig_gain & 0xFF;
+	raw_dig_gain_h = (raw_dig_gain >> 8) & 0xFF;
+
+	raw_gain = (cgain << 7)
+		| (cgain << 6)
+		| (gain_exp << 4)
+		| (gain_exp << 2)
+		| gain_exp;
+	TRY(err, ov10640_group_reg_write(self, OV10640_CG_AGAIN, raw_gain));
+	TRY(err, ov10640_group_reg_write(self, OV10640_DIG_L_GAIN_L, raw_dig_gain_l));
+	TRY(err, ov10640_group_reg_write(self, OV10640_DIG_L_GAIN_H, raw_dig_gain_h));
+	TRY(err, ov10640_group_reg_write(self, OV10640_DIG_S_GAIN_L, raw_dig_gain_l));
+	TRY(err, ov10640_group_reg_write(self, OV10640_DIG_S_GAIN_H, raw_dig_gain_h));
+	TRY(err, ov10640_group_reg_write(self, OV10640_DIG_VS_GAIN_L, raw_dig_gain_l));
+	TRY(err, ov10640_group_reg_write(self, OV10640_DIG_VS_GAIN_H, raw_dig_gain_h));
+
+	return 0;
+}
+
+static int ov10640_framerate_set(struct ov10640 *self, s64 val)
+{
+	return 0;
+}
+
+
+
+int ov10640_hflip_set(struct ov10640 *self, bool hflip)
+{
+	/* Mirror */
+	int err = 0;
+	u8 val = hflip ? 1:0;
+
+	/* the third parameter is a mask */
+	TRY(err, regmap_update_bits(self->map, OV10640_REG_READ_MODE,
+				    (1 << 2), val << 2));
+	TRY(err, regmap_update_bits(self->map, OV10640_REG_R_ISP_CTRL_2,
+				    (1 << 0), val));
+	TRY(err, regmap_update_bits(self->map, OV10640_REG_R_CTRL08,
+				    (1 << 1), val << 1));
+	return err;
+}
+
+
+int ov10640_vflip_set(struct ov10640 *self, bool vflip)
+{
+	/* Flip */
+	int err = 0;
+	u8 val = vflip ? 1:0;
+
+	/* the third parameter is a mask */
+	TRY(err, regmap_update_bits(self->map, OV10640_REG_READ_MODE,
+				    (1 << 3), val << 3));
+	TRY(err, regmap_update_bits(self->map, OV10640_REG_R_ISP_CTRL_2,
+				    (1 << 1), val << 1));
+	TRY(err, regmap_update_bits(self->map, OV10640_REG_R_CTRL08,
+				    (1 << 2), val << 2));
+	return err;
+}
+
+
+static int ov10640_frame_sync_enable_set(struct ov10640 *self, s64 val)
+{
+	int ret = 0;
+
+	if (val < 0 || val > 1)
+		return -EINVAL;
+
+	self->frame_sync_mode = val;
+	return ret;
+}
+
+
+static int ov10640_exposure_set(struct ov10640 *self, s64 exp_us)
+{
+	int err = 0;
+	struct camera_common_data *s_data = self->s_data;
+	const struct sensor_mode_properties *mode =
+			&s_data->sensor_props.sensor_modes[s_data->mode];
+	int mode_ix = self->s_data->sensor_mode_id;
+	int is_hdr = ov10640_formats[mode_ix].hdr_en;
+
+	unsigned int vts_l = 0;
+	unsigned int vts_h = 0;
+	u16 vts = 0;
+	u16 max_lines = 0;
+
+	s64 vs_reg = 0;
+	s64 s_reg = 0;
+
+	s64 line_length = mode->image_properties.line_length;
+	s64 pixel_clock = mode->signal_properties.pixel_clock.val;
+	s64 n_lines = pixel_clock * exp_us / line_length /
+		FIXED_POINT_SCALING_FACTOR;
+	++n_lines;
+	if (n_lines < 0) {
+		n_lines = 1;
+	}
+
+	/* The datasheet says that the max exposure for L and S
+	 * exposures is VTS - 6 */
+
+	TRY(err, regmap_read(self->map, OV10640_REG_VTS_H, &vts_h));
+	TRY(err, regmap_read(self->map, OV10640_REG_VTS_L, &vts_l));
+	vts = (vts_h << 8) | vts_l;
+	max_lines = vts - 6;
+	dev_dbg_ratelimited(self->dev, "vts = %u, max_lines=%u",
+			     vts, max_lines);
+
+	dev_dbg_ratelimited(self->dev,
+			    "exposure vals min=%lld max=%lld exp_us=%lld",
+			    OV10640_MIN_EXPO, OV10640_MAX_EXPO, exp_us);
+	dev_dbg_ratelimited(self->dev,
+			    "line_length=%lld pixel_clock=%lld n_lines=%lld",
+			    line_length, pixel_clock, n_lines);
+
+	if (n_lines > max_lines) {
+		dev_warn(self->dev, "invalid exposure: n_lines=%lld max=%u",
+			 n_lines, max_lines);
+		n_lines = max_lines;
+	}
+
+	s_reg = n_lines / 32;
+	vs_reg = s_reg;
+
+	TRY(err, ov10640_group_reg_write_u16(self, OV10640_EXPO_L_H, n_lines));
+	if (is_hdr) {
+		dev_dbg_ratelimited(self->dev,
+				    "n_lines=%lld"
+				    " S=%lld"
+				    " VS=%lld"
+				    ,
+				    n_lines, s_reg, vs_reg);
+
+		TRY(err, ov10640_group_reg_write_u16(
+			    self, OV10640_EXPO_S_H, s_reg));
+		/* (n_lines / 6) -1 should be the VS value*/
+		TRY(err, ov10640_group_reg_write(self, OV10640_EXPO_VS,
+			    vs_reg));
+	}
+
+	return 0;
+}
+
+static int ov10640_exposure_short_set(struct ov10640 *self, s64 exp_us)
+{
+	/* int err = 0; */
+	struct camera_common_data *s_data = self->s_data;
+	const struct sensor_mode_properties *mode =
+			&s_data->sensor_props.sensor_modes[s_data->mode];
+	int mode_ix = self->s_data->sensor_mode_id;
+	int is_hdr = ov10640_formats[mode_ix].hdr_en;
+
+	s64 line_length = mode->image_properties.line_length;
+	s64 pixel_clock = mode->signal_properties.pixel_clock.val;
+	s64 n_lines = pixel_clock * exp_us / line_length /
+		FIXED_POINT_SCALING_FACTOR;
+	++n_lines;
+
+	if (!is_hdr) {
+		dev_warn(self->dev, "setting short exposure in a linear mode?");
+		return 0;
+	}
+
+
+	dev_dbg_ratelimited(self->dev, "exposure vals min=%lld max=%lld exp_us=%lld",
+		OV10640_MIN_EXPO, OV10640_MAX_EXPO, exp_us);
+	dev_dbg_ratelimited(self->dev, "line_length=%lld pixel_clock=%lld n_lines=%lld",
+		line_length, pixel_clock, n_lines);
+	if (n_lines == 0) {
+		dev_warn(self->dev, "invalid exposure!");
+		return 0;
+	}
+
+	/* The very short (VS) exposure is an 8 bit
+	 * value. Each bit is 1/32 of a row period. */
+	/* TRY(err, ov10640_group_reg_write(self, OV10640_EXPO_VS, )); */
+	dev_dbg(self->dev,
+		"short exposure is currently controlled "
+		"in long exposure control to maintain fixed exposure ratio");
+	return 0;
+}
+
+
+/**
+ * v4l2 control handler
+ *
+ * @param ctrl the v4l2 control
+ *
+ * @return 0 on success
+ */
+static int ov10640_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct ov10640 *self =
+		container_of(ctrl->handler, struct ov10640, ctrl_handler);
+	int err = 0;
+
+	switch (ctrl->id) {
+	case V4L2_CID_HFLIP:
+		dev_dbg(self->dev, "hflip");
+		self->hflip = ctrl->val;
+		TRY(err, ov10640_hflip_set(self, ctrl->val));
+		break;
+	case V4L2_CID_VFLIP:
+		dev_dbg(self->dev, "vflip");
+		self->vflip = ctrl->val;
+		TRY(err, ov10640_vflip_set(self, ctrl->val));
+		break;
+	case TEGRA_CAMERA_CID_SENSOR_MODE_ID:
+		self->s_data->sensor_mode_id = *ctrl->p_new.p_s64;
+		return 0;
+		break;
+	case TEGRA_CAMERA_CID_GAIN:
+		TRY(err, ov10640_gain_set(self, *ctrl->p_new.p_s64));
+		break;
+	case TEGRA_CAMERA_CID_FRAME_RATE:
+		TRY(err, ov10640_framerate_set(self, *ctrl->p_new.p_s64));
+		break;
+	case TEGRA_CAMERA_CID_EXPOSURE:
+		TRY(err, ov10640_exposure_set(self, *ctrl->p_new.p_s64));
+		break;
+	case TEGRA_CAMERA_CID_EXPOSURE_SHORT:
+		TRY(err, ov10640_exposure_short_set(self, *ctrl->p_new.p_s64));
+		break;
+	case TEGRA_CAMERA_CID_HDR_EN:
+		dev_dbg(self->dev, "hdr enable called");
+		break;
+	case TEGRA_CAMERA_CID_GROUP_HOLD:
+		TRY(err, ov10640_group_hold_enable(self, ctrl->val));
+		break;
+	/* case OV10640_CID_FLIP_MIRROR: */
+	/* 	TRY(err, ov10640_flip_mirror_set(self, ctrl->val)); */
+	/* 	break; */
+	case OV10640_CID_FSYNC_ENABLE:
+		TRY(err, ov10640_frame_sync_enable_set(self, ctrl->val));
+		break;
+	default:
+		dev_err(self->dev, "unknown ctrl id=%d hflip=%d",
+			ctrl->id, V4L2_CID_HFLIP);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static const struct v4l2_ctrl_ops ov10640_ctrl_ops = {
+	.s_ctrl = ov10640_s_ctrl,
+};
+
+static const s64 ov10640_analog_gain_values[] = { 1, 2, 4, 8, };
+
+static struct v4l2_ctrl_config ctrl_config_list[] = {
+	{
+		.ops = &ov10640_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_SENSOR_MODE_ID,
+		.name = "Sensor Mode",
+		.type = V4L2_CTRL_TYPE_INTEGER64,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = 0,
+		.max = OV10640_MODE_END - 1,
+		.def = OV10640_MODE_DEFAULT,
+		.step = 1,
+	},
+	{
+		.ops = &ov10640_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_GAIN,
+		.name = "Gain",
+		.type = V4L2_CTRL_TYPE_INTEGER64,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = 1LL * FIXED_POINT_SCALING_FACTOR,
+		.max = 8LL * FIXED_POINT_SCALING_FACTOR,
+		.def = 1LL * FIXED_POINT_SCALING_FACTOR,
+		.step = 1LL * FIXED_POINT_SCALING_FACTOR / 1000,
+	},
+	{
+		.ops = &ov10640_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_FRAME_RATE,
+		.name = "Frame Rate",
+		.type = V4L2_CTRL_TYPE_INTEGER64,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = 30 * FIXED_POINT_SCALING_FACTOR,
+		.max = 30 * FIXED_POINT_SCALING_FACTOR,
+		.def = 30 * FIXED_POINT_SCALING_FACTOR,
+		.step = 1 * FIXED_POINT_SCALING_FACTOR,
+	},
+	{
+		.ops = &ov10640_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_EXPOSURE,
+		.name = "Exposure",
+		.type = V4L2_CTRL_TYPE_INTEGER64,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		/* min is one line */
+		.min = OV10640_MIN_EXPO * FIXED_POINT_SCALING_FACTOR / 1000000LL,
+		.max = OV10640_MAX_EXPO * FIXED_POINT_SCALING_FACTOR / 1000000LL,
+		.def = OV10640_DEF_EXPO * FIXED_POINT_SCALING_FACTOR / 1000000LL,
+		/* step is one line at a time */
+		.step = OV10640_MIN_EXPO * FIXED_POINT_SCALING_FACTOR /1000000LL,
+	},
+		{
+		.ops = &ov10640_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_EXPOSURE_SHORT,
+		.name = "Exposure",
+		.type = V4L2_CTRL_TYPE_INTEGER64,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		/* min is 1/32 of a row period */
+		.min = OV10640_MIN_EXPO_SHORT * FIXED_POINT_SCALING_FACTOR / 1000000LL,
+		/* max is 8 row periods */
+		.max = OV10640_MAX_EXPO_SHORT * FIXED_POINT_SCALING_FACTOR / 1000000LL,
+		.def = OV10640_DEF_EXPO_SHORT * FIXED_POINT_SCALING_FACTOR / 1000000LL,
+		/* step is 1/32 of a line */
+		.step = OV10640_MIN_EXPO_SHORT * FIXED_POINT_SCALING_FACTOR /1000000LL,
+	},
+	{
+		.ops = &ov10640_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_HDR_EN,
+		.name = "HDR enable",
+		.type = V4L2_CTRL_TYPE_INTEGER_MENU,
+		.min = 0,
+		.max = ARRAY_SIZE(switch_ctrl_qmenu) - 1,
+		.menu_skip_mask = 0,
+		.def = 0,
+		.qmenu_int = switch_ctrl_qmenu,
+	},
+	{
+		.ops = &ov10640_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_GROUP_HOLD,
+		.name = "Group Hold",
+		.type = V4L2_CTRL_TYPE_INTEGER_MENU,
+		.min = 0,
+		.max = ARRAY_SIZE(switch_ctrl_qmenu) - 1,
+		.menu_skip_mask = 0,
+		.def = 0,
+		.qmenu_int = switch_ctrl_qmenu,
+	},
+	/* { */
+	/* 	.ops = &ov10640_ctrl_ops, */
+	/* 	.id = OV10640_CID_FLIP_MIRROR, */
+	/* 	.name = "Flip and Mirror", */
+	/* 	.type = V4L2_CTRL_TYPE_INTEGER, */
+	/* 	.flags = V4L2_CTRL_FLAG_SLIDER, */
+	/* 	.min = OV10640_NO_FLIP_MIRROR, */
+	/* 	.max = OV10640_FLIP_AND_MIRROR, */
+	/* 	.def = OV10640_FLIP, */
+	/* 	.step = 1, */
+	/* }, */
+	{
+		.ops = &ov10640_ctrl_ops,
+		.id = OV10640_CID_FSYNC_ENABLE,
+		.name = "Frame Sync Enable",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = 0,
+		.max = 1,
+		.def = 0,
+		.step = 1,
+	},
+};
+
+#define OV10640_NUM_CUSTOM_CONTROLS	ARRAY_SIZE(ctrl_config_list)
+#define OV10640_NUM_STD_CONTROLS	(2)
+#define OV10640_NUM_CONTROLS		(OV10640_NUM_CUSTOM_CONTROLS + OV10640_NUM_STD_CONTROLS)
+
+int ov10640_ctrls_count(void)
+{
+	return OV10640_NUM_CONTROLS;
+}
+
+/**
+ * Initializes v4l2 controls (taken from example code).
+ */
+int ov10640_ctrls_init(struct ov10640 *self)
+{
+	struct v4l2_ctrl *ctrl;
+	int numctrls;
+	int err;
+	int i;
+	int ctrl_index = 0;
+
+	dev_dbg(self->dev, "ENTER");
+
+	self->numctrls = numctrls = ov10640_ctrls_count();
+	self->ctrls = devm_kzalloc(self->dev, sizeof(struct v4l2_ctrl *) * numctrls,
+				   GFP_KERNEL);
+
+	v4l2_ctrl_handler_init(&self->ctrl_handler, numctrls);
+
+	ctrl = v4l2_ctrl_new_std(&self->ctrl_handler, &ov10640_ctrl_ops,
+				 V4L2_CID_HFLIP, 0, 1, 1, 0);
+	if (ctrl == NULL) {
+		dev_err(self->dev, "Error initializing standard control\n");
+		err = -EINVAL;
+		goto error;
+	}
+	self->ctrls[ctrl_index++] = ctrl;
+
+	ctrl = v4l2_ctrl_new_std(&self->ctrl_handler, &ov10640_ctrl_ops,
+				 V4L2_CID_VFLIP, 0, 1, 1, 1);
+	if (ctrl == NULL) {
+		dev_err(self->dev, "Error initializing standard control\n");
+		err = -EINVAL;
+		goto error;
+	}
+	self->ctrls[ctrl_index++] = ctrl;
+
+
+	for (i = 0; i < OV10640_NUM_CUSTOM_CONTROLS; i++) {
+		ctrl = v4l2_ctrl_new_custom(&self->ctrl_handler, &ctrl_config_list[i], NULL);
+		if (ctrl == NULL) {
+			dev_err(self->dev, "Failed to init %s ctrl",
+				ctrl_config_list[i].name);
+			continue;
+		}
+
+		if (ctrl_config_list[i].type == V4L2_CTRL_TYPE_STRING &&
+		    ctrl_config_list[i].flags & V4L2_CTRL_FLAG_READ_ONLY) {
+			ctrl->p_new.p_char = devm_kzalloc(self->dev, ctrl_config_list[i].max + 1,
+							  GFP_KERNEL);
+			if (!ctrl->p_new.p_char)
+				return -ENOMEM;
+		}
+		self->ctrls[ctrl_index++] = ctrl;
+	}
+	BUG_ON(ctrl_index != OV10640_NUM_CONTROLS);
+
+	self->subdev->ctrl_handler = &self->ctrl_handler;
+	if (self->ctrl_handler.error) {
+		dev_err(self->dev, "Error %d adding controls", self->ctrl_handler.error);
+		err = self->ctrl_handler.error;
+		goto error;
+	}
+
+	if ((err = v4l2_ctrl_handler_setup(&self->ctrl_handler))) {
+		dev_err(self->dev, "Error %d setting default controls", err);
+		goto error;
+	}
+
+	dev_dbg(self->dev, "EXIT");
+
+	return 0;
+
+error:
+	v4l2_ctrl_handler_free(&self->ctrl_handler);
+	return err;
+}
diff --git a/drivers/d3/ov10640/ov10640_ctrls.h b/drivers/d3/ov10640/ov10640_ctrls.h
new file mode 100644
index 000000000000..199e0e6bbd84
--- /dev/null
+++ b/drivers/d3/ov10640/ov10640_ctrls.h
@@ -0,0 +1,30 @@
+/**
+ * @author Josh Watts <jwatts@d3engineering.com>
+ *
+ * ov10640 v4l2 driver for Nvidia Jetson
+ *
+ * Copyright (c) 2019, D3 Engineering.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+#ifndef _OV10640_CTRLS_H
+#define _OV10640_CTRLS_H
+
+#include "ov10640.h"
+
+int ov10640_ctrls_count(void);
+int ov10640_ctrls_init(struct ov10640 *self);
+int ov10640_hflip_set(struct ov10640 *self, bool hflip);
+int ov10640_vflip_set(struct ov10640 *self, bool vflip);
+
+#endif
diff --git a/drivers/d3/ov10640/ov10640_main.c b/drivers/d3/ov10640/ov10640_main.c
new file mode 100644
index 000000000000..875b455010b6
--- /dev/null
+++ b/drivers/d3/ov10640/ov10640_main.c
@@ -0,0 +1,483 @@
+/**
+ * @author Josh Watts <jwatts@d3engineering.com>
+ *
+ * ov10640 v4l2 driver for Nvidia Jetson
+ *
+ * Copyright (c) 2019, D3 Engineering.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+#include <linux/module.h>
+#include <linux/of_device.h>
+/* Nvidia camera utility code */
+#include <media/camera_common.h>
+
+#include <d3/d3-jetson-bsp.h>
+
+#include <d3/ub960.h>
+
+#include "ov10640.h"
+#include "ov10640_reg.h"
+#include "ov10640_tables.h"
+#include "ov10640_ctrls.h"
+
+extern int ub953_set_frame_sync_enable(struct device *dev, bool enabled);
+
+
+
+/**
+ * Notes:
+
+	aCSP section 1.4 lists registers for start/stop of sensor output (finishes current frame on stop)
+		Remove final start from reg table
+
+
+ */
+
+/**
+ * This is part of Nvidia camera_common framework. They create a file
+ * in sysfs that you can use to read and write registers. That hooks
+ * into this.
+ *
+ * @param s_data
+ * @param addr address to read
+ * @param val where to store value
+ *
+ * @return 0 on success
+ */
+static int ov10640_camera_read_reg(struct camera_common_data *s_data, u16 addr,
+				   u8 *val)
+{
+	struct ov10640 *self = s_data->priv;
+	unsigned int _val;
+	int result;
+	result = regmap_read(self->map, addr, &_val);
+	*val = _val;
+	return result;
+}
+
+
+/**
+ * This is part of Nvidia camera_common framework. They create a file
+ * in sysfs that you can use to read and write registers. That hooks
+ * into this.
+ *
+ * @param s_data
+ * @param addr address to write
+ * @param val what to write
+ *
+ * @return 0 on success
+ */
+static int ov10640_camera_write_reg(struct camera_common_data *s_data, u16 addr,
+				    u8 val)
+{
+	struct ov10640 *self = s_data->priv;
+	return regmap_write(self->map, addr, val);
+}
+
+
+/**
+ * This is called to start the stream. Currently this doesn't really
+ * do anything other than log start/stop.
+ *
+ * @param sd sub device
+ * @param enable enable/disable stream
+ *
+ * @return
+ */
+static int ov10640_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_common_data *s_data = to_camera_common_data(&client->dev);
+	struct ov10640 *self = (struct ov10640 *)s_data->priv;
+	struct i2c_client *parent_client;
+	int mode_ix = self->s_data->sensor_mode_id;
+	int is_hdr = ov10640_formats[mode_ix].hdr_en;
+	parent_client = of_find_i2c_device_by_node(client->dev.of_node->parent);
+
+	dev_dbg(self->dev, "mode: %d %s %s",
+		mode_ix,
+		is_hdr ? "HDR": "linear",
+		enable ? "START" : "STOP");
+
+	if (self->deserializer) {
+		ub960_s_stream(self->deserializer, self->client, enable);
+	}
+
+
+	if (enable) {
+		/* configure the sensor */
+		/* regmap_write(self->map, OV10640_REG_SOFTWARE_CTRL2, */
+		/* 	     OV10640_REG_SOFTWARE_CTRL2_RESET); */
+		regmap_multi_reg_write(
+			self->map,
+			mode_table[mode_ix].reg_sequence,
+			mode_table[mode_ix].size);
+		ov10640_hflip_set(self, self->hflip);
+		ov10640_vflip_set(self, self->vflip);
+		regmap_update_bits(self->map,
+				   OV10640_REG_SENSOR_CTRL,
+				   OV10640_REG_SENSOR_CTRL_FSIN_EN_MASK,
+				   OV10640_REG_SENSOR_CTRL_FSIN_EN(self->frame_sync_mode));
+
+		regmap_multi_reg_write(self->map, mode_stream, mode_stream_len);
+		if (self->frame_sync_mode) {
+			ub953_set_frame_sync_enable(&parent_client->dev, true);
+		}
+	} else {
+		ub953_set_frame_sync_enable(&parent_client->dev, false);
+		regmap_write(self->map, OV10640_REG_SOFTWARE_CTRL1,
+			     OV10640_REG_SOFTWARE_CTRL1_SW_STBY);
+	}
+	return 0;
+}
+
+static struct v4l2_subdev_video_ops ov10640_subdev_video_ops = {
+	.s_stream	= ov10640_s_stream,
+	.g_mbus_config	= camera_common_g_mbus_config,
+};
+
+static struct v4l2_subdev_core_ops ov10640_subdev_core_ops = {
+	.s_power	= camera_common_s_power,
+};
+
+/**
+ * v4l2 set and tryset format handler
+ *
+ * @param sd sub dev
+ * @param cfg
+ * @param format format to attempt to set or to set
+ *
+ * @return 0 on success
+ */
+static int ov10640_set_fmt(struct v4l2_subdev *sd,
+			   struct v4l2_subdev_pad_config *cfg,
+			   struct v4l2_subdev_format *format)
+{
+	int ret;
+
+	if (format->which == V4L2_SUBDEV_FORMAT_TRY)
+		ret = camera_common_try_fmt(sd, &format->format);
+	else
+		ret = camera_common_s_fmt(sd, &format->format);
+
+	return ret;
+}
+
+
+/**
+ * Returns the active format
+ *
+ * @param sd sub dev
+ * @param cfg
+ * @param format output - the active format
+ *
+ * @return
+ */
+static int ov10640_get_fmt(struct v4l2_subdev *sd,
+			   struct v4l2_subdev_pad_config *cfg,
+			   struct v4l2_subdev_format *format)
+{
+	return camera_common_g_fmt(sd, &format->format);
+}
+
+
+static struct v4l2_subdev_pad_ops ov10640_subdev_pad_ops = {
+	.set_fmt	     = ov10640_set_fmt,
+	.get_fmt	     = ov10640_get_fmt,
+	.enum_mbus_code	     = camera_common_enum_mbus_code,
+	.enum_frame_size     = camera_common_enum_framesizes,
+	.enum_frame_interval = camera_common_enum_frameintervals,
+};
+
+
+static struct v4l2_subdev_ops ov10640_subdev_ops = {
+	.core  = &ov10640_subdev_core_ops,
+	.video = &ov10640_subdev_video_ops,
+	.pad   = &ov10640_subdev_pad_ops,
+};
+
+
+static int ov10640_camera_power_on(struct camera_common_data *s_data)
+{
+	struct ov10640 *priv = (struct ov10640 *)s_data->priv;
+	struct camera_common_power_rail *pw = &priv->power;
+	pw->state = SWITCH_ON;
+	
+	return 0;
+
+}
+
+static int ov10640_camera_power_off(struct camera_common_data *s_data)
+{
+	struct ov10640 *priv = (struct ov10640 *)s_data->priv;
+	struct camera_common_power_rail *pw = &priv->power;
+	pw->state = SWITCH_OFF;
+	//TODO: Power control?
+	return 0;
+}
+
+/**
+ * These are for debugging. The Nvidia camera_common code creates a
+ * file in sysfs to read and write the image sensor.
+ */
+static struct camera_common_sensor_ops ov10640_common_ops = {
+	.power_on = ov10640_camera_power_on,
+	.power_off = ov10640_camera_power_off,
+	.write_reg = ov10640_camera_write_reg,
+	.read_reg  = ov10640_camera_read_reg,
+};
+
+static struct regmap_config ov10640_regmap_cfg = {
+	.reg_bits = 16,
+	.val_bits = 8,
+};
+
+static const struct v4l2_subdev_internal_ops ov10640_subdev_internal_ops = {
+	// No ops needed
+};
+
+
+static const struct media_entity_operations ov10640_media_ops = {
+	.link_validate = v4l2_subdev_link_validate,
+};
+
+
+static int ov10640_deserializer_parse(struct ov10640 *self,
+				      struct i2c_client **out)
+{
+	struct device_node *node = self->client->dev.of_node;
+	struct device_node *deserializer_node;
+	struct i2c_client *deserializer_client;
+
+	deserializer_node = of_parse_phandle(node, "deserializer", 0);
+	if (!deserializer_node) {
+		dev_dbg(self->dev, "could not find deserializer node");
+		return -ENOENT;
+	}
+
+	deserializer_client = of_find_i2c_device_by_node(deserializer_node);
+	of_node_put(deserializer_node);
+	deserializer_node = NULL;
+
+	if (!deserializer_client) {
+		dev_dbg(self->dev, "missing deserializer client");
+		return -ENOENT;
+	}
+
+	*out = deserializer_client;
+	return 0;
+}
+
+
+/**
+ * Pull parameters from device tree.
+ *
+ * @param s_data camera common data (for Nvidia layers)
+ *
+ * @return 0 on success
+ */
+static struct camera_common_pdata *ov10640_parse_dt(
+	struct ov10640 *self,
+	struct camera_common_data *s_data)
+{
+	struct device_node *node = self->client->dev.of_node;
+	struct camera_common_pdata *board_priv_pdata;
+	int err;
+
+	if (!node) {
+		dev_err(self->dev, "no OF node");
+		return NULL;
+	}
+
+	board_priv_pdata = devm_kzalloc(self->dev,
+					sizeof(*board_priv_pdata), GFP_KERNEL);
+
+	err = of_property_read_string(node, "mclk",
+				      &board_priv_pdata->mclk_name);
+	if (err) {
+		/* This is not fatal */
+		dev_warn(self->dev, "mclk not in DT");
+	}
+
+	if (of_property_read_s32(node,
+				 "frame-sync-mode",
+				 &self->frame_sync_mode) != 0)
+		self->frame_sync_mode = 0;
+
+	/* Errors warnings are reported in deserializer_parse. It is
+	 * OK for this to return an error as the presence of a
+	 * deserializer is optional. */
+	if (ov10640_deserializer_parse(self, &self->deserializer) == 0) {
+		dev_dbg(self->dev, "deserializer present");
+	}
+	else {
+		self->deserializer = NULL;
+	}
+	return board_priv_pdata;
+}
+
+
+/**
+ * Initializes media controller
+ *
+ * @param self driver instance
+ *
+ * @return 0 on success
+ */
+static int ov10640_media_init(struct ov10640 *self)
+{
+	int err = 0;
+#if defined(CONFIG_MEDIA_CONTROLLER)
+	self->pad.flags = MEDIA_PAD_FL_SOURCE;
+	self->subdev->entity.ops = &ov10640_media_ops;
+	/* The media controller code is slightly different on Tx2
+	 * (kernel 4.4) vs. on Xavier (kernel 4.9) */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 9, 0)
+	self->subdev->entity.type = MEDIA_ENT_T_V4L2_SUBDEV_SENSOR;
+	err = media_entity_init(&self->subdev->entity, 1, &self->pad, 0);
+#else
+	err = tegra_media_entity_init(&self->subdev->entity, 1, &self->pad, true, true);
+#endif	/* LINUX_VERSION */
+	if (err < 0) {
+		dev_err(self->dev, "unable to init media entity");
+		return err;
+	}
+#endif	/* CONFIG_MEDIA_CONTROLLER */
+	return 0;
+}
+
+
+/**
+ * This is called by the kernel when a new instance of the driver is
+ * instantiated.
+ *
+ * @param client i2c client device
+ * @param id
+ *
+ * @return 0 on success
+ */
+static int ov10640_probe(struct i2c_client *client,
+			 const struct i2c_device_id *id)
+{
+	int err = 0;
+	struct camera_common_data *common_data;
+	struct ov10640 *self = NULL;
+	int tries;
+
+	dev_dbg(&client->dev, "probe enter");
+
+	TRY_MEM(common_data, devm_kzalloc(&client->dev, sizeof(*common_data),
+					  GFP_KERNEL));
+	TRY_MEM(self, devm_kzalloc(&client->dev, sizeof(*self), GFP_KERNEL));
+	self->client = client;
+	self->dev = &client->dev;
+
+	common_data->priv = self;
+	common_data->ops = &ov10640_common_ops;
+	common_data->ctrl_handler = &self->ctrl_handler;
+	common_data->dev = &client->dev;
+	common_data->frmfmt = &ov10640_formats[0];
+	common_data->numfmts = ov10640_formats_len;
+	common_data->colorfmt = camera_common_find_datafmt(MEDIA_BUS_FMT_SBGGR12_1X12);
+
+	common_data->power = &self->power;
+	common_data->ctrls = self->ctrls;
+
+	common_data->priv = self;
+	common_data->numctrls = ov10640_ctrls_count();
+
+	common_data->def_mode = common_data->frmfmt[OV10640_MODE_DEFAULT].mode;
+	common_data->def_width = common_data->frmfmt[OV10640_MODE_DEFAULT].size.width;
+	common_data->def_height =
+		common_data->frmfmt[OV10640_MODE_DEFAULT].size.height;
+	/* common_data->def_clk_freq = 48000000; */
+	common_data->fmt_width = common_data->def_width;
+	common_data->fmt_height = common_data->def_height;
+
+	self->s_data = common_data;
+	self->s_data->sensor_mode_id = OV10640_MODE_DEFAULT;
+	self->s_data->mode = OV10640_MODE_DEFAULT;
+	self->subdev = &common_data->subdev;
+	self->subdev->dev = self->dev;
+	self->s_data->dev = self->dev;
+
+	self->pdata = ov10640_parse_dt(self, common_data);
+	if (!self->pdata)
+		return -EFAULT;
+
+	TRY_MEM(self->map, devm_regmap_init_i2c(self->client, &ov10640_regmap_cfg));
+
+	for (tries = 50; --tries >= 0; ) {
+		/* regmap_write(self->map, OV10640_REG_SOFTWARE_CTRL2, */
+		/* 	     OV10640_REG_SOFTWARE_CTRL2_RESET); */
+
+		err = regmap_multi_reg_write(self->map, mode_table[OV10640_MODE_DEFAULT].reg_sequence, mode_table[OV10640_MODE_DEFAULT].size);
+
+		if (err >= 0)
+			err = regmap_write(self->map, OV10640_REG_SOFTWARE_CTRL1, OV10640_REG_SOFTWARE_CTRL1_SW_STBY);
+
+		if (err < 0) {
+			dev_dbg(self->dev, "Giving device more time to settle\n");
+			usleep_range(50 * 1000, 50 * 1000);
+		} else
+			break;
+	}
+	if (err < 0) {
+		dev_err(self->dev, "Failed to find device\n");
+		return err;
+	}
+
+	TRY(err, camera_common_initialize(common_data, "ov10640"));
+
+	v4l2_i2c_subdev_init(self->subdev, client, &ov10640_subdev_ops);
+	TRY(err, ov10640_ctrls_init(self));
+
+	self->subdev->internal_ops = &ov10640_subdev_internal_ops;
+	self->subdev->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE | V4L2_SUBDEV_FL_HAS_EVENTS;
+
+	TRY(err, ov10640_media_init(self));
+	TRY(err, v4l2_async_register_subdev(self->subdev));
+
+	dev_dbg(self->dev, "probe success");
+	return 0;
+}
+
+static struct of_device_id ov10640_of_match[] = {
+	{ .compatible = "d3,ov10640"},
+	{ },
+};
+MODULE_DEVICE_TABLE(of, ov10640_of_match);
+
+static const struct i2c_device_id ov10640_id[] = {
+	{"ov10640", 0},
+	{}
+};
+MODULE_DEVICE_TABLE(i2c, ov10640_id);
+
+
+static struct i2c_driver ov10640_driver = {
+	.driver = {
+		.name = "ov10640",
+		.owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(ov10640_of_match),
+	},
+	.probe = ov10640_probe,
+	.id_table = ov10640_id,
+};
+module_i2c_driver(ov10640_driver);
+MODULE_DESCRIPTION("Driver for OV10640 camera for Nvidia Jetson");
+MODULE_VERSION(D3_JETSON_BSP_VERSION);
+MODULE_AUTHOR("Greg Rowe <growe@d3engineering.com>");
+MODULE_AUTHOR("Josh Watts <jwatts@d3engineering.com>");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/d3/ov10640/ov10640_reg.h b/drivers/d3/ov10640/ov10640_reg.h
new file mode 100644
index 000000000000..464045aa4f31
--- /dev/null
+++ b/drivers/d3/ov10640/ov10640_reg.h
@@ -0,0 +1,72 @@
+/**
+ * @author Josh Watts <jwatts@d3engineering.com>
+ *
+ * ov10640 v4l2 driver for Nvidia Jetson
+ *
+ * Copyright (c) 2019, D3 Engineering.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+#ifndef _OV10640_REG_H
+#define _OV10640_REG_H
+
+#define OV10640_REG_SOFTWARE_CTRL1		0x3012
+#define OV10640_REG_SOFTWARE_CTRL1_SW_STBY	(0u << 0)
+#define OV10640_REG_SOFTWARE_CTRL1_STREAMING	(1u << 0)
+
+#define OV10640_REG_SOFTWARE_CTRL2		0x3013
+#define OV10640_REG_SOFTWARE_CTRL2_RESET	0x1
+
+
+#define OV10640_REG_GROUP_CTRL			0x302c
+#define OV10640_REG_GROUP_CTRL_PRE_SOF		(1u << 5)
+#define OV10640_REG_GROUP_CTRL_1ST_GRP(x)	((x) << 2)
+#define OV10640_REG_GROUP_CTRL_1ST_GRP_MASK	(3u << 2)
+#define OV10640_REG_OPERATION_CTRL		0x302f
+#define OV10640_REG_OPERATION_CTRL_SINGLE_START	(1u << 0)
+
+#define OV10640_REG_HTS_H			0x3080
+#define OV10640_REG_VTS_H			0x3082
+#define OV10640_REG_VTS_L			0x3083
+
+#define OV10640_REG_SENSOR_CTRL     0x308C
+#define OV10640_REG_SENSOR_CTRL_FSIN_EN(x)      (0x90*x)
+#define OV10640_REG_SENSOR_CTRL_FSIN_EN_MASK    (0x90)
+
+#define OV10640_DARK_CURRENT_L_H		0x30D0
+#define OV10640_ROW_AVERAGE_L_H			0x30D6
+#define OV10640_EXPO_L_H			0x30E6
+#define OV10640_EXPO_S_H			0x30E8
+#define OV10640_EXPO_VS				0x30EA
+#define OV10640_CG_AGAIN			0x30EB
+#define OV10640_CG_AGAIN_L_AGAIN(x)		((x) << 0)
+#define OV10640_CG_AGAIN_L_AGAIN_MASK		(3u << 0)
+
+#define OV10640_DIG_L_GAIN_L			0x30ED
+#define OV10640_DIG_L_GAIN_H			0x30EC
+#define OV10640_DIG_S_GAIN_L			0x30EF
+#define OV10640_DIG_S_GAIN_H			0x30EE
+#define OV10640_DIG_VS_GAIN_L			0x30F1
+#define OV10640_DIG_VS_GAIN_H			0x30F0
+
+#define OV10640_REG_READ_MODE                     0x3090
+#define OV10640_REG_READ_MODE_FLIP_MIRROR(x)      ((x) << 2)
+#define OV10640_REG_READ_MODE_FLIP_MIRROR_MASK    (0x0c)
+#define OV10640_REG_R_ISP_CTRL_2                  0x3128
+#define OV10640_REG_R_ISP_CTRL_2_FLIP_MIRROR(x)   ((x) << 0)
+#define OV10640_REG_R_ISP_CTRL_2_FLIP_MIRROR_MASK (0x03)
+#define OV10640_REG_R_CTRL08                      0x3291
+#define OV10640_REG_R_CTRL08_FLIP_MIRROR(x)       ((x) << 1)
+#define OV10640_REG_R_CTRL08_FLIP_MIRROR_MASK     (0x06)
+
+#endif
diff --git a/drivers/d3/ov10640/ov10640_tables.c b/drivers/d3/ov10640/ov10640_tables.c
new file mode 100644
index 000000000000..96194a683349
--- /dev/null
+++ b/drivers/d3/ov10640/ov10640_tables.c
@@ -0,0 +1,2743 @@
+/**
+ * @author Greg Rowe <growe@d3engineering.com>
+ *
+ * ov10640 v4l2 driver for Nvidia Jetson - default register settings
+ *
+ * Copyright (c) 2019, D3 Engineering.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+#include "ov10640_tables.h"
+#include <media/camera_common.h>
+
+/**
+ * This configuration comes from MMS's release for TI Vision SDK 3.05.
+ */
+#ifdef CONFIG_D3_OV10640_HDR_ENABLE
+const struct reg_sequence mode_1280x1080hdr[] = {
+	{0x3013, 0x01, 10000},
+	{0x328a, 0x11, 0x00},
+	{0x313f, 0x80, 0x00},
+	{0x3132, 0x24, 0x00},
+	{0x3000, 0x03, 0x00},
+	{0x3002, 0x07, 0x00},
+	{0x3004, 0x03, 0x00},
+	{0x3005, 0x60, 0x00},
+	{0x3006, 0x07, 0x00},
+	{0x3007, 0x01, 0x00},
+	{0x3014, 0x03, 0x00},
+	{0x3023, 0x05, 0x00},
+	{0x3032, 0x35, 0x00},
+	{0x3033, 0x04, 0x00},
+	{0x3054, 0x00, 0x00},
+	{0x3055, 0x03, 0x00},
+	{0x3056, 0x01, 0x00},
+	{0x3057, 0xff, 0x00},
+	{0x3058, 0xaf, 0x00},
+	{0x3059, 0x44, 0x00},
+	{0x305a, 0x02, 0x00},
+	{0x305b, 0x00, 0x00},
+	{0x305c, 0x30, 0x00},
+	{0x305d, 0x9c, 0x00},
+	{0x305e, 0x19, 0x00},
+	{0x305f, 0x18, 0x00},
+	{0x3060, 0xf9, 0x00},
+	{0x3061, 0xf0, 0x00},
+	{0x308c, 0x03, 0x00},
+	{0x308f, 0x10, 0x00},
+	/* hdr mode  */
+	{0x3090, 0x08, 0x00},  /* flip */
+	/* linear mode */
+	/* {0x3090, 0x68, 0x00},  /\* Single exposure and flip *\/ */
+	{0x3091, 0x00, 0x00},  /* Disable embedded data lines */
+	{0x3291, 0x04, 0x00},  /* flip */
+	{0x30a3, 0x08, 0x00},
+	{0x30ad, 0x03, 0x00},
+	{0x30ae, 0x80, 0x00},
+	{0x30af, 0x80, 0x00},
+	{0x30b0, 0xff, 0x00},
+	{0x30b1, 0x3f, 0x00},
+	{0x30b2, 0x22, 0x00},
+	{0x30b9, 0x22, 0x00},
+	{0x30bb, 0x00, 0x00},
+	{0x30bc, 0x00, 0x00},
+	{0x30bd, 0x00, 0x00},
+	{0x30be, 0x00, 0x00},
+	{0x30bf, 0x00, 0x00},
+	{0x30c0, 0x00, 0x00},
+	{0x30c1, 0x00, 0x00},
+	{0x30c2, 0x00, 0x00},
+	{0x30c3, 0x00, 0x00},
+	{0x30c4, 0x80, 0x00},
+	{0x30c5, 0x00, 0x00},
+	{0x30c6, 0x80, 0x00},
+	{0x30c7, 0x00, 0x00},
+	{0x30c8, 0x80, 0x00},
+	{0x3119, 0x55, 0x00},
+	{0x311a, 0x01, 0x00},
+	{0x311b, 0x4a, 0x00},
+	{0x3074, 0x00, 0x00},
+	{0x3075, 0x00, 0x00},
+	{0x3078, 0x05, 0x00},
+	{0x3079, 0x07, 0x00},
+	{0x307a, 0x04, 0x00},
+	{0x307b, 0x41, 0x00},
+	{0x307c, 0x05, 0x00},
+	{0x307d, 0x00, 0x00},
+	{0x307e, 0x04, 0x00},
+	{0x307f, 0x38, 0x00},
+	{0x3080, 0x05, 0x00},	/* line length 0x5aa (1450) */
+	{0x3081, 0xaa, 0x00},
+	{0x3084, 0x00, 0x00},
+	{0x3085, 0x04, 0x00},
+	{0x3086, 0x00, 0x00},
+	{0x3087, 0x04, 0x00},
+	{0x3088, 0x00, 0x00},
+	{0x3089, 0x40, 0x00},
+	{0x308d, 0x92, 0x00},
+	{0x3094, 0xa5, 0x00},
+	{0x30e6, 0x02, 0x00},
+	{0x30e7, 0xe0, 0x00},
+	{0x30e8, 0x02, 0x00},
+	{0x30e9, 0xe0, 0x00},
+/*{0x30eb, 0x40 , 0x00},*/
+	{0x30eb, 0x00, 0x00},
+	{0x30ec, 0x01, 0x00},
+	{0x30ed, 0x80, 0x00},
+	{0x30ee, 0x01, 0x00},
+	{0x30f0, 0x01, 0x00},
+	{0x30ef, 0x80, 0x00},
+	{0x30f1, 0x80, 0x00},
+	{0x30fa, 0x76, 0x00},
+	{0x3120, 0x00, 0x00},
+	{0x3121, 0x01, 0x00},
+	{0x3122, 0x00, 0x0A},
+	{0x3127, 0x63, 0x00},
+	{0x3128, 0xc2, 0x00},  /* flip */
+	{0x3129, 0x00, 0x00},
+	{0x31be, 0x00, 0x00},
+	{0x30a5, 0x78, 0x00},
+	{0x30a6, 0x40, 0x00},
+	{0x30a7, 0x78, 0x00},
+	{0x30a8, 0x80, 0x00},
+	{0x30a9, 0x78, 0x00},
+	{0x30aa, 0xe0, 0x00},
+	{0x30ab, 0xf9, 0x00},
+	{0x30ac, 0xc0, 0x00},
+	{0x3440, 0x04, 0x00},
+	{0x3444, 0x48, 0x00},
+	{0x344e, 0x2c, 0x00},
+	{0x3457, 0x33, 0x00},
+	{0x345e, 0x38, 0x00},
+	{0x3461, 0xa8, 0x00},
+	{0x7002, 0xaa, 0x00},
+	{0x7001, 0xdf, 0x00},
+	{0x7048, 0x00, 0x00},
+	{0x7049, 0x02, 0x00},
+	{0x704a, 0x02, 0x00},
+	{0x704b, 0x00, 0x00},
+	{0x704c, 0x01, 0x00},
+	{0x704d, 0x00, 0x00},
+	{0x7043, 0x04, 0x00},
+	{0x7040, 0x3c, 0x00},
+	{0x7047, 0x00, 0x00},
+	{0x7044, 0x01, 0x00},
+	{0x7000, 0x1f, 0x00},
+	{0x7084, 0x01, 0x00},
+	{0x7085, 0x03, 0x00},
+	{0x7086, 0x02, 0x00},
+	{0x7087, 0x40, 0x00},
+	{0x7088, 0x01, 0x00},
+	{0x7089, 0x20, 0x00},
+	{0x707f, 0x04, 0x00},
+	{0x707c, 0x3c, 0x00},
+	{0x7083, 0x00, 0x00},
+	{0x7080, 0x01, 0x00},
+	{0x7003, 0xdf, 0x00},
+	{0x70c0, 0x00, 0x00},
+	{0x70c1, 0x02, 0x00},
+	{0x70c2, 0x02, 0x00},
+	{0x70c3, 0x00, 0x00},
+	{0x70c4, 0x01, 0x00},
+	{0x70c5, 0x00, 0x00},
+	{0x70b8, 0x03, 0x00},
+	{0x70b9, 0x98, 0x00},
+	{0x70bc, 0x00, 0x00},
+	{0x70bd, 0x80, 0x00},
+	{0x7004, 0x02, 0x00},
+	{0x7005, 0x00, 0x00},
+	{0x7006, 0x01, 0x00},
+	{0x7007, 0x80, 0x00},
+	{0x7008, 0x02, 0x00},
+	{0x7009, 0x00, 0x00},
+	{0x700a, 0x04, 0x00},
+	{0x700b, 0x00, 0x00},
+	{0x700e, 0x00, 0x00},
+	{0x700f, 0x60, 0x00},
+	{0x701a, 0x02, 0x00},
+	{0x701b, 0x00, 0x00},
+	{0x701c, 0x01, 0x00},
+	{0x701d, 0x80, 0x00},
+	{0x701e, 0x02, 0x00},
+	{0x701f, 0x00, 0x00},
+	{0x7020, 0x04, 0x00},
+	{0x7021, 0x00, 0x00},
+	{0x7024, 0x00, 0x00},
+	{0x7025, 0x60, 0x00},
+	{0x70e7, 0x00, 0x00},
+	{0x70e4, 0x10, 0x00},
+	{0x70e5, 0x00, 0x00},
+	{0x70e6, 0x00, 0x00},
+	{0x70eb, 0x00, 0x00},
+	{0x70e8, 0x10, 0x00},
+	{0x70e9, 0x00, 0x00},
+	{0x70ea, 0x00, 0x00},
+	{0x70ef, 0x00, 0x00},
+	{0x70ec, 0xfd, 0x00},
+	{0x70ed, 0x00, 0x00},
+	{0x70ee, 0x00, 0x00},
+	{0x70eb, 0x00, 0x00},
+	{0x70f0, 0xfd, 0x00},
+	{0x70f1, 0x00, 0x00},
+	{0x70f2, 0x00, 0x00},
+	{0x30fb, 0x06, 0x00},
+	{0x30fc, 0x80, 0x00},
+	{0x30fd, 0x02, 0x00},
+	{0x30fe, 0x93, 0x00},
+	{0x6000, 0xc1, 0x00},
+	{0x6001, 0xb9, 0x00},
+	{0x6002, 0xba, 0x00},
+	{0x6003, 0xa4, 0x00},
+	{0x6004, 0xb5, 0x00},
+	{0x6005, 0xa0, 0x00},
+	{0x6006, 0x82, 0x00},
+	{0x6007, 0xa7, 0x00},
+	{0x6008, 0xb7, 0x00},
+	{0x6009, 0x5c, 0x00},
+	{0x600a, 0x9e, 0x00},
+	{0x600b, 0xc0, 0x00},
+	{0x600c, 0xd2, 0x00},
+	{0x600d, 0x33, 0x00},
+	{0x600e, 0xcc, 0x00},
+	{0x600f, 0xe2, 0x00},
+	{0x6010, 0xc1, 0x00},
+	{0x6011, 0xab, 0x00},
+	{0x6012, 0xb7, 0x00},
+	{0x6013, 0x00, 0x00},
+	{0x6014, 0x00, 0x00},
+	{0x6015, 0x00, 0x00},
+	{0x6016, 0x00, 0x00},
+	{0x6017, 0x00, 0x00},
+	{0x6018, 0x00, 0x00},
+	{0x6019, 0x00, 0x00},
+	{0x601a, 0x00, 0x00},
+	{0x601b, 0x00, 0x00},
+	{0x601c, 0x00, 0x00},
+	{0x601d, 0x00, 0x00},
+	{0x601e, 0x9c, 0x00},
+	{0x601f, 0x94, 0x00},
+	{0x6020, 0x90, 0x00},
+	{0x6021, 0xc5, 0x00},
+	{0x6022, 0x01, 0x00},
+	{0x6023, 0x54, 0x00},
+	{0x6024, 0x2a, 0x00},
+	{0x6025, 0x61, 0x00},
+	{0x6026, 0xd2, 0x00},
+	{0x6027, 0xcc, 0x00},
+	{0x6028, 0x04, 0x00},
+	{0x6029, 0x35, 0x00},
+	{0x602a, 0xb1, 0x00},
+	{0x602b, 0xb2, 0x00},
+	{0x602c, 0xb3, 0x00},
+	{0x602d, 0xd2, 0x00},
+	{0x602e, 0xd3, 0x00},
+	{0x602f, 0x12, 0x00},
+	{0x6030, 0x31, 0x00},
+	{0x6031, 0xcc, 0x00},
+	{0x6032, 0x06, 0x00},
+	{0x6033, 0xd2, 0x00},
+	{0x6034, 0xc4, 0x00},
+	{0x6035, 0xce, 0x00},
+	{0x6036, 0x18, 0x00},
+	{0x6037, 0xcf, 0x00},
+	{0x6038, 0x1e, 0x00},
+	{0x6039, 0xd0, 0x00},
+	{0x603a, 0x24, 0x00},
+	{0x603b, 0xc5, 0x00},
+	{0x603c, 0xd2, 0x00},
+	{0x603d, 0xbc, 0x00},
+	{0x603e, 0xcc, 0x00},
+	{0x603f, 0x52, 0x00},
+	{0x6040, 0x2b, 0x00},
+	{0x6041, 0xd2, 0x00},
+	{0x6042, 0xd3, 0x00},
+	{0x6043, 0x02, 0x00},
+	{0x6044, 0xcc, 0x00},
+	{0x6045, 0x0a, 0x00},
+	{0x6046, 0xd2, 0x00},
+	{0x6047, 0xd3, 0x00},
+	{0x6048, 0x0f, 0x00},
+	{0x6049, 0x1a, 0x00},
+	{0x604a, 0x2a, 0x00},
+	{0x604b, 0xd4, 0x00},
+	{0x604c, 0xf6, 0x00},
+	{0x604d, 0xba, 0x00},
+	{0x604e, 0x56, 0x00},
+	{0x604f, 0xd3, 0x00},
+	{0x6050, 0x2e, 0x00},
+	{0x6051, 0x54, 0x00},
+	{0x6052, 0x26, 0x00},
+	{0x6053, 0xd2, 0x00},
+	{0x6054, 0xcc, 0x00},
+	{0x6055, 0x60, 0x00},
+	{0x6056, 0xd2, 0x00},
+	{0x6057, 0xd3, 0x00},
+	{0x6058, 0x27, 0x00},
+	{0x6059, 0x27, 0x00},
+	{0x605a, 0x08, 0x00},
+	{0x605b, 0x1a, 0x00},
+	{0x605c, 0xcc, 0x00},
+	{0x605d, 0x88, 0x00},
+	{0x605e, 0x00, 0x00},
+	{0x605f, 0x12, 0x00},
+	{0x6060, 0x2c, 0x00},
+	{0x6061, 0x60, 0x00},
+	{0x6062, 0xc2, 0x00},
+	{0x6063, 0xb9, 0x00},
+	{0x6064, 0xa5, 0x00},
+	{0x6065, 0xb5, 0x00},
+	{0x6066, 0xa0, 0x00},
+	{0x6067, 0x82, 0x00},
+	{0x6068, 0x5c, 0x00},
+	{0x6069, 0xd4, 0x00},
+	{0x606a, 0xbe, 0x00},
+	{0x606b, 0xd4, 0x00},
+	{0x606c, 0xbe, 0x00},
+	{0x606d, 0xd3, 0x00},
+	{0x606e, 0x01, 0x00},
+	{0x606f, 0x7c, 0x00},
+	{0x6070, 0x74, 0x00},
+	{0x6071, 0x00, 0x00},
+	{0x6072, 0x61, 0x00},
+	{0x6073, 0x2a, 0x00},
+	{0x6074, 0xd2, 0x00},
+	{0x6075, 0xcc, 0x00},
+	{0x6076, 0xdf, 0x00},
+	{0x6077, 0xc6, 0x00},
+	{0x6078, 0x35, 0x00},
+	{0x6079, 0xd2, 0x00},
+	{0x607a, 0xcc, 0x00},
+	{0x607b, 0x06, 0x00},
+	{0x607c, 0x31, 0x00},
+	{0x607d, 0xd2, 0x00},
+	{0x607e, 0xc5, 0x00},
+	{0x607f, 0xbb, 0x00},
+	{0x6080, 0xcc, 0x00},
+	{0x6081, 0x18, 0x00},
+	{0x6082, 0xc6, 0x00},
+	{0x6083, 0xd2, 0x00},
+	{0x6084, 0xbd, 0x00},
+	{0x6085, 0xcc, 0x00},
+	{0x6086, 0x52, 0x00},
+	{0x6087, 0x2b, 0x00},
+	{0x6088, 0xd2, 0x00},
+	{0x6089, 0xd3, 0x00},
+	{0x608a, 0x01, 0x00},
+	{0x608b, 0xcc, 0x00},
+	{0x608c, 0x0a, 0x00},
+	{0x608d, 0xd2, 0x00},
+	{0x608e, 0xd3, 0x00},
+	{0x608f, 0x0f, 0x00},
+	{0x6090, 0x1a, 0x00},
+	{0x6091, 0x71, 0x00},
+	{0x6092, 0x2a, 0x00},
+	{0x6093, 0xd4, 0x00},
+	{0x6094, 0xf6, 0x00},
+	{0x6095, 0xd3, 0x00},
+	{0x6096, 0x22, 0x00},
+	{0x6097, 0x70, 0x00},
+	{0x6098, 0xca, 0x00},
+	{0x6099, 0x26, 0x00},
+	{0x609a, 0xd2, 0x00},
+	{0x609b, 0xcc, 0x00},
+	{0x609c, 0x60, 0x00},
+	{0x609d, 0xd2, 0x00},
+	{0x609e, 0xd3, 0x00},
+	{0x609f, 0x27, 0x00},
+	{0x60a0, 0x27, 0x00},
+	{0x60a1, 0x08, 0x00},
+	{0x60a2, 0x1a, 0x00},
+	{0x60a3, 0xcc, 0x00},
+	{0x60a4, 0x88, 0x00},
+	{0x60a5, 0x12, 0x00},
+	{0x60a6, 0x2c, 0x00},
+	{0x60a7, 0x60, 0x00},
+	{0x60a8, 0x00, 0x00},
+	{0x60a9, 0x00, 0x00},
+	{0x60aa, 0xc0, 0x00},
+	{0x60ab, 0xb9, 0x00},
+	{0x60ac, 0xa3, 0x00},
+	{0x60ad, 0xb5, 0x00},
+	{0x60ae, 0x00, 0x00},
+	{0x60af, 0xa0, 0x00},
+	{0x60b0, 0x82, 0x00},
+	{0x60b1, 0x5c, 0x00},
+	{0x60b2, 0xd4, 0x00},
+	{0x60b3, 0xa0, 0x00},
+	{0x60b4, 0x9d, 0x00},
+	{0x60b5, 0xd3, 0x00},
+	{0x60b6, 0x26, 0x00},
+	{0x60b7, 0xb0, 0x00},
+	{0x60b8, 0xb7, 0x00},
+	{0x60b9, 0x00, 0x00},
+	{0x60ba, 0xd3, 0x00},
+	{0x60bb, 0x0a, 0x00},
+	{0x60bc, 0xd3, 0x00},
+	{0x60bd, 0x10, 0x00},
+	{0x60be, 0x9c, 0x00},
+	{0x60bf, 0x94, 0x00},
+	{0x60c0, 0x90, 0x00},
+	{0x60c1, 0xc8, 0x00},
+	{0x60c2, 0xba, 0x00},
+	{0x60c3, 0x7c, 0x00},
+	{0x60c4, 0x74, 0x00},
+	{0x60c5, 0x00, 0x00},
+	{0x60c6, 0x61, 0x00},
+	{0x60c7, 0x2a, 0x00},
+	{0x60c8, 0x00, 0x00},
+	{0x60c9, 0xd2, 0x00},
+	{0x60ca, 0xcc, 0x00},
+	{0x60cb, 0xdf, 0x00},
+	{0x60cc, 0xc4, 0x00},
+	{0x60cd, 0x35, 0x00},
+	{0x60ce, 0xd2, 0x00},
+	{0x60cf, 0xcc, 0x00},
+	{0x60d0, 0x06, 0x00},
+	{0x60d1, 0x31, 0x00},
+	{0x60d2, 0xd2, 0x00},
+	{0x60d3, 0xcc, 0x00},
+	{0x60d4, 0x15, 0x00},
+	{0x60d5, 0xd2, 0x00},
+	{0x60d6, 0xbb, 0x00},
+	{0x60d7, 0xcc, 0x00},
+	{0x60d8, 0x1a, 0x00},
+	{0x60d9, 0xd2, 0x00},
+	{0x60da, 0xbe, 0x00},
+	{0x60db, 0xce, 0x00},
+	{0x60dc, 0x52, 0x00},
+	{0x60dd, 0xcf, 0x00},
+	{0x60de, 0x56, 0x00},
+	{0x60df, 0xd0, 0x00},
+	{0x60e0, 0x5b, 0x00},
+	{0x60e1, 0x2b, 0x00},
+	{0x60e2, 0xd2, 0x00},
+	{0x60e3, 0xd3, 0x00},
+	{0x60e4, 0x01, 0x00},
+	{0x60e5, 0xcc, 0x00},
+	{0x60e6, 0x0a, 0x00},
+	{0x60e7, 0xd2, 0x00},
+	{0x60e8, 0xd3, 0x00},
+	{0x60e9, 0x0f, 0x00},
+	{0x60ea, 0xd9, 0x00},
+	{0x60eb, 0xc7, 0x00},
+	{0x60ec, 0xda, 0x00},
+	{0x60ed, 0xce, 0x00},
+	{0x60ee, 0x1a, 0x00},
+	{0x60ef, 0xd4, 0x00},
+	{0x60f0, 0xf6, 0x00},
+	{0x60f1, 0xd4, 0x00},
+	{0x60f2, 0xa9, 0x00},
+	{0x60f3, 0x27, 0x00},
+	{0x60f4, 0x00, 0x00},
+	{0x60f5, 0xd2, 0x00},
+	{0x60f6, 0xcc, 0x00},
+	{0x60f7, 0x60, 0x00},
+	{0x60f8, 0xd2, 0x00},
+	{0x60f9, 0xd3, 0x00},
+	{0x60fa, 0x2d, 0x00},
+	{0x60fb, 0xd9, 0x00},
+	{0x60fc, 0xdf, 0x00},
+	{0x60fd, 0xda, 0x00},
+	{0x60fe, 0xe5, 0x00},
+	{0x60ff, 0x1a, 0x00},
+	{0x6100, 0x12, 0x00},
+	{0x6101, 0xcc, 0x00},
+	{0x6102, 0x88, 0x00},
+	{0x6103, 0xd6, 0x00},
+	{0x6104, 0xb1, 0x00},
+	{0x6105, 0xb9, 0x00},
+	{0x6106, 0xba, 0x00},
+	{0x6107, 0xaf, 0x00},
+	{0x6108, 0xdc, 0x00},
+	{0x6109, 0x00, 0x00},
+	{0x610a, 0xcb, 0x00},
+	{0x610b, 0xc3, 0x00},
+	{0x610c, 0xb9, 0x00},
+	{0x610d, 0xa4, 0x00},
+	{0x610e, 0xb5, 0x00},
+	{0x610f, 0x5c, 0x00},
+	{0x6110, 0x12, 0x00},
+	{0x6111, 0x2a, 0x00},
+	{0x6112, 0x61, 0x00},
+	{0x6113, 0xd2, 0x00},
+	{0x6114, 0xcc, 0x00},
+	{0x6115, 0xdf, 0x00},
+	{0x6116, 0xc7, 0x00},
+	{0x6117, 0x35, 0x00},
+	{0x6118, 0xd2, 0x00},
+	{0x6119, 0xcc, 0x00},
+	{0x611a, 0x06, 0x00},
+	{0x611b, 0x31, 0x00},
+	{0x611c, 0xc6, 0x00},
+	{0x611d, 0xbb, 0x00},
+	{0x611e, 0xd2, 0x00},
+	{0x611f, 0xcc, 0x00},
+	{0x6120, 0x18, 0x00},
+	{0x6121, 0xd2, 0x00},
+	{0x6122, 0xbe, 0x00},
+	{0x6123, 0xcc, 0x00},
+	{0x6124, 0x52, 0x00},
+	{0x6125, 0xc7, 0x00},
+	{0x6126, 0xd2, 0x00},
+	{0x6127, 0xcc, 0x00},
+	{0x6128, 0x0a, 0x00},
+	{0x6129, 0xb4, 0x00},
+	{0x612a, 0xb7, 0x00},
+	{0x612b, 0x94, 0x00},
+	{0x612c, 0xd2, 0x00},
+	{0x612d, 0x12, 0x00},
+	{0x612e, 0x26, 0x00},
+	{0x612f, 0x42, 0x00},
+	{0x6130, 0x46, 0x00},
+	{0x6131, 0x42, 0x00},
+	{0x6132, 0xd3, 0x00},
+	{0x6133, 0x20, 0x00},
+	{0x6134, 0x27, 0x00},
+	{0x6135, 0x00, 0x00},
+	{0x6136, 0x1a, 0x00},
+	{0x6137, 0xcc, 0x00},
+	{0x6138, 0x88, 0x00},
+	{0x6139, 0x60, 0x00},
+	{0x613a, 0x2c, 0x00},
+	{0x613b, 0x12, 0x00},
+	{0x613c, 0x40, 0x00},
+	{0x613d, 0xb8, 0x00},
+	{0x613e, 0x90, 0x00},
+	{0x613f, 0xd5, 0x00},
+	{0x6140, 0xba, 0x00},
+	{0x6141, 0x00, 0x00},
+	{0x6142, 0x00, 0x00},
+	{0x6143, 0x00, 0x00},
+	{0x6144, 0x00, 0x00},
+	{0x6145, 0x00, 0x00},
+	{0x6146, 0x00, 0x00},
+	{0x6147, 0xaa, 0x00},
+	{0x6148, 0xb7, 0x00},
+	{0x6149, 0x00, 0x00},
+	{0x614a, 0x00, 0x00},
+	{0x614b, 0x00, 0x00},
+	{0x614c, 0x00, 0x00},
+	{0x614d, 0xa6, 0x00},
+	{0x614e, 0xb7, 0x00},
+	{0x614f, 0x00, 0x00},
+	{0x6150, 0xd5, 0x00},
+	{0x6151, 0x00, 0x00},
+	{0x6152, 0x71, 0x00},
+	{0x6153, 0xd3, 0x00},
+	{0x6154, 0x30, 0x00},
+	{0x6155, 0xba, 0x00},
+	{0x6156, 0x00, 0x00},
+	{0x6157, 0x00, 0x00},
+	{0x6158, 0x00, 0x00},
+	{0x6159, 0x00, 0x00},
+	{0x615a, 0xd3, 0x00},
+	{0x615b, 0x10, 0x00},
+	{0x615c, 0x70, 0x00},
+	{0x615d, 0x00, 0x00},
+	{0x615e, 0x00, 0x00},
+	{0x615f, 0x00, 0x00},
+	{0x6160, 0x00, 0x00},
+	{0x6161, 0xd5, 0x00},
+	{0x6162, 0xba, 0x00},
+	{0x6163, 0xb0, 0x00},
+	{0x6164, 0xb7, 0x00},
+	{0x6165, 0x00, 0x00},
+	{0x6166, 0x9d, 0x00},
+	{0x6167, 0xd3, 0x00},
+	{0x6168, 0x0a, 0x00},
+	{0x6169, 0x9d, 0x00},
+	{0x616a, 0x9d, 0x00},
+	{0x616b, 0xd3, 0x00},
+	{0x616c, 0x10, 0x00},
+	{0x616d, 0x9c, 0x00},
+	{0x616e, 0x94, 0x00},
+	{0x616f, 0x90, 0x00},
+	{0x6170, 0xc8, 0x00},
+	{0x6171, 0xba, 0x00},
+	{0x6172, 0xd2, 0x00},
+	{0x6173, 0x60, 0x00},
+	{0x6174, 0x2c, 0x00},
+	{0x6175, 0x50, 0x00},
+	{0x6176, 0x11, 0x00},
+	{0x6177, 0xcc, 0x00},
+	{0x6178, 0x00, 0x00},
+	{0x6179, 0x30, 0x00},
+	{0x617a, 0xd5, 0x00},
+	{0x617b, 0x00, 0x00},
+	{0x617c, 0xba, 0x00},
+	{0x617d, 0xb0, 0x00},
+	{0x617e, 0xb7, 0x00},
+	{0x617f, 0x00, 0x00},
+	{0x6180, 0x9d, 0x00},
+	{0x6181, 0xd3, 0x00},
+	{0x6182, 0x0a, 0x00},
+	{0x6183, 0x9d, 0x00},
+	{0x6184, 0x9d, 0x00},
+	{0x6185, 0xd3, 0x00},
+	{0x6186, 0x10, 0x00},
+	{0x6187, 0x9c, 0x00},
+	{0x6188, 0x94, 0x00},
+	{0x6189, 0x90, 0x00},
+	{0x618a, 0xc8, 0x00},
+	{0x618b, 0xba, 0x00},
+	{0x618c, 0xd5, 0x00},
+	{0x618d, 0x00, 0x00},
+	{0x618e, 0x01, 0x00},
+	{0x618f, 0x1a, 0x00},
+	{0x6190, 0xcc, 0x00},
+	{0x6191, 0x12, 0x00},
+	{0x6192, 0x12, 0x00},
+	{0x6193, 0x00, 0x00},
+	{0x6194, 0xcc, 0x00},
+	{0x6195, 0x9c, 0x00},
+	{0x6196, 0xd2, 0x00},
+	{0x6197, 0xcc, 0x00},
+	{0x6198, 0x60, 0x00},
+	{0x6199, 0xd2, 0x00},
+	{0x619a, 0x04, 0x00},
+	{0x619b, 0xd5, 0x00},
+	{0x619c, 0x1a, 0x00},
+	{0x619d, 0xcc, 0x00},
+	{0x619e, 0x12, 0x00},
+	{0x619f, 0x00, 0x00},
+	{0x61a0, 0x12, 0x00},
+	{0x61a1, 0xcc, 0x00},
+	{0x61a2, 0x9c, 0x00},
+	{0x61a3, 0xd2, 0x00},
+	{0x61a4, 0xcc, 0x00},
+	{0x61a5, 0x60, 0x00},
+	{0x61a6, 0xd2, 0x00},
+	{0x61a7, 0x1a, 0x00},
+	{0x61a8, 0xcc, 0x00},
+	{0x61a9, 0x12, 0x00},
+	{0x61aa, 0x00, 0x00},
+	{0x61ab, 0x12, 0x00},
+	{0x61ac, 0xcc, 0x00},
+	{0x61ad, 0x9c, 0x00},
+	{0x61ae, 0xd2, 0x00},
+	{0x61af, 0xcc, 0x00},
+	{0x61b0, 0x60, 0x00},
+	{0x61b1, 0xd2, 0x00},
+	{0x61b2, 0x1a, 0x00},
+	{0x61b3, 0xcc, 0x00},
+	{0x61b4, 0x12, 0x00},
+	{0x61b5, 0x00, 0x00},
+	{0x61b6, 0x12, 0x00},
+	{0x61b7, 0xcc, 0x00},
+	{0x61b8, 0x9c, 0x00},
+	{0x61b9, 0xd2, 0x00},
+	{0x61ba, 0xcc, 0x00},
+	{0x61bb, 0x60, 0x00},
+	{0x61bc, 0xd2, 0x00},
+	{0x61bd, 0xd5, 0x00},
+	{0x61be, 0x1a, 0x00},
+	{0x61bf, 0xcc, 0x00},
+	{0x61c0, 0x12, 0x00},
+	{0x61c1, 0x12, 0x00},
+	{0x61c2, 0x00, 0x00},
+	{0x61c3, 0xcc, 0x00},
+	{0x61c4, 0x8a, 0x00},
+	{0x61c5, 0xd2, 0x00},
+	{0x61c6, 0xcc, 0x00},
+	{0x61c7, 0x74, 0x00},
+	{0x61c8, 0xd2, 0x00},
+	{0x61c9, 0xd5, 0x00},
+	{0x61ca, 0x1a, 0x00},
+	{0x61cb, 0xcc, 0x00},
+	{0x61cc, 0x12, 0x00},
+	{0x61cd, 0x00, 0x00},
+	{0x61ce, 0x12, 0x00},
+	{0x61cf, 0xcc, 0x00},
+	{0x61d0, 0x8a, 0x00},
+	{0x61d1, 0xd2, 0x00},
+	{0x61d2, 0xcc, 0x00},
+	{0x61d3, 0x74, 0x00},
+	{0x61d4, 0xd2, 0x00},
+	{0x61d5, 0x1a, 0x00},
+	{0x61d6, 0xcc, 0x00},
+	{0x61d7, 0x12, 0x00},
+	{0x61d8, 0x00, 0x00},
+	{0x61d9, 0x12, 0x00},
+	{0x61da, 0xcc, 0x00},
+	{0x61db, 0x8a, 0x00},
+	{0x61dc, 0xd2, 0x00},
+	{0x61dd, 0xcc, 0x00},
+	{0x61de, 0x74, 0x00},
+	{0x61df, 0xd2, 0x00},
+	{0x61e0, 0x1a, 0x00},
+	{0x61e1, 0xcc, 0x00},
+	{0x61e2, 0x12, 0x00},
+	{0x61e3, 0x00, 0x00},
+	{0x61e4, 0x12, 0x00},
+	{0x61e5, 0xcc, 0x00},
+	{0x61e6, 0x8a, 0x00},
+	{0x61e7, 0xd2, 0x00},
+	{0x61e8, 0xcc, 0x00},
+	{0x61e9, 0x74, 0x00},
+	{0x61ea, 0xd2, 0x00},
+	{0x61eb, 0xd5, 0x00},
+	{0x61ec, 0xcc, 0x00},
+	{0x61ed, 0x12, 0x00},
+	{0x61ee, 0x00, 0x00},
+	{0x61ef, 0x12, 0x00},
+	{0x61f0, 0xcc, 0x00},
+	{0x61f1, 0x9c, 0x00},
+	{0x61f2, 0xd5, 0x00},
+	{0x6400, 0x04, 0x00},
+	{0x6401, 0x04, 0x00},
+	{0x6402, 0x00, 0x00},
+	{0x6403, 0xff, 0x00},
+	{0x6404, 0x00, 0x00},
+	{0x6405, 0x08, 0x00},
+	{0x6406, 0x00, 0x00},
+	{0x6407, 0xff, 0x00},
+	{0x6408, 0x04, 0x00},
+	{0x6409, 0x70, 0x00},
+	{0x640a, 0x00, 0x00},
+	{0x640b, 0xff, 0x00},
+	{0x640c, 0x05, 0x00},
+	{0x640d, 0x14, 0x00},
+	{0x640e, 0x04, 0x00},
+	{0x640f, 0x71, 0x00},
+	{0x6410, 0x05, 0x00},
+	{0x6411, 0x74, 0x00},
+	{0x6412, 0x00, 0x00},
+	{0x6413, 0xff, 0x00},
+	{0x6414, 0x05, 0x00},
+	{0x6415, 0x54, 0x00},
+	{0x6416, 0x05, 0x00},
+	{0x6417, 0x44, 0x00},
+	{0x6418, 0x04, 0x00},
+	{0x6419, 0x30, 0x00},
+	{0x641a, 0x05, 0x00},
+	{0x641b, 0x46, 0x00},
+	{0x641c, 0x00, 0x00},
+	{0x641d, 0xff, 0x00},
+	{0x641e, 0x04, 0x00},
+	{0x641f, 0x31, 0x00},
+	{0x6420, 0x04, 0x00},
+	{0x6421, 0x30, 0x00},
+	{0x6422, 0x00, 0x00},
+	{0x6423, 0xff, 0x00},
+	{0x6424, 0x04, 0x00},
+	{0x6425, 0x20, 0x00},
+	{0x6426, 0x05, 0x00},
+	{0x6427, 0x06, 0x00},
+	{0x6428, 0x00, 0x00},
+	{0x6429, 0xff, 0x00},
+	{0x642a, 0x08, 0x00},
+	{0x642b, 0x2a, 0x00},
+	{0x642c, 0x08, 0x00},
+	{0x642d, 0x31, 0x00},
+	{0x642e, 0x00, 0x00},
+	{0x642f, 0xff, 0x00},
+	{0x6430, 0x08, 0x00},
+	{0x6431, 0x2a, 0x00},
+	{0x6432, 0x08, 0x00},
+	{0x6433, 0x31, 0x00},
+	{0x6434, 0x06, 0x00},
+	{0x6435, 0x20, 0x00},
+	{0x6436, 0x07, 0x00},
+	{0x6437, 0x00, 0x00},
+	{0x6438, 0x08, 0x00},
+	{0x6439, 0x40, 0x00},
+	{0x643a, 0x00, 0x00},
+	{0x643b, 0xff, 0x00},
+	{0x643c, 0x08, 0x00},
+	{0x643d, 0x2a, 0x00},
+	{0x643e, 0x08, 0x00},
+	{0x643f, 0x36, 0x00},
+	{0x6440, 0x06, 0x00},
+	{0x6441, 0x10, 0x00},
+	{0x6442, 0x07, 0x00},
+	{0x6443, 0x00, 0x00},
+	{0x6444, 0x08, 0x00},
+	{0x6445, 0x40, 0x00},
+	{0x6446, 0x00, 0x00},
+	{0x6447, 0xff, 0x00},
+	{0x6448, 0x08, 0x00},
+	{0x6449, 0x2a, 0x00},
+	{0x644a, 0x08, 0x00},
+	{0x644b, 0x3b, 0x00},
+	{0x644c, 0x06, 0x00},
+	{0x644d, 0x00, 0x00},
+	{0x644e, 0x07, 0x00},
+	{0x644f, 0x00, 0x00},
+	{0x6450, 0x08, 0x00},
+	{0x6451, 0x40, 0x00},
+	{0x6452, 0x00, 0x00},
+	{0x6453, 0xff, 0x00},
+	{0x6454, 0x06, 0x00},
+	{0x6455, 0x00, 0x00},
+	{0x6456, 0x07, 0x00},
+	{0x6457, 0x05, 0x00},
+	{0x6458, 0x01, 0x00},
+	{0x6459, 0xaf, 0x00},
+	{0x645a, 0x01, 0x00},
+	{0x645b, 0x0f, 0x00},
+	{0x645c, 0x01, 0x00},
+	{0x645d, 0x90, 0x00},
+	{0x645e, 0x01, 0x00},
+	{0x645f, 0xc8, 0x00},
+	{0x6460, 0x00, 0x00},
+	{0x6461, 0xff, 0x00},
+	{0x6462, 0x01, 0x00},
+	{0x6463, 0xac, 0x00},
+	{0x6464, 0x01, 0x00},
+	{0x6465, 0x0c, 0x00},
+	{0x6466, 0x01, 0x00},
+	{0x6467, 0x90, 0x00},
+	{0x6468, 0x01, 0x00},
+	{0x6469, 0xe8, 0x00},
+	{0x646a, 0x00, 0x00},
+	{0x646b, 0xff, 0x00},
+	{0x646c, 0x01, 0x00},
+	{0x646d, 0xad, 0x00},
+	{0x646e, 0x01, 0x00},
+	{0x646f, 0x0d, 0x00},
+	{0x6470, 0x01, 0x00},
+	{0x6471, 0x90, 0x00},
+	{0x6472, 0x01, 0x00},
+	{0x6473, 0xe8, 0x00},
+	{0x6474, 0x00, 0x00},
+	{0x6475, 0xff, 0x00},
+	{0x6476, 0x01, 0x00},
+	{0x6477, 0xae, 0x00},
+	{0x6478, 0x01, 0x00},
+	{0x6479, 0x0e, 0x00},
+	{0x647a, 0x01, 0x00},
+	{0x647b, 0x90, 0x00},
+	{0x647c, 0x01, 0x00},
+	{0x647d, 0xe8, 0x00},
+	{0x647e, 0x00, 0x00},
+	{0x647f, 0xff, 0x00},
+	{0x6480, 0x01, 0x00},
+	{0x6481, 0xb0, 0x00},
+	{0x6482, 0x01, 0x00},
+	{0x6483, 0xb1, 0x00},
+	{0x6484, 0x01, 0x00},
+	{0x6485, 0xb2, 0x00},
+	{0x6486, 0x01, 0x00},
+	{0x6487, 0xb3, 0x00},
+	{0x6488, 0x01, 0x00},
+	{0x6489, 0xb4, 0x00},
+	{0x648a, 0x01, 0x00},
+	{0x648b, 0xb5, 0x00},
+	{0x648c, 0x01, 0x00},
+	{0x648d, 0xb6, 0x00},
+	{0x648e, 0x01, 0x00},
+	{0x648f, 0xb7, 0x00},
+	{0x6490, 0x01, 0x00},
+	{0x6491, 0xb8, 0x00},
+	{0x6492, 0x01, 0x00},
+	{0x6493, 0xb9, 0x00},
+	{0x6494, 0x01, 0x00},
+	{0x6495, 0xba, 0x00},
+	{0x6496, 0x01, 0x00},
+	{0x6497, 0xbb, 0x00},
+	{0x6498, 0x01, 0x00},
+	{0x6499, 0xbc, 0x00},
+	{0x649a, 0x01, 0x00},
+	{0x649b, 0xbd, 0x00},
+	{0x649c, 0x01, 0x00},
+	{0x649d, 0xbe, 0x00},
+	{0x649e, 0x01, 0x00},
+	{0x649f, 0xbf, 0x00},
+	{0x64a0, 0x01, 0x00},
+	{0x64a1, 0xc0, 0x00},
+	{0x64a2, 0x00, 0x00},
+	{0x64a3, 0xff, 0x00},
+	{0x64a4, 0x06, 0x00},
+	{0x64a5, 0x00, 0x00},
+	{0x64a6, 0x01, 0x00},
+	{0x64a7, 0xf6, 0x00},
+	{0x64a8, 0x04, 0x00},
+	{0x64a9, 0x30, 0x00},
+	{0x64aa, 0x00, 0x00},
+	{0x64ab, 0xff, 0x00},
+	{0x64ac, 0x06, 0x00},
+	{0x64ad, 0x10, 0x00},
+	{0x64ae, 0x01, 0x00},
+	{0x64af, 0xf6, 0x00},
+	{0x64b0, 0x04, 0x00},
+	{0x64b1, 0x30, 0x00},
+	{0x64b2, 0x06, 0x00},
+	{0x64b3, 0x00, 0x00},
+	{0x64b4, 0x00, 0x00},
+	{0x64b5, 0xff, 0x00},
+	{0x64b6, 0x06, 0x00},
+	{0x64b7, 0x20, 0x00},
+	{0x64b8, 0x01, 0x00},
+	{0x64b9, 0xf6, 0x00},
+	{0x64ba, 0x04, 0x00},
+	{0x64bb, 0x30, 0x00},
+	{0x64bc, 0x06, 0x00},
+	{0x64bd, 0x00, 0x00},
+	{0x64be, 0x00, 0x00},
+	{0x64bf, 0xff, 0x00},
+	{0x64c0, 0x04, 0x00},
+	{0x64c1, 0x31, 0x00},
+	{0x64c2, 0x04, 0x00},
+	{0x64c3, 0x30, 0x00},
+	{0x64c4, 0x01, 0x00},
+	{0x64c5, 0x20, 0x00},
+	{0x64c6, 0x01, 0x00},
+	{0x64c7, 0x31, 0x00},
+	{0x64c8, 0x01, 0x00},
+	{0x64c9, 0x32, 0x00},
+	{0x64ca, 0x01, 0x00},
+	{0x64cb, 0x33, 0x00},
+	{0x64cc, 0x01, 0x00},
+	{0x64cd, 0x34, 0x00},
+	{0x64ce, 0x01, 0x00},
+	{0x64cf, 0x35, 0x00},
+	{0x64d0, 0x01, 0x00},
+	{0x64d1, 0x36, 0x00},
+	{0x64d2, 0x01, 0x00},
+	{0x64d3, 0x37, 0x00},
+	{0x64d4, 0x01, 0x00},
+	{0x64d5, 0x38, 0x00},
+	{0x64d6, 0x01, 0x00},
+	{0x64d7, 0x39, 0x00},
+	{0x64d8, 0x01, 0x00},
+	{0x64d9, 0x3a, 0x00},
+	{0x64da, 0x01, 0x00},
+	{0x64db, 0x3b, 0x00},
+	{0x64dc, 0x01, 0x00},
+	{0x64dd, 0x3c, 0x00},
+	{0x64de, 0x01, 0x00},
+	{0x64df, 0x3d, 0x00},
+	{0x64e0, 0x01, 0x00},
+	{0x64e1, 0x3e, 0x00},
+	{0x64e2, 0x01, 0x00},
+	{0x64e3, 0x3f, 0x00},
+	{0x64e4, 0x02, 0x00},
+	{0x64e5, 0xa0, 0x00},
+	{0x64e6, 0x00, 0x00},
+	{0x64e7, 0xff, 0x00},
+	{0x64e8, 0x04, 0x00},
+	{0x64e9, 0x31, 0x00},
+	{0x64ea, 0x04, 0x00},
+	{0x64eb, 0x30, 0x00},
+	{0x64ec, 0x01, 0x00},
+	{0x64ed, 0x00, 0x00},
+	{0x64ee, 0x01, 0x00},
+	{0x64ef, 0x11, 0x00},
+	{0x64f0, 0x01, 0x00},
+	{0x64f1, 0x12, 0x00},
+	{0x64f2, 0x01, 0x00},
+	{0x64f3, 0x13, 0x00},
+	{0x64f4, 0x01, 0x00},
+	{0x64f5, 0x14, 0x00},
+	{0x64f6, 0x01, 0x00},
+	{0x64f7, 0x15, 0x00},
+	{0x64f8, 0x01, 0x00},
+	{0x64f9, 0x16, 0x00},
+	{0x64fa, 0x01, 0x00},
+	{0x64fb, 0x17, 0x00},
+	{0x64fc, 0x01, 0x00},
+	{0x64fd, 0x18, 0x00},
+	{0x64fe, 0x01, 0x00},
+	{0x64ff, 0x19, 0x00},
+	{0x6500, 0x01, 0x00},
+	{0x6501, 0x1a, 0x00},
+	{0x6502, 0x01, 0x00},
+	{0x6503, 0x1b, 0x00},
+	{0x6504, 0x01, 0x00},
+	{0x6505, 0x1c, 0x00},
+	{0x6506, 0x01, 0x00},
+	{0x6507, 0x1d, 0x00},
+	{0x6508, 0x01, 0x00},
+	{0x6509, 0x1e, 0x00},
+	{0x650a, 0x01, 0x00},
+	{0x650b, 0x1f, 0x00},
+	{0x650c, 0x02, 0x00},
+	{0x650d, 0xa0, 0x00},
+	{0x650e, 0x00, 0x00},
+	{0x650f, 0xff, 0x00},
+	{0x6510, 0x04, 0x00},
+	{0x6511, 0x20, 0x00},
+	{0x6512, 0x05, 0x00},
+	{0x6513, 0x86, 0x00},
+	{0x6514, 0x03, 0x00},
+	{0x6515, 0x0b, 0x00},
+	{0x6516, 0x05, 0x00},
+	{0x6517, 0x86, 0x00},
+	{0x6518, 0x00, 0x00},
+	{0x6519, 0x00, 0x00},
+	{0x651a, 0x05, 0x00},
+	{0x651b, 0x06, 0x00},
+	{0x651c, 0x00, 0x00},
+	{0x651d, 0x04, 0x00},
+	{0x651e, 0x05, 0x00},
+	{0x651f, 0x04, 0x00},
+	{0x6520, 0x00, 0x00},
+	{0x6521, 0x04, 0x00},
+	{0x6522, 0x05, 0x00},
+	{0x6523, 0x00, 0x00},
+	{0x6524, 0x05, 0x00},
+	{0x6525, 0x0a, 0x00},
+	{0x6526, 0x03, 0x00},
+	{0x6527, 0x9a, 0x00},
+	{0x6528, 0x05, 0x00},
+	{0x6529, 0x86, 0x00},
+	{0x652a, 0x00, 0x00},
+	{0x652b, 0x00, 0x00},
+	{0x652c, 0x05, 0x00},
+	{0x652d, 0x06, 0x00},
+	{0x652e, 0x00, 0x00},
+	{0x652f, 0x01, 0x00},
+	{0x6530, 0x05, 0x00},
+	{0x6531, 0x04, 0x00},
+	{0x6532, 0x00, 0x00},
+	{0x6533, 0x04, 0x00},
+	{0x6534, 0x05, 0x00},
+	{0x6535, 0x00, 0x00},
+	{0x6536, 0x05, 0x00},
+	{0x6537, 0x0a, 0x00},
+	{0x6538, 0x03, 0x00},
+	{0x6539, 0x99, 0x00},
+	{0x653a, 0x05, 0x00},
+	{0x653b, 0x06, 0x00},
+	{0x653c, 0x00, 0x00},
+	{0x653d, 0x00, 0x00},
+	{0x653e, 0x05, 0x00},
+	{0x653f, 0x04, 0x00},
+	{0x6540, 0x00, 0x00},
+	{0x6541, 0x04, 0x00},
+	{0x6542, 0x05, 0x00},
+	{0x6543, 0x00, 0x00},
+	{0x6544, 0x05, 0x00},
+	{0x6545, 0x0a, 0x00},
+	{0x6546, 0x03, 0x00},
+	{0x6547, 0x98, 0x00},
+	{0x6548, 0x05, 0x00},
+	{0x6549, 0x06, 0x00},
+	{0x654a, 0x00, 0x00},
+	{0x654b, 0x00, 0x00},
+	{0x654c, 0x05, 0x00},
+	{0x654d, 0x04, 0x00},
+	{0x654e, 0x00, 0x00},
+	{0x654f, 0x04, 0x00},
+	{0x6550, 0x05, 0x00},
+	{0x6551, 0x00, 0x00},
+	{0x6552, 0x05, 0x00},
+	{0x6553, 0x0a, 0x00},
+	{0x6554, 0x03, 0x00},
+	{0x6555, 0x97, 0x00},
+	{0x6556, 0x05, 0x00},
+	{0x6557, 0x06, 0x00},
+	{0x6558, 0x05, 0x00},
+	{0x6559, 0x04, 0x00},
+	{0x655a, 0x00, 0x00},
+	{0x655b, 0x04, 0x00},
+	{0x655c, 0x05, 0x00},
+	{0x655d, 0x00, 0x00},
+	{0x655e, 0x05, 0x00},
+	{0x655f, 0x0a, 0x00},
+	{0x6560, 0x03, 0x00},
+	{0x6561, 0x96, 0x00},
+	{0x6562, 0x05, 0x00},
+	{0x6563, 0x06, 0x00},
+	{0x6564, 0x05, 0x00},
+	{0x6565, 0x04, 0x00},
+	{0x6566, 0x00, 0x00},
+	{0x6567, 0x04, 0x00},
+	{0x6568, 0x05, 0x00},
+	{0x6569, 0x00, 0x00},
+	{0x656a, 0x05, 0x00},
+	{0x656b, 0x0a, 0x00},
+	{0x656c, 0x03, 0x00},
+	{0x656d, 0x95, 0x00},
+	{0x656e, 0x05, 0x00},
+	{0x656f, 0x06, 0x00},
+	{0x6570, 0x05, 0x00},
+	{0x6571, 0x04, 0x00},
+	{0x6572, 0x00, 0x00},
+	{0x6573, 0x04, 0x00},
+	{0x6574, 0x05, 0x00},
+	{0x6575, 0x00, 0x00},
+	{0x6576, 0x05, 0x00},
+	{0x6577, 0x0a, 0x00},
+	{0x6578, 0x03, 0x00},
+	{0x6579, 0x94, 0x00},
+	{0x657a, 0x05, 0x00},
+	{0x657b, 0x06, 0x00},
+	{0x657c, 0x00, 0x00},
+	{0x657d, 0x00, 0x00},
+	{0x657e, 0x05, 0x00},
+	{0x657f, 0x04, 0x00},
+	{0x6580, 0x00, 0x00},
+	{0x6581, 0x04, 0x00},
+	{0x6582, 0x05, 0x00},
+	{0x6583, 0x00, 0x00},
+	{0x6584, 0x05, 0x00},
+	{0x6585, 0x0a, 0x00},
+	{0x6586, 0x03, 0x00},
+	{0x6587, 0x93, 0x00},
+	{0x6588, 0x05, 0x00},
+	{0x6589, 0x06, 0x00},
+	{0x658a, 0x00, 0x00},
+	{0x658b, 0x00, 0x00},
+	{0x658c, 0x05, 0x00},
+	{0x658d, 0x04, 0x00},
+	{0x658e, 0x00, 0x00},
+	{0x658f, 0x04, 0x00},
+	{0x6590, 0x05, 0x00},
+	{0x6591, 0x00, 0x00},
+	{0x6592, 0x05, 0x00},
+	{0x6593, 0x0a, 0x00},
+	{0x6594, 0x03, 0x00},
+	{0x6595, 0x92, 0x00},
+	{0x6596, 0x05, 0x00},
+	{0x6597, 0x06, 0x00},
+	{0x6598, 0x05, 0x00},
+	{0x6599, 0x04, 0x00},
+	{0x659a, 0x00, 0x00},
+	{0x659b, 0x04, 0x00},
+	{0x659c, 0x05, 0x00},
+	{0x659d, 0x00, 0x00},
+	{0x659e, 0x05, 0x00},
+	{0x659f, 0x0a, 0x00},
+	{0x65a0, 0x03, 0x00},
+	{0x65a1, 0x91, 0x00},
+	{0x65a2, 0x05, 0x00},
+	{0x65a3, 0x06, 0x00},
+	{0x65a4, 0x05, 0x00},
+	{0x65a5, 0x04, 0x00},
+	{0x65a6, 0x00, 0x00},
+	{0x65a7, 0x04, 0x00},
+	{0x65a8, 0x05, 0x00},
+	{0x65a9, 0x00, 0x00},
+	{0x65aa, 0x05, 0x00},
+	{0x65ab, 0x0a, 0x00},
+	{0x65ac, 0x03, 0x00},
+	{0x65ad, 0x90, 0x00},
+	{0x65ae, 0x05, 0x00},
+	{0x65af, 0x06, 0x00},
+	{0x65b0, 0x05, 0x00},
+	{0x65b1, 0x04, 0x00},
+	{0x65b2, 0x00, 0x00},
+	{0x65b3, 0x04, 0x00},
+	{0x65b4, 0x05, 0x00},
+	{0x65b5, 0x00, 0x00},
+	{0x65b6, 0x05, 0x00},
+	{0x65b7, 0x0a, 0x00},
+	{0x65b8, 0x02, 0x00},
+	{0x65b9, 0x90, 0x00},
+	{0x65ba, 0x05, 0x00},
+	{0x65bb, 0x06, 0x00},
+	{0x65bc, 0x00, 0x00},
+	{0x65bd, 0xff, 0x00},
+	{0x65be, 0x04, 0x00},
+	{0x65bf, 0x70, 0x00},
+	{0x65c0, 0x08, 0x00},
+	{0x65c1, 0x76, 0x00},
+	{0x65c2, 0x00, 0x00},
+	{0x65c3, 0xff, 0x00},
+	{0x65c4, 0x08, 0x00},
+	{0x65c5, 0x76, 0x00},
+	{0x65c6, 0x04, 0x00},
+	{0x65c7, 0x0c, 0x00},
+	{0x65c8, 0x05, 0x00},
+	{0x65c9, 0x07, 0x00},
+	{0x65ca, 0x04, 0x00},
+	{0x65cb, 0x04, 0x00},
+	{0x65cc, 0x00, 0x00},
+	{0x65cd, 0xff, 0x00},
+	{0x65ce, 0x00, 0x00},
+	{0x65cf, 0xff, 0x00},
+	{0x65d0, 0x00, 0x00},
+	{0x65d1, 0xff, 0x00},
+	{0x3037, 0x71, 0x00},
+	{0x303a, 0x04, 0x00},
+	{0x303b, 0x7f, 0x00},
+	{0x303c, 0xfe, 0x00},
+	{0x303d, 0x19, 0x00},
+	{0x303e, 0xd7, 0x00},
+	{0x303f, 0x09, 0x00},
+	{0x3040, 0x78, 0x00},
+	{0x3042, 0x05, 0x00},
+	{0x328a, 0x10, 0x00},
+	{0x328a, 0x00, 0x00},
+	{0x31be, 0x03, 0x00},
+	{0x31bf, 0x9f, 0x00},
+	{0x31c0, 0xff, 0x00},
+	{0x3133, 0xb7, 0x00},
+	{0x3134, 0xca, 0x00},
+	{0x3135, 0xcc, 0x00},
+	{0x3012, 0x01, 0x00},
+	{0x3012, 0x00, 0x00},
+	{0x3000, 0x03, 0x00},
+	{0x3001, 0x49, 0x00},
+	{0x3002, 0x07, 0x00},
+	{0x3004, 0x03, 0x00},
+	{0x3005, 0x44, 0x00},
+	{0x3006, 0x07, 0x00},
+	{0x308f, 0x10, 0x00},
+	{0x3127, 0x63, 0x00},
+	{0x3074, 0x00, 0x00},
+	{0x3075, 0x00, 0x00},
+	{0x3076, 0x00, 0x00},
+/*{0x3077, 0xB6 , 0x00},    */
+	{0x3077, 0x02, 0x00},
+	{0x3078, 0x05, 0x00},
+	{0x3079, 0x07, 0x00},
+	{0x307a, 0x04, 0x00},
+	{0x307b, 0x41, 0x00},
+	{0x307c, 0x05, 0x00},
+	{0x307d, 0x00, 0x00},
+	{0x307e, 0x04, 0x00},
+	{0x307f, 0x38, 0x00},
+	{0x3080, 0x05, 0x00},
+	{0x3081, 0xc8, 0x00},
+	{0x3082, 0x06, 0x00},
+	{0x3083, 0x82, 0x00},
+	{0x3084, 0x00, 0x00},
+	{0x3085, 0x04, 0x00},
+	{0x3086, 0x00, 0x00},
+	{0x3087, 0x04, 0x00},
+	{0x346d, 0x1D, 0x00},
+	{0x3444, 0x48, 0x00},
+	/* hdr mode */
+	/* /\* GJR: odd, this register is set to 0x55 above *\/ */
+	{0x3119, 0x54, 0x00},
+
+	/* linear mode */
+	/* {0x3119, 0x55, 0x00},	    /\* long exposure only *\/ */
+
+/* expo_calc_ctrl 1 & 2: all auto, ex dgain */
+	{0x7001, 0xff, 0x00},
+	{0x7000, 0x3f, 0x00},
+	{0x7003, 0xbf, 0x00},
+	{0x7002, 0xff, 0x00},
+/* long test targets */
+	{0x7004, 0x13, 0x00},
+	{0x7005, 0xec, 0x00},
+	{0x7006, 0x0e, 0x00},
+	{0x7007, 0xf1, 0x00},
+	{0x7008, 0x13, 0x00},
+	{0x7009, 0xec, 0x00},
+	{0x700A, 0x27, 0x00},
+	{0x700B, 0xd8, 0x00},
+	{0x700e, 0x00, 0x00},
+	{0x700f, 0xff, 0x00},
+/* short test targets */
+	{0x701a, 0x13, 0x00},
+	{0x701b, 0xec, 0x00},
+	{0x701c, 0x0e, 0x00},
+	{0x701d, 0xf1, 0x00},
+	{0x701e, 0x13, 0x00},
+	{0x701f, 0xec, 0x00},
+	{0x7020, 0x27, 0x00},
+	{0x7021, 0xd8, 0x00},
+	{0x7024, 0x00, 0x00},
+	{0x7025, 0xff, 0x00},
+/* Absolute minimum value for analog gain */
+	{0x7048, 0x00, 0x00},
+	{0x7049, 0x01, 0x00},
+/* long dgain 1.33x */
+	{0x704a, 0x03, 0x00},
+	{0x704b, 0x00, 0x00},
+	{0x704c, 0x01, 0x00},
+	{0x704d, 0x40, 0x00},
+/* short gain min 2.0, dgain 1x */
+	{0x7084, 0x01, 0x00},
+	{0x7085, 0x02, 0x00},
+	{0x7086, 0x03, 0x00},
+	{0x7087, 0x00, 0x00},
+	{0x7088, 0x01, 0x00},
+	{0x7089, 0x40, 0x00},
+/* very short, dgain 1.333  */
+	{0x70c0, 0x00, 0x00},
+	{0x70c1, 0x03, 0x00},
+	{0x70c2, 0x03, 0x00},
+	{0x70c3, 0x00, 0x00},
+	{0x70c4, 0x01, 0x00},
+	{0x70c5, 0x40, 0x00},
+/* long exp */
+	{0x7042, 0x00, 0x00},
+	{0x7043, 0x03, 0x00},
+	{0x7040, 0x3c, 0x00},
+	{0x7041, 0x00, 0x00},
+	{0x7046, 0x00, 0x00},
+	{0x7047, 0x00, 0x00},
+	{0x7044, 0x04, 0x00},
+	{0x7045, 0x00, 0x00},
+/* short */
+	{0x707e, 0x00, 0x00},
+	{0x707f, 0x02, 0x00},
+	{0x707c, 0xe0, 0x00},
+	{0x707d, 0x00, 0x00},
+	{0x7082, 0x00, 0x00},
+	{0x7083, 0x00, 0x00},
+	{0x7080, 0x04, 0x00},
+	{0x7081, 0x00, 0x00},
+/* very short */
+	{0x70ba, 0x00, 0x00},
+	{0x70bb, 0x00, 0x00},
+	{0x70b8, 0x03, 0x00},
+	{0x70b9, 0xf8, 0x00},
+	{0x70be, 0x00, 0x00},
+	{0x70bf, 0x00, 0x00},
+	{0x70bc, 0x00, 0x00},
+	{0x70bd, 0x80, 0x00},
+/* absolute  max long/short = 16 */
+	{0x70e6, 0x00, 0x00},
+	{0x70e7, 0x00, 0x00},
+	{0x70e4, 0x10, 0x00},
+	{0x70e5, 0x00, 0x00},
+/* absolute min long/short = 8 */
+	{0x70ea, 0x00, 0x00},
+	{0x70eb, 0x00, 0x00},
+	{0x70e8, 0x08, 0x00},
+	{0x70e9, 0x00, 0x00},
+/* absolute max long/very short = 256 */
+	{0x70ee, 0x00, 0x00},
+	{0x70ef, 0x01, 0x00},
+	{0x70ec, 0x00, 0x00},
+	{0x70ed, 0x00, 0x00},
+/* absolute min long/very short = 256 */
+	{0x70f2, 0x00, 0x00},
+	{0x70f3, 0x00, 0x00},
+	{0x70f0, 0xff, 0x00},
+	{0x70f1, 0x00, 0x00},
+/* PD ratio  x6.5 */
+	{0x30FB, 0x6 , 0x00},
+	{0x30FC, 0x80, 0x00},
+/* CG ratio 2.57 */
+	{0x30FD, 0x2 , 0x00},
+	{0x30FE, 0x93, 0x00},
+	{0x313c, 0x20, 0x00},
+	{0x313f, 0x80, 0x00},
+	{0x3140, 0x10, 0x00},
+	{0x3127, 0x63, 0x00},     /* enable ISP */
+/* {0x30fa, 0x56, 0x00},    enable AEC */
+	{0x30fa, 0x16, 0x00},    /*disable AEC */
+	{0x328A, 0x00, 0x00},
+	{0x704A, 0x08, 0x00},
+	{0x4000, 0x00, 0x00},
+	{0x4001, 0x00, 0x00},
+	{0x4002, 0x00, 0x00},
+	{0x4003, 0x00, 0x00},
+	{0x4004, 0x03, 0x00},
+	{0x4005, 0x20, 0x00},
+	{0x4006, 0x05, 0x00},
+	{0x4007, 0x00, 0x00},
+	{0x4008, 0x16, 0x00},
+};
+const size_t mode_1280x1080hdr_len = ARRAY_SIZE(mode_1280x1080hdr);
+#endif /* CONFIG_D3_OV10640_HDR_ENABLE */
+
+const struct reg_sequence mode_1280x1080long[] = {
+	{0x3013, 0x01, 10000},
+	{0x328a, 0x11, 0x00},
+	{0x313f, 0x80, 0x00},
+	{0x3132, 0x24, 0x00},
+	{0x3000, 0x03, 0x00},
+	{0x3002, 0x07, 0x00},
+	{0x3004, 0x03, 0x00},
+	{0x3005, 0x60, 0x00},
+	{0x3006, 0x07, 0x00},
+	{0x3007, 0x01, 0x00},
+	{0x3014, 0x03, 0x00},
+	{0x3023, 0x05, 0x00},
+	{0x3032, 0x35, 0x00},
+	{0x3033, 0x04, 0x00},
+	{0x3054, 0x00, 0x00},
+	{0x3055, 0x03, 0x00},
+	{0x3056, 0x01, 0x00},
+	{0x3057, 0xff, 0x00},
+	{0x3058, 0xaf, 0x00},
+	{0x3059, 0x44, 0x00},
+	{0x305a, 0x02, 0x00},
+	{0x305b, 0x00, 0x00},
+	{0x305c, 0x30, 0x00},
+	{0x305d, 0x9c, 0x00},
+	{0x305e, 0x19, 0x00},
+	{0x305f, 0x18, 0x00},
+	{0x3060, 0xf9, 0x00},
+	{0x3061, 0xf0, 0x00},
+	{0x308c, 0x03, 0x00},
+	{0x308f, 0x10, 0x00},
+	/* /\* hdr mode  *\/ */
+	/* {0x3090, 0x08, 0x00},  /\* flip *\/ */
+	/* linear mode */
+	{0x3090, 0x68, 0x00},  /* Single exposure and flip */
+	{0x3091, 0x00, 0x00},  /* Disable embedded data lines */
+	{0x3291, 0x04, 0x00},  /* flip */
+	{0x30a3, 0x08, 0x00},
+	{0x30ad, 0x03, 0x00},
+	{0x30ae, 0x80, 0x00},
+	{0x30af, 0x80, 0x00},
+	{0x30b0, 0xff, 0x00},
+	{0x30b1, 0x3f, 0x00},
+	{0x30b2, 0x22, 0x00},
+	{0x30b9, 0x22, 0x00},
+	{0x30bb, 0x00, 0x00},
+	{0x30bc, 0x00, 0x00},
+	{0x30bd, 0x00, 0x00},
+	{0x30be, 0x00, 0x00},
+	{0x30bf, 0x00, 0x00},
+	{0x30c0, 0x00, 0x00},
+	{0x30c1, 0x00, 0x00},
+	{0x30c2, 0x00, 0x00},
+	{0x30c3, 0x00, 0x00},
+	{0x30c4, 0x80, 0x00},
+	{0x30c5, 0x00, 0x00},
+	{0x30c6, 0x80, 0x00},
+	{0x30c7, 0x00, 0x00},
+	{0x30c8, 0x80, 0x00},
+	{0x3119, 0x55, 0x00},
+	{0x311a, 0x01, 0x00},
+	{0x311b, 0x4a, 0x00},
+	{0x3074, 0x00, 0x00},
+	{0x3075, 0x00, 0x00},
+	{0x3078, 0x05, 0x00},
+	{0x3079, 0x07, 0x00},
+	{0x307a, 0x04, 0x00},
+	{0x307b, 0x41, 0x00},
+	{0x307c, 0x05, 0x00},
+	{0x307d, 0x00, 0x00},
+	{0x307e, 0x04, 0x00},
+	{0x307f, 0x38, 0x00},
+	{0x3080, 0x05, 0x00},
+	{0x3081, 0xaa, 0x00},
+	{0x3084, 0x00, 0x00},
+	{0x3085, 0x04, 0x00},
+	{0x3086, 0x00, 0x00},
+	{0x3087, 0x04, 0x00},
+	{0x3088, 0x00, 0x00},
+	{0x3089, 0x40, 0x00},
+	{0x308d, 0x92, 0x00},
+	{0x3094, 0xa5, 0x00},
+	{0x30e6, 0x02, 0x00},
+	{0x30e7, 0xe0, 0x00},
+	{0x30e8, 0x02, 0x00},
+	{0x30e9, 0xe0, 0x00},
+/*{0x30eb, 0x40 , 0x00},*/
+	{0x30eb, 0x00, 0x00},
+	{0x30ec, 0x01, 0x00},
+	{0x30ed, 0x80, 0x00},
+	{0x30ee, 0x01, 0x00},
+	{0x30f0, 0x01, 0x00},
+	{0x30ef, 0x80, 0x00},
+	{0x30f1, 0x80, 0x00},
+	{0x30fa, 0x76, 0x00},
+	{0x3120, 0x00, 0x00},
+	{0x3121, 0x01, 0x00},
+	{0x3122, 0x00, 0x0A},
+	{0x3127, 0x63, 0x00},
+	{0x3128, 0xc2, 0x00},  /* flip */
+	{0x3129, 0x00, 0x00},
+	{0x31be, 0x00, 0x00},
+	{0x30a5, 0x78, 0x00},
+	{0x30a6, 0x40, 0x00},
+	{0x30a7, 0x78, 0x00},
+	{0x30a8, 0x80, 0x00},
+	{0x30a9, 0x78, 0x00},
+	{0x30aa, 0xe0, 0x00},
+	{0x30ab, 0xf9, 0x00},
+	{0x30ac, 0xc0, 0x00},
+	{0x3440, 0x04, 0x00},
+	{0x3444, 0x48, 0x00},
+	{0x344e, 0x2c, 0x00},
+	{0x3457, 0x33, 0x00},
+	{0x345e, 0x38, 0x00},
+	{0x3461, 0xa8, 0x00},
+	{0x7002, 0xaa, 0x00},
+	{0x7001, 0xdf, 0x00},
+	{0x7048, 0x00, 0x00},
+	{0x7049, 0x02, 0x00},
+	{0x704a, 0x02, 0x00},
+	{0x704b, 0x00, 0x00},
+	{0x704c, 0x01, 0x00},
+	{0x704d, 0x00, 0x00},
+	{0x7043, 0x04, 0x00},
+	{0x7040, 0x3c, 0x00},
+	{0x7047, 0x00, 0x00},
+	{0x7044, 0x01, 0x00},
+	{0x7000, 0x1f, 0x00},
+	{0x7084, 0x01, 0x00},
+	{0x7085, 0x03, 0x00},
+	{0x7086, 0x02, 0x00},
+	{0x7087, 0x40, 0x00},
+	{0x7088, 0x01, 0x00},
+	{0x7089, 0x20, 0x00},
+	{0x707f, 0x04, 0x00},
+	{0x707c, 0x3c, 0x00},
+	{0x7083, 0x00, 0x00},
+	{0x7080, 0x01, 0x00},
+	{0x7003, 0xdf, 0x00},
+	{0x70c0, 0x00, 0x00},
+	{0x70c1, 0x02, 0x00},
+	{0x70c2, 0x02, 0x00},
+	{0x70c3, 0x00, 0x00},
+	{0x70c4, 0x01, 0x00},
+	{0x70c5, 0x00, 0x00},
+	{0x70b8, 0x03, 0x00},
+	{0x70b9, 0x98, 0x00},
+	{0x70bc, 0x00, 0x00},
+	{0x70bd, 0x80, 0x00},
+	{0x7004, 0x02, 0x00},
+	{0x7005, 0x00, 0x00},
+	{0x7006, 0x01, 0x00},
+	{0x7007, 0x80, 0x00},
+	{0x7008, 0x02, 0x00},
+	{0x7009, 0x00, 0x00},
+	{0x700a, 0x04, 0x00},
+	{0x700b, 0x00, 0x00},
+	{0x700e, 0x00, 0x00},
+	{0x700f, 0x60, 0x00},
+	{0x701a, 0x02, 0x00},
+	{0x701b, 0x00, 0x00},
+	{0x701c, 0x01, 0x00},
+	{0x701d, 0x80, 0x00},
+	{0x701e, 0x02, 0x00},
+	{0x701f, 0x00, 0x00},
+	{0x7020, 0x04, 0x00},
+	{0x7021, 0x00, 0x00},
+	{0x7024, 0x00, 0x00},
+	{0x7025, 0x60, 0x00},
+	{0x70e7, 0x00, 0x00},
+	{0x70e4, 0x10, 0x00},
+	{0x70e5, 0x00, 0x00},
+	{0x70e6, 0x00, 0x00},
+	{0x70eb, 0x00, 0x00},
+	{0x70e8, 0x10, 0x00},
+	{0x70e9, 0x00, 0x00},
+	{0x70ea, 0x00, 0x00},
+	{0x70ef, 0x00, 0x00},
+	{0x70ec, 0xfd, 0x00},
+	{0x70ed, 0x00, 0x00},
+	{0x70ee, 0x00, 0x00},
+	{0x70eb, 0x00, 0x00},
+	{0x70f0, 0xfd, 0x00},
+	{0x70f1, 0x00, 0x00},
+	{0x70f2, 0x00, 0x00},
+	{0x30fb, 0x06, 0x00},
+	{0x30fc, 0x80, 0x00},
+	{0x30fd, 0x02, 0x00},
+	{0x30fe, 0x93, 0x00},
+	{0x6000, 0xc1, 0x00},
+	{0x6001, 0xb9, 0x00},
+	{0x6002, 0xba, 0x00},
+	{0x6003, 0xa4, 0x00},
+	{0x6004, 0xb5, 0x00},
+	{0x6005, 0xa0, 0x00},
+	{0x6006, 0x82, 0x00},
+	{0x6007, 0xa7, 0x00},
+	{0x6008, 0xb7, 0x00},
+	{0x6009, 0x5c, 0x00},
+	{0x600a, 0x9e, 0x00},
+	{0x600b, 0xc0, 0x00},
+	{0x600c, 0xd2, 0x00},
+	{0x600d, 0x33, 0x00},
+	{0x600e, 0xcc, 0x00},
+	{0x600f, 0xe2, 0x00},
+	{0x6010, 0xc1, 0x00},
+	{0x6011, 0xab, 0x00},
+	{0x6012, 0xb7, 0x00},
+	{0x6013, 0x00, 0x00},
+	{0x6014, 0x00, 0x00},
+	{0x6015, 0x00, 0x00},
+	{0x6016, 0x00, 0x00},
+	{0x6017, 0x00, 0x00},
+	{0x6018, 0x00, 0x00},
+	{0x6019, 0x00, 0x00},
+	{0x601a, 0x00, 0x00},
+	{0x601b, 0x00, 0x00},
+	{0x601c, 0x00, 0x00},
+	{0x601d, 0x00, 0x00},
+	{0x601e, 0x9c, 0x00},
+	{0x601f, 0x94, 0x00},
+	{0x6020, 0x90, 0x00},
+	{0x6021, 0xc5, 0x00},
+	{0x6022, 0x01, 0x00},
+	{0x6023, 0x54, 0x00},
+	{0x6024, 0x2a, 0x00},
+	{0x6025, 0x61, 0x00},
+	{0x6026, 0xd2, 0x00},
+	{0x6027, 0xcc, 0x00},
+	{0x6028, 0x04, 0x00},
+	{0x6029, 0x35, 0x00},
+	{0x602a, 0xb1, 0x00},
+	{0x602b, 0xb2, 0x00},
+	{0x602c, 0xb3, 0x00},
+	{0x602d, 0xd2, 0x00},
+	{0x602e, 0xd3, 0x00},
+	{0x602f, 0x12, 0x00},
+	{0x6030, 0x31, 0x00},
+	{0x6031, 0xcc, 0x00},
+	{0x6032, 0x06, 0x00},
+	{0x6033, 0xd2, 0x00},
+	{0x6034, 0xc4, 0x00},
+	{0x6035, 0xce, 0x00},
+	{0x6036, 0x18, 0x00},
+	{0x6037, 0xcf, 0x00},
+	{0x6038, 0x1e, 0x00},
+	{0x6039, 0xd0, 0x00},
+	{0x603a, 0x24, 0x00},
+	{0x603b, 0xc5, 0x00},
+	{0x603c, 0xd2, 0x00},
+	{0x603d, 0xbc, 0x00},
+	{0x603e, 0xcc, 0x00},
+	{0x603f, 0x52, 0x00},
+	{0x6040, 0x2b, 0x00},
+	{0x6041, 0xd2, 0x00},
+	{0x6042, 0xd3, 0x00},
+	{0x6043, 0x02, 0x00},
+	{0x6044, 0xcc, 0x00},
+	{0x6045, 0x0a, 0x00},
+	{0x6046, 0xd2, 0x00},
+	{0x6047, 0xd3, 0x00},
+	{0x6048, 0x0f, 0x00},
+	{0x6049, 0x1a, 0x00},
+	{0x604a, 0x2a, 0x00},
+	{0x604b, 0xd4, 0x00},
+	{0x604c, 0xf6, 0x00},
+	{0x604d, 0xba, 0x00},
+	{0x604e, 0x56, 0x00},
+	{0x604f, 0xd3, 0x00},
+	{0x6050, 0x2e, 0x00},
+	{0x6051, 0x54, 0x00},
+	{0x6052, 0x26, 0x00},
+	{0x6053, 0xd2, 0x00},
+	{0x6054, 0xcc, 0x00},
+	{0x6055, 0x60, 0x00},
+	{0x6056, 0xd2, 0x00},
+	{0x6057, 0xd3, 0x00},
+	{0x6058, 0x27, 0x00},
+	{0x6059, 0x27, 0x00},
+	{0x605a, 0x08, 0x00},
+	{0x605b, 0x1a, 0x00},
+	{0x605c, 0xcc, 0x00},
+	{0x605d, 0x88, 0x00},
+	{0x605e, 0x00, 0x00},
+	{0x605f, 0x12, 0x00},
+	{0x6060, 0x2c, 0x00},
+	{0x6061, 0x60, 0x00},
+	{0x6062, 0xc2, 0x00},
+	{0x6063, 0xb9, 0x00},
+	{0x6064, 0xa5, 0x00},
+	{0x6065, 0xb5, 0x00},
+	{0x6066, 0xa0, 0x00},
+	{0x6067, 0x82, 0x00},
+	{0x6068, 0x5c, 0x00},
+	{0x6069, 0xd4, 0x00},
+	{0x606a, 0xbe, 0x00},
+	{0x606b, 0xd4, 0x00},
+	{0x606c, 0xbe, 0x00},
+	{0x606d, 0xd3, 0x00},
+	{0x606e, 0x01, 0x00},
+	{0x606f, 0x7c, 0x00},
+	{0x6070, 0x74, 0x00},
+	{0x6071, 0x00, 0x00},
+	{0x6072, 0x61, 0x00},
+	{0x6073, 0x2a, 0x00},
+	{0x6074, 0xd2, 0x00},
+	{0x6075, 0xcc, 0x00},
+	{0x6076, 0xdf, 0x00},
+	{0x6077, 0xc6, 0x00},
+	{0x6078, 0x35, 0x00},
+	{0x6079, 0xd2, 0x00},
+	{0x607a, 0xcc, 0x00},
+	{0x607b, 0x06, 0x00},
+	{0x607c, 0x31, 0x00},
+	{0x607d, 0xd2, 0x00},
+	{0x607e, 0xc5, 0x00},
+	{0x607f, 0xbb, 0x00},
+	{0x6080, 0xcc, 0x00},
+	{0x6081, 0x18, 0x00},
+	{0x6082, 0xc6, 0x00},
+	{0x6083, 0xd2, 0x00},
+	{0x6084, 0xbd, 0x00},
+	{0x6085, 0xcc, 0x00},
+	{0x6086, 0x52, 0x00},
+	{0x6087, 0x2b, 0x00},
+	{0x6088, 0xd2, 0x00},
+	{0x6089, 0xd3, 0x00},
+	{0x608a, 0x01, 0x00},
+	{0x608b, 0xcc, 0x00},
+	{0x608c, 0x0a, 0x00},
+	{0x608d, 0xd2, 0x00},
+	{0x608e, 0xd3, 0x00},
+	{0x608f, 0x0f, 0x00},
+	{0x6090, 0x1a, 0x00},
+	{0x6091, 0x71, 0x00},
+	{0x6092, 0x2a, 0x00},
+	{0x6093, 0xd4, 0x00},
+	{0x6094, 0xf6, 0x00},
+	{0x6095, 0xd3, 0x00},
+	{0x6096, 0x22, 0x00},
+	{0x6097, 0x70, 0x00},
+	{0x6098, 0xca, 0x00},
+	{0x6099, 0x26, 0x00},
+	{0x609a, 0xd2, 0x00},
+	{0x609b, 0xcc, 0x00},
+	{0x609c, 0x60, 0x00},
+	{0x609d, 0xd2, 0x00},
+	{0x609e, 0xd3, 0x00},
+	{0x609f, 0x27, 0x00},
+	{0x60a0, 0x27, 0x00},
+	{0x60a1, 0x08, 0x00},
+	{0x60a2, 0x1a, 0x00},
+	{0x60a3, 0xcc, 0x00},
+	{0x60a4, 0x88, 0x00},
+	{0x60a5, 0x12, 0x00},
+	{0x60a6, 0x2c, 0x00},
+	{0x60a7, 0x60, 0x00},
+	{0x60a8, 0x00, 0x00},
+	{0x60a9, 0x00, 0x00},
+	{0x60aa, 0xc0, 0x00},
+	{0x60ab, 0xb9, 0x00},
+	{0x60ac, 0xa3, 0x00},
+	{0x60ad, 0xb5, 0x00},
+	{0x60ae, 0x00, 0x00},
+	{0x60af, 0xa0, 0x00},
+	{0x60b0, 0x82, 0x00},
+	{0x60b1, 0x5c, 0x00},
+	{0x60b2, 0xd4, 0x00},
+	{0x60b3, 0xa0, 0x00},
+	{0x60b4, 0x9d, 0x00},
+	{0x60b5, 0xd3, 0x00},
+	{0x60b6, 0x26, 0x00},
+	{0x60b7, 0xb0, 0x00},
+	{0x60b8, 0xb7, 0x00},
+	{0x60b9, 0x00, 0x00},
+	{0x60ba, 0xd3, 0x00},
+	{0x60bb, 0x0a, 0x00},
+	{0x60bc, 0xd3, 0x00},
+	{0x60bd, 0x10, 0x00},
+	{0x60be, 0x9c, 0x00},
+	{0x60bf, 0x94, 0x00},
+	{0x60c0, 0x90, 0x00},
+	{0x60c1, 0xc8, 0x00},
+	{0x60c2, 0xba, 0x00},
+	{0x60c3, 0x7c, 0x00},
+	{0x60c4, 0x74, 0x00},
+	{0x60c5, 0x00, 0x00},
+	{0x60c6, 0x61, 0x00},
+	{0x60c7, 0x2a, 0x00},
+	{0x60c8, 0x00, 0x00},
+	{0x60c9, 0xd2, 0x00},
+	{0x60ca, 0xcc, 0x00},
+	{0x60cb, 0xdf, 0x00},
+	{0x60cc, 0xc4, 0x00},
+	{0x60cd, 0x35, 0x00},
+	{0x60ce, 0xd2, 0x00},
+	{0x60cf, 0xcc, 0x00},
+	{0x60d0, 0x06, 0x00},
+	{0x60d1, 0x31, 0x00},
+	{0x60d2, 0xd2, 0x00},
+	{0x60d3, 0xcc, 0x00},
+	{0x60d4, 0x15, 0x00},
+	{0x60d5, 0xd2, 0x00},
+	{0x60d6, 0xbb, 0x00},
+	{0x60d7, 0xcc, 0x00},
+	{0x60d8, 0x1a, 0x00},
+	{0x60d9, 0xd2, 0x00},
+	{0x60da, 0xbe, 0x00},
+	{0x60db, 0xce, 0x00},
+	{0x60dc, 0x52, 0x00},
+	{0x60dd, 0xcf, 0x00},
+	{0x60de, 0x56, 0x00},
+	{0x60df, 0xd0, 0x00},
+	{0x60e0, 0x5b, 0x00},
+	{0x60e1, 0x2b, 0x00},
+	{0x60e2, 0xd2, 0x00},
+	{0x60e3, 0xd3, 0x00},
+	{0x60e4, 0x01, 0x00},
+	{0x60e5, 0xcc, 0x00},
+	{0x60e6, 0x0a, 0x00},
+	{0x60e7, 0xd2, 0x00},
+	{0x60e8, 0xd3, 0x00},
+	{0x60e9, 0x0f, 0x00},
+	{0x60ea, 0xd9, 0x00},
+	{0x60eb, 0xc7, 0x00},
+	{0x60ec, 0xda, 0x00},
+	{0x60ed, 0xce, 0x00},
+	{0x60ee, 0x1a, 0x00},
+	{0x60ef, 0xd4, 0x00},
+	{0x60f0, 0xf6, 0x00},
+	{0x60f1, 0xd4, 0x00},
+	{0x60f2, 0xa9, 0x00},
+	{0x60f3, 0x27, 0x00},
+	{0x60f4, 0x00, 0x00},
+	{0x60f5, 0xd2, 0x00},
+	{0x60f6, 0xcc, 0x00},
+	{0x60f7, 0x60, 0x00},
+	{0x60f8, 0xd2, 0x00},
+	{0x60f9, 0xd3, 0x00},
+	{0x60fa, 0x2d, 0x00},
+	{0x60fb, 0xd9, 0x00},
+	{0x60fc, 0xdf, 0x00},
+	{0x60fd, 0xda, 0x00},
+	{0x60fe, 0xe5, 0x00},
+	{0x60ff, 0x1a, 0x00},
+	{0x6100, 0x12, 0x00},
+	{0x6101, 0xcc, 0x00},
+	{0x6102, 0x88, 0x00},
+	{0x6103, 0xd6, 0x00},
+	{0x6104, 0xb1, 0x00},
+	{0x6105, 0xb9, 0x00},
+	{0x6106, 0xba, 0x00},
+	{0x6107, 0xaf, 0x00},
+	{0x6108, 0xdc, 0x00},
+	{0x6109, 0x00, 0x00},
+	{0x610a, 0xcb, 0x00},
+	{0x610b, 0xc3, 0x00},
+	{0x610c, 0xb9, 0x00},
+	{0x610d, 0xa4, 0x00},
+	{0x610e, 0xb5, 0x00},
+	{0x610f, 0x5c, 0x00},
+	{0x6110, 0x12, 0x00},
+	{0x6111, 0x2a, 0x00},
+	{0x6112, 0x61, 0x00},
+	{0x6113, 0xd2, 0x00},
+	{0x6114, 0xcc, 0x00},
+	{0x6115, 0xdf, 0x00},
+	{0x6116, 0xc7, 0x00},
+	{0x6117, 0x35, 0x00},
+	{0x6118, 0xd2, 0x00},
+	{0x6119, 0xcc, 0x00},
+	{0x611a, 0x06, 0x00},
+	{0x611b, 0x31, 0x00},
+	{0x611c, 0xc6, 0x00},
+	{0x611d, 0xbb, 0x00},
+	{0x611e, 0xd2, 0x00},
+	{0x611f, 0xcc, 0x00},
+	{0x6120, 0x18, 0x00},
+	{0x6121, 0xd2, 0x00},
+	{0x6122, 0xbe, 0x00},
+	{0x6123, 0xcc, 0x00},
+	{0x6124, 0x52, 0x00},
+	{0x6125, 0xc7, 0x00},
+	{0x6126, 0xd2, 0x00},
+	{0x6127, 0xcc, 0x00},
+	{0x6128, 0x0a, 0x00},
+	{0x6129, 0xb4, 0x00},
+	{0x612a, 0xb7, 0x00},
+	{0x612b, 0x94, 0x00},
+	{0x612c, 0xd2, 0x00},
+	{0x612d, 0x12, 0x00},
+	{0x612e, 0x26, 0x00},
+	{0x612f, 0x42, 0x00},
+	{0x6130, 0x46, 0x00},
+	{0x6131, 0x42, 0x00},
+	{0x6132, 0xd3, 0x00},
+	{0x6133, 0x20, 0x00},
+	{0x6134, 0x27, 0x00},
+	{0x6135, 0x00, 0x00},
+	{0x6136, 0x1a, 0x00},
+	{0x6137, 0xcc, 0x00},
+	{0x6138, 0x88, 0x00},
+	{0x6139, 0x60, 0x00},
+	{0x613a, 0x2c, 0x00},
+	{0x613b, 0x12, 0x00},
+	{0x613c, 0x40, 0x00},
+	{0x613d, 0xb8, 0x00},
+	{0x613e, 0x90, 0x00},
+	{0x613f, 0xd5, 0x00},
+	{0x6140, 0xba, 0x00},
+	{0x6141, 0x00, 0x00},
+	{0x6142, 0x00, 0x00},
+	{0x6143, 0x00, 0x00},
+	{0x6144, 0x00, 0x00},
+	{0x6145, 0x00, 0x00},
+	{0x6146, 0x00, 0x00},
+	{0x6147, 0xaa, 0x00},
+	{0x6148, 0xb7, 0x00},
+	{0x6149, 0x00, 0x00},
+	{0x614a, 0x00, 0x00},
+	{0x614b, 0x00, 0x00},
+	{0x614c, 0x00, 0x00},
+	{0x614d, 0xa6, 0x00},
+	{0x614e, 0xb7, 0x00},
+	{0x614f, 0x00, 0x00},
+	{0x6150, 0xd5, 0x00},
+	{0x6151, 0x00, 0x00},
+	{0x6152, 0x71, 0x00},
+	{0x6153, 0xd3, 0x00},
+	{0x6154, 0x30, 0x00},
+	{0x6155, 0xba, 0x00},
+	{0x6156, 0x00, 0x00},
+	{0x6157, 0x00, 0x00},
+	{0x6158, 0x00, 0x00},
+	{0x6159, 0x00, 0x00},
+	{0x615a, 0xd3, 0x00},
+	{0x615b, 0x10, 0x00},
+	{0x615c, 0x70, 0x00},
+	{0x615d, 0x00, 0x00},
+	{0x615e, 0x00, 0x00},
+	{0x615f, 0x00, 0x00},
+	{0x6160, 0x00, 0x00},
+	{0x6161, 0xd5, 0x00},
+	{0x6162, 0xba, 0x00},
+	{0x6163, 0xb0, 0x00},
+	{0x6164, 0xb7, 0x00},
+	{0x6165, 0x00, 0x00},
+	{0x6166, 0x9d, 0x00},
+	{0x6167, 0xd3, 0x00},
+	{0x6168, 0x0a, 0x00},
+	{0x6169, 0x9d, 0x00},
+	{0x616a, 0x9d, 0x00},
+	{0x616b, 0xd3, 0x00},
+	{0x616c, 0x10, 0x00},
+	{0x616d, 0x9c, 0x00},
+	{0x616e, 0x94, 0x00},
+	{0x616f, 0x90, 0x00},
+	{0x6170, 0xc8, 0x00},
+	{0x6171, 0xba, 0x00},
+	{0x6172, 0xd2, 0x00},
+	{0x6173, 0x60, 0x00},
+	{0x6174, 0x2c, 0x00},
+	{0x6175, 0x50, 0x00},
+	{0x6176, 0x11, 0x00},
+	{0x6177, 0xcc, 0x00},
+	{0x6178, 0x00, 0x00},
+	{0x6179, 0x30, 0x00},
+	{0x617a, 0xd5, 0x00},
+	{0x617b, 0x00, 0x00},
+	{0x617c, 0xba, 0x00},
+	{0x617d, 0xb0, 0x00},
+	{0x617e, 0xb7, 0x00},
+	{0x617f, 0x00, 0x00},
+	{0x6180, 0x9d, 0x00},
+	{0x6181, 0xd3, 0x00},
+	{0x6182, 0x0a, 0x00},
+	{0x6183, 0x9d, 0x00},
+	{0x6184, 0x9d, 0x00},
+	{0x6185, 0xd3, 0x00},
+	{0x6186, 0x10, 0x00},
+	{0x6187, 0x9c, 0x00},
+	{0x6188, 0x94, 0x00},
+	{0x6189, 0x90, 0x00},
+	{0x618a, 0xc8, 0x00},
+	{0x618b, 0xba, 0x00},
+	{0x618c, 0xd5, 0x00},
+	{0x618d, 0x00, 0x00},
+	{0x618e, 0x01, 0x00},
+	{0x618f, 0x1a, 0x00},
+	{0x6190, 0xcc, 0x00},
+	{0x6191, 0x12, 0x00},
+	{0x6192, 0x12, 0x00},
+	{0x6193, 0x00, 0x00},
+	{0x6194, 0xcc, 0x00},
+	{0x6195, 0x9c, 0x00},
+	{0x6196, 0xd2, 0x00},
+	{0x6197, 0xcc, 0x00},
+	{0x6198, 0x60, 0x00},
+	{0x6199, 0xd2, 0x00},
+	{0x619a, 0x04, 0x00},
+	{0x619b, 0xd5, 0x00},
+	{0x619c, 0x1a, 0x00},
+	{0x619d, 0xcc, 0x00},
+	{0x619e, 0x12, 0x00},
+	{0x619f, 0x00, 0x00},
+	{0x61a0, 0x12, 0x00},
+	{0x61a1, 0xcc, 0x00},
+	{0x61a2, 0x9c, 0x00},
+	{0x61a3, 0xd2, 0x00},
+	{0x61a4, 0xcc, 0x00},
+	{0x61a5, 0x60, 0x00},
+	{0x61a6, 0xd2, 0x00},
+	{0x61a7, 0x1a, 0x00},
+	{0x61a8, 0xcc, 0x00},
+	{0x61a9, 0x12, 0x00},
+	{0x61aa, 0x00, 0x00},
+	{0x61ab, 0x12, 0x00},
+	{0x61ac, 0xcc, 0x00},
+	{0x61ad, 0x9c, 0x00},
+	{0x61ae, 0xd2, 0x00},
+	{0x61af, 0xcc, 0x00},
+	{0x61b0, 0x60, 0x00},
+	{0x61b1, 0xd2, 0x00},
+	{0x61b2, 0x1a, 0x00},
+	{0x61b3, 0xcc, 0x00},
+	{0x61b4, 0x12, 0x00},
+	{0x61b5, 0x00, 0x00},
+	{0x61b6, 0x12, 0x00},
+	{0x61b7, 0xcc, 0x00},
+	{0x61b8, 0x9c, 0x00},
+	{0x61b9, 0xd2, 0x00},
+	{0x61ba, 0xcc, 0x00},
+	{0x61bb, 0x60, 0x00},
+	{0x61bc, 0xd2, 0x00},
+	{0x61bd, 0xd5, 0x00},
+	{0x61be, 0x1a, 0x00},
+	{0x61bf, 0xcc, 0x00},
+	{0x61c0, 0x12, 0x00},
+	{0x61c1, 0x12, 0x00},
+	{0x61c2, 0x00, 0x00},
+	{0x61c3, 0xcc, 0x00},
+	{0x61c4, 0x8a, 0x00},
+	{0x61c5, 0xd2, 0x00},
+	{0x61c6, 0xcc, 0x00},
+	{0x61c7, 0x74, 0x00},
+	{0x61c8, 0xd2, 0x00},
+	{0x61c9, 0xd5, 0x00},
+	{0x61ca, 0x1a, 0x00},
+	{0x61cb, 0xcc, 0x00},
+	{0x61cc, 0x12, 0x00},
+	{0x61cd, 0x00, 0x00},
+	{0x61ce, 0x12, 0x00},
+	{0x61cf, 0xcc, 0x00},
+	{0x61d0, 0x8a, 0x00},
+	{0x61d1, 0xd2, 0x00},
+	{0x61d2, 0xcc, 0x00},
+	{0x61d3, 0x74, 0x00},
+	{0x61d4, 0xd2, 0x00},
+	{0x61d5, 0x1a, 0x00},
+	{0x61d6, 0xcc, 0x00},
+	{0x61d7, 0x12, 0x00},
+	{0x61d8, 0x00, 0x00},
+	{0x61d9, 0x12, 0x00},
+	{0x61da, 0xcc, 0x00},
+	{0x61db, 0x8a, 0x00},
+	{0x61dc, 0xd2, 0x00},
+	{0x61dd, 0xcc, 0x00},
+	{0x61de, 0x74, 0x00},
+	{0x61df, 0xd2, 0x00},
+	{0x61e0, 0x1a, 0x00},
+	{0x61e1, 0xcc, 0x00},
+	{0x61e2, 0x12, 0x00},
+	{0x61e3, 0x00, 0x00},
+	{0x61e4, 0x12, 0x00},
+	{0x61e5, 0xcc, 0x00},
+	{0x61e6, 0x8a, 0x00},
+	{0x61e7, 0xd2, 0x00},
+	{0x61e8, 0xcc, 0x00},
+	{0x61e9, 0x74, 0x00},
+	{0x61ea, 0xd2, 0x00},
+	{0x61eb, 0xd5, 0x00},
+	{0x61ec, 0xcc, 0x00},
+	{0x61ed, 0x12, 0x00},
+	{0x61ee, 0x00, 0x00},
+	{0x61ef, 0x12, 0x00},
+	{0x61f0, 0xcc, 0x00},
+	{0x61f1, 0x9c, 0x00},
+	{0x61f2, 0xd5, 0x00},
+	{0x6400, 0x04, 0x00},
+	{0x6401, 0x04, 0x00},
+	{0x6402, 0x00, 0x00},
+	{0x6403, 0xff, 0x00},
+	{0x6404, 0x00, 0x00},
+	{0x6405, 0x08, 0x00},
+	{0x6406, 0x00, 0x00},
+	{0x6407, 0xff, 0x00},
+	{0x6408, 0x04, 0x00},
+	{0x6409, 0x70, 0x00},
+	{0x640a, 0x00, 0x00},
+	{0x640b, 0xff, 0x00},
+	{0x640c, 0x05, 0x00},
+	{0x640d, 0x14, 0x00},
+	{0x640e, 0x04, 0x00},
+	{0x640f, 0x71, 0x00},
+	{0x6410, 0x05, 0x00},
+	{0x6411, 0x74, 0x00},
+	{0x6412, 0x00, 0x00},
+	{0x6413, 0xff, 0x00},
+	{0x6414, 0x05, 0x00},
+	{0x6415, 0x54, 0x00},
+	{0x6416, 0x05, 0x00},
+	{0x6417, 0x44, 0x00},
+	{0x6418, 0x04, 0x00},
+	{0x6419, 0x30, 0x00},
+	{0x641a, 0x05, 0x00},
+	{0x641b, 0x46, 0x00},
+	{0x641c, 0x00, 0x00},
+	{0x641d, 0xff, 0x00},
+	{0x641e, 0x04, 0x00},
+	{0x641f, 0x31, 0x00},
+	{0x6420, 0x04, 0x00},
+	{0x6421, 0x30, 0x00},
+	{0x6422, 0x00, 0x00},
+	{0x6423, 0xff, 0x00},
+	{0x6424, 0x04, 0x00},
+	{0x6425, 0x20, 0x00},
+	{0x6426, 0x05, 0x00},
+	{0x6427, 0x06, 0x00},
+	{0x6428, 0x00, 0x00},
+	{0x6429, 0xff, 0x00},
+	{0x642a, 0x08, 0x00},
+	{0x642b, 0x2a, 0x00},
+	{0x642c, 0x08, 0x00},
+	{0x642d, 0x31, 0x00},
+	{0x642e, 0x00, 0x00},
+	{0x642f, 0xff, 0x00},
+	{0x6430, 0x08, 0x00},
+	{0x6431, 0x2a, 0x00},
+	{0x6432, 0x08, 0x00},
+	{0x6433, 0x31, 0x00},
+	{0x6434, 0x06, 0x00},
+	{0x6435, 0x20, 0x00},
+	{0x6436, 0x07, 0x00},
+	{0x6437, 0x00, 0x00},
+	{0x6438, 0x08, 0x00},
+	{0x6439, 0x40, 0x00},
+	{0x643a, 0x00, 0x00},
+	{0x643b, 0xff, 0x00},
+	{0x643c, 0x08, 0x00},
+	{0x643d, 0x2a, 0x00},
+	{0x643e, 0x08, 0x00},
+	{0x643f, 0x36, 0x00},
+	{0x6440, 0x06, 0x00},
+	{0x6441, 0x10, 0x00},
+	{0x6442, 0x07, 0x00},
+	{0x6443, 0x00, 0x00},
+	{0x6444, 0x08, 0x00},
+	{0x6445, 0x40, 0x00},
+	{0x6446, 0x00, 0x00},
+	{0x6447, 0xff, 0x00},
+	{0x6448, 0x08, 0x00},
+	{0x6449, 0x2a, 0x00},
+	{0x644a, 0x08, 0x00},
+	{0x644b, 0x3b, 0x00},
+	{0x644c, 0x06, 0x00},
+	{0x644d, 0x00, 0x00},
+	{0x644e, 0x07, 0x00},
+	{0x644f, 0x00, 0x00},
+	{0x6450, 0x08, 0x00},
+	{0x6451, 0x40, 0x00},
+	{0x6452, 0x00, 0x00},
+	{0x6453, 0xff, 0x00},
+	{0x6454, 0x06, 0x00},
+	{0x6455, 0x00, 0x00},
+	{0x6456, 0x07, 0x00},
+	{0x6457, 0x05, 0x00},
+	{0x6458, 0x01, 0x00},
+	{0x6459, 0xaf, 0x00},
+	{0x645a, 0x01, 0x00},
+	{0x645b, 0x0f, 0x00},
+	{0x645c, 0x01, 0x00},
+	{0x645d, 0x90, 0x00},
+	{0x645e, 0x01, 0x00},
+	{0x645f, 0xc8, 0x00},
+	{0x6460, 0x00, 0x00},
+	{0x6461, 0xff, 0x00},
+	{0x6462, 0x01, 0x00},
+	{0x6463, 0xac, 0x00},
+	{0x6464, 0x01, 0x00},
+	{0x6465, 0x0c, 0x00},
+	{0x6466, 0x01, 0x00},
+	{0x6467, 0x90, 0x00},
+	{0x6468, 0x01, 0x00},
+	{0x6469, 0xe8, 0x00},
+	{0x646a, 0x00, 0x00},
+	{0x646b, 0xff, 0x00},
+	{0x646c, 0x01, 0x00},
+	{0x646d, 0xad, 0x00},
+	{0x646e, 0x01, 0x00},
+	{0x646f, 0x0d, 0x00},
+	{0x6470, 0x01, 0x00},
+	{0x6471, 0x90, 0x00},
+	{0x6472, 0x01, 0x00},
+	{0x6473, 0xe8, 0x00},
+	{0x6474, 0x00, 0x00},
+	{0x6475, 0xff, 0x00},
+	{0x6476, 0x01, 0x00},
+	{0x6477, 0xae, 0x00},
+	{0x6478, 0x01, 0x00},
+	{0x6479, 0x0e, 0x00},
+	{0x647a, 0x01, 0x00},
+	{0x647b, 0x90, 0x00},
+	{0x647c, 0x01, 0x00},
+	{0x647d, 0xe8, 0x00},
+	{0x647e, 0x00, 0x00},
+	{0x647f, 0xff, 0x00},
+	{0x6480, 0x01, 0x00},
+	{0x6481, 0xb0, 0x00},
+	{0x6482, 0x01, 0x00},
+	{0x6483, 0xb1, 0x00},
+	{0x6484, 0x01, 0x00},
+	{0x6485, 0xb2, 0x00},
+	{0x6486, 0x01, 0x00},
+	{0x6487, 0xb3, 0x00},
+	{0x6488, 0x01, 0x00},
+	{0x6489, 0xb4, 0x00},
+	{0x648a, 0x01, 0x00},
+	{0x648b, 0xb5, 0x00},
+	{0x648c, 0x01, 0x00},
+	{0x648d, 0xb6, 0x00},
+	{0x648e, 0x01, 0x00},
+	{0x648f, 0xb7, 0x00},
+	{0x6490, 0x01, 0x00},
+	{0x6491, 0xb8, 0x00},
+	{0x6492, 0x01, 0x00},
+	{0x6493, 0xb9, 0x00},
+	{0x6494, 0x01, 0x00},
+	{0x6495, 0xba, 0x00},
+	{0x6496, 0x01, 0x00},
+	{0x6497, 0xbb, 0x00},
+	{0x6498, 0x01, 0x00},
+	{0x6499, 0xbc, 0x00},
+	{0x649a, 0x01, 0x00},
+	{0x649b, 0xbd, 0x00},
+	{0x649c, 0x01, 0x00},
+	{0x649d, 0xbe, 0x00},
+	{0x649e, 0x01, 0x00},
+	{0x649f, 0xbf, 0x00},
+	{0x64a0, 0x01, 0x00},
+	{0x64a1, 0xc0, 0x00},
+	{0x64a2, 0x00, 0x00},
+	{0x64a3, 0xff, 0x00},
+	{0x64a4, 0x06, 0x00},
+	{0x64a5, 0x00, 0x00},
+	{0x64a6, 0x01, 0x00},
+	{0x64a7, 0xf6, 0x00},
+	{0x64a8, 0x04, 0x00},
+	{0x64a9, 0x30, 0x00},
+	{0x64aa, 0x00, 0x00},
+	{0x64ab, 0xff, 0x00},
+	{0x64ac, 0x06, 0x00},
+	{0x64ad, 0x10, 0x00},
+	{0x64ae, 0x01, 0x00},
+	{0x64af, 0xf6, 0x00},
+	{0x64b0, 0x04, 0x00},
+	{0x64b1, 0x30, 0x00},
+	{0x64b2, 0x06, 0x00},
+	{0x64b3, 0x00, 0x00},
+	{0x64b4, 0x00, 0x00},
+	{0x64b5, 0xff, 0x00},
+	{0x64b6, 0x06, 0x00},
+	{0x64b7, 0x20, 0x00},
+	{0x64b8, 0x01, 0x00},
+	{0x64b9, 0xf6, 0x00},
+	{0x64ba, 0x04, 0x00},
+	{0x64bb, 0x30, 0x00},
+	{0x64bc, 0x06, 0x00},
+	{0x64bd, 0x00, 0x00},
+	{0x64be, 0x00, 0x00},
+	{0x64bf, 0xff, 0x00},
+	{0x64c0, 0x04, 0x00},
+	{0x64c1, 0x31, 0x00},
+	{0x64c2, 0x04, 0x00},
+	{0x64c3, 0x30, 0x00},
+	{0x64c4, 0x01, 0x00},
+	{0x64c5, 0x20, 0x00},
+	{0x64c6, 0x01, 0x00},
+	{0x64c7, 0x31, 0x00},
+	{0x64c8, 0x01, 0x00},
+	{0x64c9, 0x32, 0x00},
+	{0x64ca, 0x01, 0x00},
+	{0x64cb, 0x33, 0x00},
+	{0x64cc, 0x01, 0x00},
+	{0x64cd, 0x34, 0x00},
+	{0x64ce, 0x01, 0x00},
+	{0x64cf, 0x35, 0x00},
+	{0x64d0, 0x01, 0x00},
+	{0x64d1, 0x36, 0x00},
+	{0x64d2, 0x01, 0x00},
+	{0x64d3, 0x37, 0x00},
+	{0x64d4, 0x01, 0x00},
+	{0x64d5, 0x38, 0x00},
+	{0x64d6, 0x01, 0x00},
+	{0x64d7, 0x39, 0x00},
+	{0x64d8, 0x01, 0x00},
+	{0x64d9, 0x3a, 0x00},
+	{0x64da, 0x01, 0x00},
+	{0x64db, 0x3b, 0x00},
+	{0x64dc, 0x01, 0x00},
+	{0x64dd, 0x3c, 0x00},
+	{0x64de, 0x01, 0x00},
+	{0x64df, 0x3d, 0x00},
+	{0x64e0, 0x01, 0x00},
+	{0x64e1, 0x3e, 0x00},
+	{0x64e2, 0x01, 0x00},
+	{0x64e3, 0x3f, 0x00},
+	{0x64e4, 0x02, 0x00},
+	{0x64e5, 0xa0, 0x00},
+	{0x64e6, 0x00, 0x00},
+	{0x64e7, 0xff, 0x00},
+	{0x64e8, 0x04, 0x00},
+	{0x64e9, 0x31, 0x00},
+	{0x64ea, 0x04, 0x00},
+	{0x64eb, 0x30, 0x00},
+	{0x64ec, 0x01, 0x00},
+	{0x64ed, 0x00, 0x00},
+	{0x64ee, 0x01, 0x00},
+	{0x64ef, 0x11, 0x00},
+	{0x64f0, 0x01, 0x00},
+	{0x64f1, 0x12, 0x00},
+	{0x64f2, 0x01, 0x00},
+	{0x64f3, 0x13, 0x00},
+	{0x64f4, 0x01, 0x00},
+	{0x64f5, 0x14, 0x00},
+	{0x64f6, 0x01, 0x00},
+	{0x64f7, 0x15, 0x00},
+	{0x64f8, 0x01, 0x00},
+	{0x64f9, 0x16, 0x00},
+	{0x64fa, 0x01, 0x00},
+	{0x64fb, 0x17, 0x00},
+	{0x64fc, 0x01, 0x00},
+	{0x64fd, 0x18, 0x00},
+	{0x64fe, 0x01, 0x00},
+	{0x64ff, 0x19, 0x00},
+	{0x6500, 0x01, 0x00},
+	{0x6501, 0x1a, 0x00},
+	{0x6502, 0x01, 0x00},
+	{0x6503, 0x1b, 0x00},
+	{0x6504, 0x01, 0x00},
+	{0x6505, 0x1c, 0x00},
+	{0x6506, 0x01, 0x00},
+	{0x6507, 0x1d, 0x00},
+	{0x6508, 0x01, 0x00},
+	{0x6509, 0x1e, 0x00},
+	{0x650a, 0x01, 0x00},
+	{0x650b, 0x1f, 0x00},
+	{0x650c, 0x02, 0x00},
+	{0x650d, 0xa0, 0x00},
+	{0x650e, 0x00, 0x00},
+	{0x650f, 0xff, 0x00},
+	{0x6510, 0x04, 0x00},
+	{0x6511, 0x20, 0x00},
+	{0x6512, 0x05, 0x00},
+	{0x6513, 0x86, 0x00},
+	{0x6514, 0x03, 0x00},
+	{0x6515, 0x0b, 0x00},
+	{0x6516, 0x05, 0x00},
+	{0x6517, 0x86, 0x00},
+	{0x6518, 0x00, 0x00},
+	{0x6519, 0x00, 0x00},
+	{0x651a, 0x05, 0x00},
+	{0x651b, 0x06, 0x00},
+	{0x651c, 0x00, 0x00},
+	{0x651d, 0x04, 0x00},
+	{0x651e, 0x05, 0x00},
+	{0x651f, 0x04, 0x00},
+	{0x6520, 0x00, 0x00},
+	{0x6521, 0x04, 0x00},
+	{0x6522, 0x05, 0x00},
+	{0x6523, 0x00, 0x00},
+	{0x6524, 0x05, 0x00},
+	{0x6525, 0x0a, 0x00},
+	{0x6526, 0x03, 0x00},
+	{0x6527, 0x9a, 0x00},
+	{0x6528, 0x05, 0x00},
+	{0x6529, 0x86, 0x00},
+	{0x652a, 0x00, 0x00},
+	{0x652b, 0x00, 0x00},
+	{0x652c, 0x05, 0x00},
+	{0x652d, 0x06, 0x00},
+	{0x652e, 0x00, 0x00},
+	{0x652f, 0x01, 0x00},
+	{0x6530, 0x05, 0x00},
+	{0x6531, 0x04, 0x00},
+	{0x6532, 0x00, 0x00},
+	{0x6533, 0x04, 0x00},
+	{0x6534, 0x05, 0x00},
+	{0x6535, 0x00, 0x00},
+	{0x6536, 0x05, 0x00},
+	{0x6537, 0x0a, 0x00},
+	{0x6538, 0x03, 0x00},
+	{0x6539, 0x99, 0x00},
+	{0x653a, 0x05, 0x00},
+	{0x653b, 0x06, 0x00},
+	{0x653c, 0x00, 0x00},
+	{0x653d, 0x00, 0x00},
+	{0x653e, 0x05, 0x00},
+	{0x653f, 0x04, 0x00},
+	{0x6540, 0x00, 0x00},
+	{0x6541, 0x04, 0x00},
+	{0x6542, 0x05, 0x00},
+	{0x6543, 0x00, 0x00},
+	{0x6544, 0x05, 0x00},
+	{0x6545, 0x0a, 0x00},
+	{0x6546, 0x03, 0x00},
+	{0x6547, 0x98, 0x00},
+	{0x6548, 0x05, 0x00},
+	{0x6549, 0x06, 0x00},
+	{0x654a, 0x00, 0x00},
+	{0x654b, 0x00, 0x00},
+	{0x654c, 0x05, 0x00},
+	{0x654d, 0x04, 0x00},
+	{0x654e, 0x00, 0x00},
+	{0x654f, 0x04, 0x00},
+	{0x6550, 0x05, 0x00},
+	{0x6551, 0x00, 0x00},
+	{0x6552, 0x05, 0x00},
+	{0x6553, 0x0a, 0x00},
+	{0x6554, 0x03, 0x00},
+	{0x6555, 0x97, 0x00},
+	{0x6556, 0x05, 0x00},
+	{0x6557, 0x06, 0x00},
+	{0x6558, 0x05, 0x00},
+	{0x6559, 0x04, 0x00},
+	{0x655a, 0x00, 0x00},
+	{0x655b, 0x04, 0x00},
+	{0x655c, 0x05, 0x00},
+	{0x655d, 0x00, 0x00},
+	{0x655e, 0x05, 0x00},
+	{0x655f, 0x0a, 0x00},
+	{0x6560, 0x03, 0x00},
+	{0x6561, 0x96, 0x00},
+	{0x6562, 0x05, 0x00},
+	{0x6563, 0x06, 0x00},
+	{0x6564, 0x05, 0x00},
+	{0x6565, 0x04, 0x00},
+	{0x6566, 0x00, 0x00},
+	{0x6567, 0x04, 0x00},
+	{0x6568, 0x05, 0x00},
+	{0x6569, 0x00, 0x00},
+	{0x656a, 0x05, 0x00},
+	{0x656b, 0x0a, 0x00},
+	{0x656c, 0x03, 0x00},
+	{0x656d, 0x95, 0x00},
+	{0x656e, 0x05, 0x00},
+	{0x656f, 0x06, 0x00},
+	{0x6570, 0x05, 0x00},
+	{0x6571, 0x04, 0x00},
+	{0x6572, 0x00, 0x00},
+	{0x6573, 0x04, 0x00},
+	{0x6574, 0x05, 0x00},
+	{0x6575, 0x00, 0x00},
+	{0x6576, 0x05, 0x00},
+	{0x6577, 0x0a, 0x00},
+	{0x6578, 0x03, 0x00},
+	{0x6579, 0x94, 0x00},
+	{0x657a, 0x05, 0x00},
+	{0x657b, 0x06, 0x00},
+	{0x657c, 0x00, 0x00},
+	{0x657d, 0x00, 0x00},
+	{0x657e, 0x05, 0x00},
+	{0x657f, 0x04, 0x00},
+	{0x6580, 0x00, 0x00},
+	{0x6581, 0x04, 0x00},
+	{0x6582, 0x05, 0x00},
+	{0x6583, 0x00, 0x00},
+	{0x6584, 0x05, 0x00},
+	{0x6585, 0x0a, 0x00},
+	{0x6586, 0x03, 0x00},
+	{0x6587, 0x93, 0x00},
+	{0x6588, 0x05, 0x00},
+	{0x6589, 0x06, 0x00},
+	{0x658a, 0x00, 0x00},
+	{0x658b, 0x00, 0x00},
+	{0x658c, 0x05, 0x00},
+	{0x658d, 0x04, 0x00},
+	{0x658e, 0x00, 0x00},
+	{0x658f, 0x04, 0x00},
+	{0x6590, 0x05, 0x00},
+	{0x6591, 0x00, 0x00},
+	{0x6592, 0x05, 0x00},
+	{0x6593, 0x0a, 0x00},
+	{0x6594, 0x03, 0x00},
+	{0x6595, 0x92, 0x00},
+	{0x6596, 0x05, 0x00},
+	{0x6597, 0x06, 0x00},
+	{0x6598, 0x05, 0x00},
+	{0x6599, 0x04, 0x00},
+	{0x659a, 0x00, 0x00},
+	{0x659b, 0x04, 0x00},
+	{0x659c, 0x05, 0x00},
+	{0x659d, 0x00, 0x00},
+	{0x659e, 0x05, 0x00},
+	{0x659f, 0x0a, 0x00},
+	{0x65a0, 0x03, 0x00},
+	{0x65a1, 0x91, 0x00},
+	{0x65a2, 0x05, 0x00},
+	{0x65a3, 0x06, 0x00},
+	{0x65a4, 0x05, 0x00},
+	{0x65a5, 0x04, 0x00},
+	{0x65a6, 0x00, 0x00},
+	{0x65a7, 0x04, 0x00},
+	{0x65a8, 0x05, 0x00},
+	{0x65a9, 0x00, 0x00},
+	{0x65aa, 0x05, 0x00},
+	{0x65ab, 0x0a, 0x00},
+	{0x65ac, 0x03, 0x00},
+	{0x65ad, 0x90, 0x00},
+	{0x65ae, 0x05, 0x00},
+	{0x65af, 0x06, 0x00},
+	{0x65b0, 0x05, 0x00},
+	{0x65b1, 0x04, 0x00},
+	{0x65b2, 0x00, 0x00},
+	{0x65b3, 0x04, 0x00},
+	{0x65b4, 0x05, 0x00},
+	{0x65b5, 0x00, 0x00},
+	{0x65b6, 0x05, 0x00},
+	{0x65b7, 0x0a, 0x00},
+	{0x65b8, 0x02, 0x00},
+	{0x65b9, 0x90, 0x00},
+	{0x65ba, 0x05, 0x00},
+	{0x65bb, 0x06, 0x00},
+	{0x65bc, 0x00, 0x00},
+	{0x65bd, 0xff, 0x00},
+	{0x65be, 0x04, 0x00},
+	{0x65bf, 0x70, 0x00},
+	{0x65c0, 0x08, 0x00},
+	{0x65c1, 0x76, 0x00},
+	{0x65c2, 0x00, 0x00},
+	{0x65c3, 0xff, 0x00},
+	{0x65c4, 0x08, 0x00},
+	{0x65c5, 0x76, 0x00},
+	{0x65c6, 0x04, 0x00},
+	{0x65c7, 0x0c, 0x00},
+	{0x65c8, 0x05, 0x00},
+	{0x65c9, 0x07, 0x00},
+	{0x65ca, 0x04, 0x00},
+	{0x65cb, 0x04, 0x00},
+	{0x65cc, 0x00, 0x00},
+	{0x65cd, 0xff, 0x00},
+	{0x65ce, 0x00, 0x00},
+	{0x65cf, 0xff, 0x00},
+	{0x65d0, 0x00, 0x00},
+	{0x65d1, 0xff, 0x00},
+	{0x3037, 0x71, 0x00},
+	{0x303a, 0x04, 0x00},
+	{0x303b, 0x7f, 0x00},
+	{0x303c, 0xfe, 0x00},
+	{0x303d, 0x19, 0x00},
+	{0x303e, 0xd7, 0x00},
+	{0x303f, 0x09, 0x00},
+	{0x3040, 0x78, 0x00},
+	{0x3042, 0x05, 0x00},
+	{0x328a, 0x10, 0x00},
+	{0x328a, 0x00, 0x00},
+	{0x31be, 0x03, 0x00},
+	{0x31bf, 0x9f, 0x00},
+	{0x31c0, 0xff, 0x00},
+	{0x3133, 0xb7, 0x00},
+	{0x3134, 0xca, 0x00},
+	{0x3135, 0xcc, 0x00},
+	{0x3012, 0x01, 0x00},
+	{0x3012, 0x00, 0x00},
+	{0x3000, 0x03, 0x00},
+	{0x3001, 0x49, 0x00},
+	{0x3002, 0x07, 0x00},
+	{0x3004, 0x03, 0x00},
+	{0x3005, 0x44, 0x00},
+	{0x3006, 0x07, 0x00},
+	{0x308f, 0x10, 0x00},
+	{0x3127, 0x63, 0x00},
+	{0x3074, 0x00, 0x00},
+	{0x3075, 0x00, 0x00},
+	{0x3076, 0x00, 0x00},
+/*{0x3077, 0xB6 , 0x00},    */
+	{0x3077, 0x02, 0x00},
+	{0x3078, 0x05, 0x00},
+	{0x3079, 0x07, 0x00},
+	{0x307a, 0x04, 0x00},
+	{0x307b, 0x41, 0x00},
+	{0x307c, 0x05, 0x00},
+	{0x307d, 0x00, 0x00},
+	{0x307e, 0x04, 0x00},
+	{0x307f, 0x38, 0x00},
+	{0x3080, 0x05, 0x00},
+	{0x3081, 0xc8, 0x00},
+	{0x3082, 0x06, 0x00},
+	{0x3083, 0x82, 0x00},
+	{0x3084, 0x00, 0x00},
+	{0x3085, 0x04, 0x00},
+	{0x3086, 0x00, 0x00},
+	{0x3087, 0x04, 0x00},
+	{0x346d, 0x1D, 0x00},
+	{0x3444, 0x48, 0x00},
+
+	/* /\* hdr mode *\/ */
+	/* /\* GJR: odd, this register is set to 0x55 above *\/ */
+	/* {0x3119, 0x54, 0x00}, */
+
+	/* linear mode */
+	{0x3119, 0x55, 0x00},	    /* long exposure only */
+
+	/* expo_calc_ctrl 1 & 2: all auto, ex dgain */
+	{0x7001, 0xff, 0x00},
+	{0x7000, 0x3f, 0x00},
+	{0x7003, 0xbf, 0x00},
+	{0x7002, 0xff, 0x00},
+	/* long test targets */
+	{0x7004, 0x13, 0x00},
+	{0x7005, 0xec, 0x00},
+	{0x7006, 0x0e, 0x00},
+	{0x7007, 0xf1, 0x00},
+	{0x7008, 0x13, 0x00},
+	{0x7009, 0xec, 0x00},
+	{0x700A, 0x27, 0x00},
+	{0x700B, 0xd8, 0x00},
+	{0x700e, 0x00, 0x00},
+	{0x700f, 0xff, 0x00},
+	/* short test targets */
+	{0x701a, 0x13, 0x00},
+	{0x701b, 0xec, 0x00},
+	{0x701c, 0x0e, 0x00},
+	{0x701d, 0xf1, 0x00},
+	{0x701e, 0x13, 0x00},
+	{0x701f, 0xec, 0x00},
+	{0x7020, 0x27, 0x00},
+	{0x7021, 0xd8, 0x00},
+	{0x7024, 0x00, 0x00},
+	{0x7025, 0xff, 0x00},
+/* Absolute minimum value for analog gain */
+	{0x7048, 0x00, 0x00},
+	{0x7049, 0x01, 0x00},
+/* long dgain 1.33x */
+	{0x704a, 0x03, 0x00},
+	{0x704b, 0x00, 0x00},
+	{0x704c, 0x01, 0x00},
+	{0x704d, 0x40, 0x00},
+/* short gain min 2.0, dgain 1x */
+	{0x7084, 0x01, 0x00},
+	{0x7085, 0x02, 0x00},
+	{0x7086, 0x03, 0x00},
+	{0x7087, 0x00, 0x00},
+	{0x7088, 0x01, 0x00},
+	{0x7089, 0x40, 0x00},
+/* very short, dgain 1.333  */
+	{0x70c0, 0x00, 0x00},
+	{0x70c1, 0x03, 0x00},
+	{0x70c2, 0x03, 0x00},
+	{0x70c3, 0x00, 0x00},
+	{0x70c4, 0x01, 0x00},
+	{0x70c5, 0x40, 0x00},
+/* long exp */
+	{0x7042, 0x00, 0x00},
+	{0x7043, 0x03, 0x00},
+	{0x7040, 0x3c, 0x00},
+	{0x7041, 0x00, 0x00},
+	{0x7046, 0x00, 0x00},
+	{0x7047, 0x00, 0x00},
+	{0x7044, 0x04, 0x00},
+	{0x7045, 0x00, 0x00},
+/* short */
+	{0x707e, 0x00, 0x00},
+	{0x707f, 0x02, 0x00},
+	{0x707c, 0xe0, 0x00},
+	{0x707d, 0x00, 0x00},
+	{0x7082, 0x00, 0x00},
+	{0x7083, 0x00, 0x00},
+	{0x7080, 0x04, 0x00},
+	{0x7081, 0x00, 0x00},
+/* very short */
+	{0x70ba, 0x00, 0x00},
+	{0x70bb, 0x00, 0x00},
+	{0x70b8, 0x03, 0x00},
+	{0x70b9, 0xf8, 0x00},
+	{0x70be, 0x00, 0x00},
+	{0x70bf, 0x00, 0x00},
+	{0x70bc, 0x00, 0x00},
+	{0x70bd, 0x80, 0x00},
+/* absolute  max long/short = 16 */
+	{0x70e6, 0x00, 0x00},
+	{0x70e7, 0x00, 0x00},
+	{0x70e4, 0x10, 0x00},
+	{0x70e5, 0x00, 0x00},
+/* absolute min long/short = 8 */
+	{0x70ea, 0x00, 0x00},
+	{0x70eb, 0x00, 0x00},
+	{0x70e8, 0x08, 0x00},
+	{0x70e9, 0x00, 0x00},
+/* absolute max long/very short = 256 */
+	{0x70ee, 0x00, 0x00},
+	{0x70ef, 0x01, 0x00},
+	{0x70ec, 0x00, 0x00},
+	{0x70ed, 0x00, 0x00},
+/* absolute min long/very short = 256 */
+	{0x70f2, 0x00, 0x00},
+	{0x70f3, 0x00, 0x00},
+	{0x70f0, 0xff, 0x00},
+	{0x70f1, 0x00, 0x00},
+/* PD ratio  x6.5 */
+	{0x30FB, 0x6 , 0x00},
+	{0x30FC, 0x80, 0x00},
+/* CG ratio 2.57 */
+	{0x30FD, 0x2 , 0x00},
+	{0x30FE, 0x93, 0x00},
+	{0x313c, 0x20, 0x00},
+	{0x313f, 0x80, 0x00},
+	{0x3140, 0x10, 0x00},
+	{0x3127, 0x63, 0x00},     /* enable ISP */
+/* {0x30fa, 0x56, 0x00},    enable AEC */
+	{0x30fa, 0x16, 0x00},    /*disable AEC */
+	{0x328A, 0x00, 0x00},
+	{0x704A, 0x08, 0x00},
+	{0x4000, 0x00, 0x00},
+	{0x4001, 0x00, 0x00},
+	{0x4002, 0x00, 0x00},
+	{0x4003, 0x00, 0x00},
+	{0x4004, 0x03, 0x00},
+	{0x4005, 0x20, 0x00},
+	{0x4006, 0x05, 0x00},
+	{0x4007, 0x00, 0x00},
+	{0x4008, 0x16, 0x00},
+};
+const size_t mode_1280x1080long_len = ARRAY_SIZE(mode_1280x1080long);
+
+const struct reg_sequence mode_stream[] = {
+	{0x3012, 0x01, 0},
+	{0x3129, 0x00, 10},
+};
+const size_t mode_stream_len = ARRAY_SIZE(mode_stream);
+
+
+const struct reg_table mode_table[] = {
+	[OV10640_MODE_1280X1080_LONG] = {
+		.reg_sequence = mode_1280x1080long,
+		.size = ARRAY_SIZE(mode_1280x1080long)
+	},
+#ifdef CONFIG_D3_OV10640_HDR_ENABLE
+	[OV10640_MODE_1280X1080_HDR] = {
+		.reg_sequence = mode_1280x1080hdr,
+		.size = ARRAY_SIZE(mode_1280x1080hdr)
+	},
+#endif	/* CONFIG_D3_OV10640_HDR_ENABLE */
+};
+const size_t mode_table_len = ARRAY_SIZE(mode_table);
+
+const int mode_1280x1080_fps[] = { 30 };
+
+
+/**
+ * Mode table as expected by Nvidia's camera_common framework
+ */
+const struct camera_common_frmfmt ov10640_formats[] = {
+	{
+		.size = {1280, 1080},
+		.framerates = mode_1280x1080_fps,
+		.num_framerates = ARRAY_SIZE(mode_1280x1080_fps),
+		.hdr_en = 0,
+		.mode = OV10640_MODE_1280X1080_LONG,
+	},
+#ifdef CONFIG_D3_OV10640_HDR_ENABLE
+	{
+		.size = {1280, 1080},
+		.framerates = mode_1280x1080_fps,
+		.num_framerates = ARRAY_SIZE(mode_1280x1080_fps),
+		.hdr_en = 1,
+		.mode = OV10640_MODE_1280X1080_HDR,
+	},
+#endif /* CONFIG_D3_OV10640_HDR_ENABLE */
+};
+const size_t ov10640_formats_len = ARRAY_SIZE(ov10640_formats);
+
diff --git a/drivers/d3/ov10640/ov10640_tables.h b/drivers/d3/ov10640/ov10640_tables.h
new file mode 100644
index 000000000000..361afe0e286f
--- /dev/null
+++ b/drivers/d3/ov10640/ov10640_tables.h
@@ -0,0 +1,66 @@
+/**
+ * @author Greg Rowe <growe@d3engineering.com>
+ *
+ * ov10640 v4l2 driver for Nvidia Jetson - default register settings
+ *
+ * Copyright (c) 2019, D3 Engineering.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+#ifndef _OV10640_TABLES_H
+#define _OV10640_TABLES_H
+
+#include <linux/kernel.h>
+#include <media/camera_common.h>
+
+enum {
+	OV10640_MODE_1280X1080_LONG,
+#ifdef CONFIG_D3_OV10640_HDR_ENABLE
+	OV10640_MODE_1280X1080_HDR,
+#endif /* CONFIG_D3_OV10640_HDR_ENABLE */
+	OV10640_MODE_END,
+	OV10640_MODE_DEFAULT = OV10640_MODE_1280X1080_LONG
+};
+
+struct reg_table {
+	const struct reg_sequence *reg_sequence;
+	size_t size;
+};
+
+
+#ifdef CONFIG_D3_OV10640_HDR_ENABLE
+extern const struct reg_sequence mode_1280x1080hdr[];
+extern const size_t mode_1280x1080hdr_len;
+#endif /* CONFIG_D3_OV10640_HDR_ENABLE */
+extern const struct reg_sequence mode_1280x1080long[];
+extern const size_t mode_1280x1080long_len;
+extern const struct reg_sequence mode_stream[];
+extern const size_t mode_stream_len;
+extern const struct reg_sequence mode_60fps[];
+extern const size_t mode_60fps_len;
+
+
+extern const struct reg_table mode_table[];
+extern const size_t mode_table_len;
+
+extern const int mode_1280x1080_fps[];
+extern const size_t mode_1280x1080_fps_len;
+
+
+/**
+ * Mode table as expected by Nvidia's camera_common framework
+ */
+extern const struct camera_common_frmfmt ov10640_formats[];
+extern const size_t ov10640_formats_len;
+
+#endif
diff --git a/drivers/d3/overlay-loader/Kconfig b/drivers/d3/overlay-loader/Kconfig
new file mode 100644
index 000000000000..71f7f9e4d354
--- /dev/null
+++ b/drivers/d3/overlay-loader/Kconfig
@@ -0,0 +1,4 @@
+config D3_OVERLAY_LOADER
+	bool "Overlay Loader"
+	help
+	  D3 A driver that will apply device tree based on kernel parameters.
diff --git a/drivers/d3/overlay-loader/Makefile b/drivers/d3/overlay-loader/Makefile
new file mode 100644
index 000000000000..c5c0f596a307
--- /dev/null
+++ b/drivers/d3/overlay-loader/Makefile
@@ -0,0 +1,3 @@
+# -*-makefile-*-
+obj-$(CONFIG_D3_OVERLAY_LOADER) += overlay-loader.o
+
diff --git a/drivers/d3/overlay-loader/overlay-loader.c b/drivers/d3/overlay-loader/overlay-loader.c
new file mode 100644
index 000000000000..352f03c5dc95
--- /dev/null
+++ b/drivers/d3/overlay-loader/overlay-loader.c
@@ -0,0 +1,794 @@
+/*
+ * Copyright (c) 2015-2016, NVIDIA CORPORATION.  All rights reserved.
+ * Author: Laxman Dewangan <ldewangan@nvidia.com>
+ *
+ * Copyright (c) 2019, D3 Engineering  All rights reserved.
+ * Author: Tyler Hart <thart@d3engineering.com>
+ * Author: Christopher White <cwhite@d3engineering.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/spinlock.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <linux/proc_fs.h>
+#include <linux/of.h>
+#include <linux/of_fdt.h>
+#include <d3/of_private.h>
+
+#ifdef CONFIG_D3_CONFIG_EEPROM
+#include <d3/config-eeprom.h>
+#endif
+
+#define MODULE_NAME "overlay-loader"
+
+#define MAXIMUM_FNAME_LENGTH		300
+#define KERN_PARAM_NAME			"active_overlays="
+#define DEVICETREE_PROPERTY_NAME	"active_overlays"
+
+/**
+ * struct kparam_element - node of a linked list holding strings
+ * @value: A pointer to a string, allocated using kmalloc or kzalloc
+ * @next: The next-element pointer
+ */
+
+struct kparam_element
+{
+	char* value;
+	struct kparam_element *next;
+};
+
+/**
+ * free_kparam_element - free a struct kparam_element and its contained string
+ * @kpe: The element to free, or NULL
+ */
+
+void free_kparam_element(struct kparam_element *kpe)
+{
+	if (!kpe)
+		return;
+
+	kfree(kpe->value);
+	kfree(kpe);
+}
+
+/**
+ * free_kparam_list - free a full linked list of struct kparam_element
+ * @kpe: The head of the list to free, or NULL
+ *
+ * This free @kpe and all following elements.
+ */
+
+void free_kparam_list(struct kparam_element *kpe)
+{
+	struct kparam_element *kpe_next;
+	while (kpe != NULL) {
+		kpe_next = kpe->next;
+		free_kparam_element(kpe);
+		kpe = kpe_next;
+	}
+}
+
+static struct property *__of_copy_property(const struct property *prop,
+					   void *new_value, int val_len,
+					   gfp_t flags)
+{
+	struct property *propn;
+	int nlen;
+	void *nval;
+
+	propn = kzalloc(sizeof(*propn), flags);
+	if (!propn)
+		return NULL;
+
+	propn->name = kstrdup(prop->name, flags);
+	if (!propn->name)
+		goto err_fail_name;
+
+	nlen = (new_value) ? val_len : prop->length;
+	nval = (new_value) ? new_value : prop->value;
+	if (nlen > 0) {
+		propn->value = kzalloc(nlen, flags);
+		if (!propn->value)
+			goto err_fail_value;
+		memcpy(propn->value, nval, nlen);
+		propn->length = nlen;
+	}
+	return propn;
+
+err_fail_value:
+	kfree(propn->name);
+err_fail_name:
+	kfree(propn);
+	return NULL;
+}
+
+
+static void free_property(struct property *pp)
+{
+	if (!pp)
+		return;
+
+	kfree(pp->name);
+	kfree(pp->value);
+	kfree(pp);
+}
+
+static struct device_node *of_get_child_by_last_name(struct device_node *node,
+						     const char *name)
+{
+	struct device_node *child;
+
+	for_each_child_of_node(node, child) {
+		const char *lname = strrchr(child->full_name, '/');
+
+		if (!strcmp(lname + 1, name))
+			return child;
+	}
+
+	return NULL;
+}
+
+
+struct device_node *create_simple_device_node_ol(const char *path,
+					      const char *add_name,
+					      size_t data_size)
+{
+	struct device_node *new_np;
+
+	new_np = kzalloc(sizeof(*new_np), GFP_KERNEL);
+	if (!new_np)
+		return NULL;
+
+	new_np->full_name = kasprintf(GFP_KERNEL, "%s/%s", path, add_name);
+	new_np->name = kasprintf(GFP_KERNEL, "%s", add_name);
+
+	if (data_size) {
+		new_np->data = kzalloc(data_size, GFP_KERNEL);
+		if (!new_np->data)
+			goto clean;
+	}
+
+	return new_np;
+
+clean:
+	kfree(new_np->full_name);
+	kfree(new_np->name);
+	kfree(new_np);
+	return NULL;
+}
+
+
+struct device_node *duplicate_single_node_ol(struct device_node *np,
+					  const char *base_dir,
+					  const char *path,
+					  const char *new_name)
+{
+	struct device_node *dup;
+	struct property *pp, *new_pp;
+	int ret;
+	const char *add_name;
+	char fname[MAXIMUM_FNAME_LENGTH + 1] = {};
+
+	dup = kzalloc(sizeof(*dup), GFP_KERNEL);
+	if (!dup)
+		return NULL;
+
+	if (new_name) {
+		add_name = new_name;
+	} else {
+		add_name = strrchr(np->full_name, '/');
+		add_name++;
+	}
+
+	if (path) {
+		strncpy(fname, path, MAXIMUM_FNAME_LENGTH);
+	} else {
+		const char *lname = strrchr(np->full_name, '/');
+		int llen = strlen(np->full_name) - strlen(lname);
+
+		strncpy(fname, np->full_name, MAXIMUM_FNAME_LENGTH);
+		fname[llen] = '\0';
+	}
+
+	if (base_dir)
+		dup->full_name = kasprintf(GFP_KERNEL, "%s%s/%s",
+					   base_dir, fname, add_name);
+	else
+		dup->full_name = kasprintf(GFP_KERNEL, "%s/%s",
+					   fname, add_name);
+
+	of_node_init(dup);
+
+	for_each_property_of_node(np, pp) {
+		if (!strcmp(pp->name, "name"))
+			new_pp = __of_copy_property(pp, (void *)add_name,
+						    strlen(add_name),
+						    GFP_KERNEL);
+		else
+			new_pp = __of_copy_property(pp, NULL, 0, GFP_KERNEL);
+		if (!new_pp) {
+			kfree(dup->full_name);
+			kfree(dup);
+			return NULL;
+		}
+
+		ret = of_add_property(dup, new_pp);
+		if (ret < 0) {
+			pr_err("Prop %s can not be added on node %s\n",
+			       new_pp->name, dup->full_name);
+			free_property(new_pp);
+			kfree(dup->full_name);
+			kfree(dup);
+			return NULL;
+		}
+	}
+
+	dup->name = __of_get_property(dup, "name", NULL) ? : "<NULL>";
+	dup->type = __of_get_property(dup, "device_type", NULL) ? : "<NULL>";
+
+	return dup;
+}
+
+struct device_node *get_copy_of_node_ol(struct device_node *np,
+				     const char *base_dir,
+				     const char *path, const char *new_name)
+{
+	struct device_node *dup;
+	struct device_node *child, *child_dup;
+	struct device_node *prev_child = NULL;
+
+	dup = duplicate_single_node_ol(np, base_dir, path, new_name);
+	if (!dup)
+		return NULL;
+
+	for_each_child_of_node(np, child) {
+		child_dup = get_copy_of_node_ol(child, NULL, dup->full_name, NULL);
+		if (!child_dup) {
+			kfree(dup);
+			return NULL;
+		}
+		child_dup->parent = dup;
+		child_dup->sibling = NULL;
+		if (!prev_child)
+			dup->child = child_dup;
+		else
+			prev_child->sibling = child_dup;
+		prev_child = child_dup;
+	}
+
+	return dup;
+}
+
+
+static struct property *__of_string_append(struct device_node *target,
+					   struct property *prop)
+{
+	struct property *new_prop, *tprop;
+	const char *tprop_name, *curr_str;
+	int slen, tlen, lenp;
+
+	tprop_name = of_prop_next_string(prop, NULL);
+	if (!tprop_name)
+		return NULL;
+
+	new_prop = kzalloc(sizeof(*new_prop), GFP_KERNEL);
+	if (!new_prop)
+		return NULL;
+
+	new_prop->name = kstrdup(tprop_name, GFP_KERNEL);
+	if (!new_prop->name)
+		goto err_fail_name;
+
+	curr_str = of_prop_next_string(prop, tprop_name);
+	for (slen = 0; curr_str; curr_str = of_prop_next_string(prop, curr_str))
+		slen += strlen(curr_str);
+
+	tprop = of_find_property(target, tprop_name, &lenp);
+	tlen = (tprop) ? tprop->length : 0;
+
+	new_prop->value = kmalloc(slen + tlen, GFP_KERNEL);
+	if (!new_prop->value)
+		goto err_fail_value;
+
+	if (tlen)
+		memcpy(new_prop->value, tprop->value, tlen);
+
+	if (slen) {
+		curr_str = of_prop_next_string(prop, tprop_name);
+		memcpy(new_prop->value + tlen, curr_str, slen);
+	}
+
+	new_prop->length = slen + tlen;
+
+	return new_prop;
+
+err_fail_value:
+	kfree(new_prop->name);
+err_fail_name:
+	kfree(new_prop);
+
+	return NULL;
+}
+
+static int do_property_override_from_overlay(struct device_node *target,
+					     struct device_node *overlay)
+{
+	struct property *prop;
+	struct property *tprop;
+	struct property *new_prop;
+	const char *pval;
+	int lenp = 0;
+	int ret;
+
+	pr_debug("Update properties from %s to %s\n", overlay->full_name,
+		 target->full_name);
+
+	for_each_property_of_node(overlay, prop) {
+		/* Skip those we do not want to proceed */
+		if (!strcmp(prop->name, "name") ||
+			!strcmp(prop->name, "phandle") ||
+			!strcmp(prop->name, "linux,phandle"))
+				continue;
+		if (!strcmp(prop->name, "delete-target-property")) {
+			if (prop->length <= 0)
+				continue;
+			pval = (const char *)prop->value;
+			pr_info("Removing Prop %s from target %s\n",
+				pval, target->full_name);
+			tprop = of_find_property(target, pval, &lenp);
+			if (tprop)
+				of_remove_property(target, tprop);
+			continue;
+		}
+
+		if (!strcmp(prop->name, "append-string-property")) {
+			if (prop->length <= 0)
+				continue;
+
+			new_prop = __of_string_append(target, prop);
+			if (!new_prop) {
+				pr_err("Prop %s can not be appended\n",
+					of_prop_next_string(prop, NULL));
+				return -EINVAL;
+			}
+			goto add_prop;
+		}
+
+		new_prop = __of_copy_property(prop, NULL, 0, GFP_KERNEL);
+		if (!new_prop) {
+			pr_err("Prop %s can not be duplicated\n",
+				prop->name);
+			return -EINVAL;
+		}
+
+add_prop:
+		tprop = of_find_property(target, new_prop->name, &lenp);
+		if (!tprop) {
+			ret = of_add_property(target, new_prop);
+			if (ret < 0) {
+				pr_err("Prop %s can not be added on node %s\n",
+					new_prop->name, target->full_name);
+				goto cleanup;
+			}
+		} else {
+			ret = of_update_property(target, new_prop);
+			if (ret < 0) {
+				pr_err("Prop %s can not be updated on node %s\n",
+					new_prop->name, target->full_name);
+				goto cleanup;
+			}
+		}
+	}
+
+	return 0;
+
+cleanup:
+	free_property(new_prop);
+	return ret;
+}
+
+
+static int do_property_overrides(struct device_node *target,
+				 struct device_node *overlay)
+{
+	struct device_node *tchild, *ochild;
+	const char *address_name;
+	int ret;
+
+	ret = do_property_override_from_overlay(target, overlay);
+	if (ret < 0) {
+		pr_err("Target %s update with overlay %s failed: %d\n",
+			target->name, overlay->name, ret);
+		return ret;
+	}
+
+	for_each_child_of_node(overlay, ochild) {
+		address_name = strrchr(ochild->full_name, '/');
+		tchild = of_get_child_by_last_name(target, address_name + 1);
+		if (!tchild) {
+			pr_err("Overlay node %s not found in target node %s\n",
+				ochild->full_name, target->full_name);
+			continue;
+		}
+		ret = do_property_overrides(tchild, ochild);
+		if (ret < 0) {
+			pr_err("Target %s update with overlay %s failed: %d\n",
+				tchild->name, ochild->name, ret);
+			return ret;
+		}
+	}
+	return 0;
+}
+
+static int handle_properties_overrides(struct device_node *np,
+				       struct device_node *target)
+{
+	struct device_node *overlay;
+	int ret;
+
+	if (!target) {
+		target = of_parse_phandle(np, "target", 0);
+		if (!target) {
+			pr_err("Node %s does not have target node\n",
+				np->name);
+			return -EINVAL;
+		}
+	}
+
+	overlay = of_get_child_by_name(np, "_overlay_");
+	if (!overlay) {
+		pr_err("Node %s does not have Overlay\n", np->name);
+		return -EINVAL;
+	}
+
+	ret = do_property_overrides(target, overlay);
+	if (ret < 0) {
+		pr_err("Target %s update with overlay %s failed: %d\n",
+			target->name, overlay->name, ret);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/**
+ * parse_parameters() - parse a string of overlay IDs into a linked list
+ * @input_k_elem: where the return value should be stored
+ * @kparam_start: the text to parse, terminated by \0 or a space (\x20).
+ * 			This text does not include any `active_overlays=`
+ * 			or other introductory text.
+ *
+ * Parses a comma-separated list of strings, e.g., "foo_0,bar_1".  Each
+ * comma-separated item is placed in its own linked-list node.
+ *
+ * Return: 0 on success; a negated error code on failure.
+ */
+
+static int parse_parameters(struct kparam_element **input_k_elem,
+		const char* kparam_start)
+{
+
+	struct kparam_element *cur_k_elem;
+	struct kparam_element *new_k_elem;
+	const char *kparam_end;
+	int kparam_len;
+	bool elem_end;
+	bool params_end;
+
+	// find param values
+	kparam_end = kparam_start;
+	cur_k_elem = NULL;
+	pr_debug(MODULE_NAME ": Parsing params: >>%s<<\n", kparam_start);
+
+	while (1) {
+		params_end = (*kparam_end == '\0' || *kparam_end == ' ');
+		elem_end = (params_end || *kparam_end == ',');
+		if (elem_end) {
+			kparam_len = strlen(kparam_start) - strlen(kparam_end);
+			// manage linked list
+			new_k_elem = kzalloc(sizeof(*(cur_k_elem->next)),
+					GFP_KERNEL);
+			new_k_elem->next = cur_k_elem;
+			cur_k_elem = new_k_elem;
+			cur_k_elem->value = kzalloc(sizeof(char) *
+					(kparam_len + 1), GFP_KERNEL);
+			strncpy(cur_k_elem->value, kparam_start, kparam_len);
+			pr_debug(MODULE_NAME ":    found element %s\n", cur_k_elem->value);
+			// move start pointer over separator char
+			kparam_start = kparam_end;
+			kparam_start++;
+		}
+		if (params_end)
+			break;
+		kparam_end++;
+	}
+	pr_debug(MODULE_NAME ": Done parsing params\n");
+
+	// verify param values exist
+	if (!cur_k_elem)
+		return -EINVAL;
+	*input_k_elem = cur_k_elem;
+	return 0;
+}
+
+/**
+ * get_kernel_parameters() - extract active_overlays values from the kernel command line.
+ * @input_k_elem: where the return value should be stored.
+ * @param_name: the name of the command-line parameter to check
+ *
+ * Parses the kernel command line to locate the names of any overlays
+ * that should be activated.  Fills in @input_k_elem with a pointer to the
+ * head of a linked list of results if successful.
+ *
+ * Return: 0 on success; a negated error code on failure.
+ */
+
+static int get_kernel_parameters(struct kparam_element **input_k_elem,
+		const char* param_name)
+{
+	char *kparam_start;
+
+	kparam_start = saved_command_line;
+	*input_k_elem = NULL;
+
+	// find start of parameter
+	while (strlen(param_name) <= strlen(kparam_start)
+			&& strncmp(param_name, kparam_start,
+			strlen(param_name))) {
+		kparam_start++;
+	}
+
+	// verify param name exists
+	if (strncmp(param_name, kparam_start, strlen(param_name)) != 0)
+		return -EINVAL;
+
+	// Increment past param name
+	kparam_start += strlen(param_name);
+
+	return parse_parameters(input_k_elem, kparam_start);
+}
+
+/**
+ * get_dt_parameters() - extract active_overlays values from the device tree
+ * @input_k_elem: where the return value should be stored.
+ * @np: the device-tree node including an active_overlays property
+ *  	(e.g., /overlay-loader)
+ *
+ * Parses the kernel command line to locate the names of any overlays
+ * that should be activated.  Fills in @input_k_elem with a pointer to the
+ * head of a linked list of results if successful.
+ *
+ * Return: 0 on success; a negated error code on failure.
+ */
+
+static int get_dt_parameters(struct kparam_element **input_k_elem,
+		struct device_node *np)
+{
+	const char *prop;
+	prop = of_get_property(np, DEVICETREE_PROPERTY_NAME, NULL);
+	if (!prop)
+		return -EINVAL;
+	return parse_parameters(input_k_elem, prop);
+}
+
+#ifdef CONFIG_D3_CONFIG_EEPROM
+
+/**
+ * get_config_eeprom_parameters() - extract active_overlays values from the
+ * 					config-eeprom
+ * @input_k_elem: where the return value should be stored.
+ *
+ * If there is any configuration-eeprom data loaded, parses it to locate the
+ * names of any overlays that should be activated.  Fills in @input_k_elem with
+ * a pointer to the head of a linked list of results if successful.
+ *
+ * Return:
+ *
+ * - On success with data, returns 0 and fills in *@input_k_elem.
+ *
+ * - On success with no data, returns 0 and sets *@input_k_elem = NULL.
+ *
+ * - On error, returns a negated error code and sets *@input_k_elem = NULL.
+ */
+
+static int get_config_eeprom_parameters(struct kparam_element **input_k_elem)
+{
+	struct config_eeprom_data *data;
+	static bool already_reported = false;
+	*input_k_elem = NULL;
+
+	data = config_eeprom_get_data();
+	if(!data) {
+		if(!already_reported)
+			pr_info(MODULE_NAME ": No config-eeprom data");
+		already_reported = true;
+		return -ENODEV;
+	}
+
+	// Basic overrun guard - TODO replace this with more robust code
+	data->overlay_loader_params[CONFIG_EEPROM_DATA_SIZE-1] = '\0';
+
+	return parse_parameters(input_k_elem, data->overlay_loader_params);
+}
+
+#endif // CONFIG_D3_CONFIG_EEPROM
+
+/**
+ * check_for_active_overlay - check whether an overlay name is active
+ * @kparams_ptr: pointer to linked list of which overlays are active
+ * @np: the device-tree node of this fragment (/overlay-loader/<fragment>)
+ * @source: text naming the source of @kparams, for logging.
+ *
+ * This traverses @kparams and, for each kparam, checks whether @np
+ * is active for the respective value.
+ *
+ * If @kparams_ptr, @np, and @source are all non-NULL, all nodes in
+ * @kparams are freed by this function, and *@kparams_ptr is set to NULL.
+ *
+ * Return: false on parameter error; whether or not the overlay is active,
+ * otherwise.
+ */
+
+static bool check_for_active_overlay(struct kparam_element **kparams_ptr,
+		struct device_node *np, const char *source)
+{
+	struct kparam_element *kparams;
+	struct property *prop;
+	const char *bname;
+	struct kparam_element *last_param = NULL;
+	bool found = false;
+
+	if(!kparams_ptr || !np || !source)
+		return false;
+
+	kparams = *kparams_ptr;
+
+	if(np->full_name) {
+		pr_info(MODULE_NAME ": checking whether %s enables %s\n",
+				source, np->full_name);
+	} else {
+		pr_info(MODULE_NAME ": checking for %s parameters\n", source);
+	}
+
+	while (kparams) {
+		of_property_for_each_string(np, "param", prop, bname) {
+			found = strcmp(kparams->value, bname) == 0;
+			if (found) {
+				pr_info("node %s match with %s parameter %s\n",
+					np->full_name, source, kparams->value);
+				free_kparam_list(kparams);
+				goto search_done;	// double break
+			}
+		}
+		last_param = kparams;
+		kparams = kparams->next;
+		free_kparam_element(last_param);
+	}
+
+search_done:
+	*kparams_ptr = NULL;
+	return found;
+}
+
+/**
+ * process_fragment() - modify device tree if the fragment is active
+ * @np: the device-tree node of this fragment (/overlay-loader/<fragment>)
+ * @overlay_loader_node: the device-tree node for /overlay-loader
+ *
+ * Process a fragment.  If the value in /overlay-loader/<fragment>/param is an
+ * active overlay, apply that fragment's override@n nodes to the device tree.
+ * The overlay is active if it is listed in any of:
+ *
+ * - The kernel command line's active_overlays parameter
+ *
+ * - The active_overlays parameter in the device tree in
+ *   /overlay-loader/active_overlays
+ *
+ * - The configuration EEPROM loaded by the config-eeprom driver
+ *   (if the config-eeprom driver is loaded)
+ *
+ * Return: 0 on success, or a negated error on failure.
+ * Note that "success" can mean that an active fragment was applied or that
+ * an inactive fragment was skipped.
+ */
+
+static int __init process_fragment(struct device_node *np,
+		struct device_node *overlay_loader_node)
+{
+	struct device_node *cnp;
+	struct kparam_element *kparams = NULL;
+	//char *target = NULL;
+	int target_param_count;
+	int nchild;
+	bool found = false;
+
+	target_param_count = of_property_count_strings(np, "param");
+	if (target_param_count <=0) {
+		pr_err("Node %s does not have any params\n",
+			np->name);
+		return -EINVAL;
+	}
+
+	nchild = of_get_child_count(np);
+	if (!nchild) {
+		pr_err("Node %s does not have Overlay child\n", np->name);
+		return -EINVAL;
+	}
+
+	// Check kernel command line
+	if(!found && (get_kernel_parameters(&kparams, KERN_PARAM_NAME) == 0))
+		found = check_for_active_overlay(&kparams, np, "kernel");
+
+	// Check device tree
+	if(!found && (get_dt_parameters(&kparams, overlay_loader_node) == 0))
+		found = check_for_active_overlay(&kparams, np, "device-tree");
+
+#ifdef CONFIG_D3_CONFIG_EEPROM
+
+	// Check configuration EEPROM
+	if(!found && (get_config_eeprom_parameters(&kparams) == 0))
+		found = check_for_active_overlay(&kparams, np, "config-eeprom");
+
+#endif // CONFIG_D3_CONFIG_EEPROM
+
+	if (!found)
+		return 0;
+
+	for_each_child_of_node(np, cnp) {
+		handle_properties_overrides(cnp, NULL);
+	}
+
+	return 0;
+}
+
+
+static int __init overlay_loader_init(void)
+{
+	struct device_node *overlay_loader_node;
+	struct device_node *child;
+	int ret;
+
+	pr_info("Initializing overlay-loader\n");
+
+	overlay_loader_node = of_find_node_by_path("/overlay-loader");
+	if (!overlay_loader_node) {
+		pr_info("Overlay-loader not available, no root node\n");
+		return 0;
+	}
+
+	if (!of_device_is_available(overlay_loader_node)) {
+		pr_info("Overlay-loader status disabled\n");
+		return 0;
+	}
+
+	for_each_available_child_of_node(overlay_loader_node, child) {
+		ret = process_fragment(child, overlay_loader_node);
+		if (ret < 0)
+			pr_err("Error in parsing node %s: %d\n",
+				child->full_name, ret);
+	}
+	return 0;
+}
+
+/* Initialize the overlay loader at level 5 (fs).  This is after subsys (#4),
+ * so nvmem is available, and is before device (#6), when devices
+ * are initialized based on the DTB state. */
+
+fs_initcall(overlay_loader_init);
+
+MODULE_DESCRIPTION("A driver that will apply device tree fragments based on values from the kernel command line, the device tree, or a configuration EEPROM.");
+MODULE_AUTHOR("Laxman Dewangan <ldewangan@nvidia.com>");
+MODULE_AUTHOR("Tyler Hart <thart@d3engineering.com>");
+MODULE_AUTHOR("Christopher White <cwhite@d3engineering.com>");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/d3/ub953/Kconfig b/drivers/d3/ub953/Kconfig
new file mode 100644
index 000000000000..34206b108995
--- /dev/null
+++ b/drivers/d3/ub953/Kconfig
@@ -0,0 +1,4 @@
+config D3_UB953
+	tristate "UB953 FPDLINK-III Serializer Driver"
+	help
+	  TI ub953 serializer (used in D3 serdes board, et. al). 
diff --git a/drivers/d3/ub953/Makefile b/drivers/d3/ub953/Makefile
new file mode 100644
index 000000000000..c5d8e7f38231
--- /dev/null
+++ b/drivers/d3/ub953/Makefile
@@ -0,0 +1,3 @@
+# -*-makefile-*-
+obj-$(CONFIG_D3_UB953)	+= ub953.o
+
diff --git a/drivers/d3/ub953/ub953.c b/drivers/d3/ub953/ub953.c
new file mode 100644
index 000000000000..7592f915879e
--- /dev/null
+++ b/drivers/d3/ub953/ub953.c
@@ -0,0 +1,658 @@
+/**
+ * @author Greg Rowe <growe@d3engineering.com>
+ * 
+ * ub953 FPDLINK-III serializer driver
+ *
+ * Copyright (c) 2018-2019, D3 Engineering.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+#include <linux/module.h>
+#include <linux/i2c.h>
+#include <linux/regmap.h>
+#include <linux/delay.h>
+
+#include <d3/d3-jetson-bsp.h>
+
+/**
+ * If @p expr evalutes to non-zero assign it to @p err and return @p err
+ */
+#define TRY(err, expr) do {\
+		err = expr; \
+		if (err) { \
+			return err; \
+		} \
+	} while (false)
+
+#define TRY_MUTEX(mutex, err, expr) do {\
+		err = expr; \
+		if (err) { \
+			mutex_unlock(mutex); \
+			return err; \
+		} \
+	} while (false)
+
+#define TRY_MEM(mem, expr) do {\
+		mem = expr; \
+		if (IS_ERR(mem)) \
+			return PTR_ERR(mem); \
+	} while (false)
+
+/**
+ * Symbolic register names (see datasheet)
+ */
+enum {
+	UB953_REG_RESET_CTL       = 0x01,
+	UB953_GENERAL_CFG         = 0x02,
+	UB953_REG_CLKOUT_CTRL0    = 0x06,
+	UB953_REG_CLKOUT_CTRL1    = 0x07,
+	UB953_REG_LOCAL_GPIO_DATA = 0x0d,
+	UB953_REG_GPIO_INPUT_CTRL = 0x0e,
+	UB953_REG_BCC_CONFIG      = 0x32,
+	UB953_REG_REV_MASK_ID     = 0x50,
+	UB953_REG_IND_ACC_CTL     = 0xB0,
+	UB953_REG_IND_ACC_ADDR    = 0xB1,
+	UB953_REG_IND_ACC_DATA    = 0xB2,
+	UB953_REG_FPD3_TX_ID0     = 0xf0,
+};
+
+/**
+ * These values are used for programming CSI_CTL1 register
+ */
+enum ub953_csi_lane_count {
+	UB953_CSI_LANE_COUNT_4 = 3,
+	UB953_CSI_LANE_COUNT_2 = 1,
+	UB953_CSI_LANE_COUNT_1 = 0,
+
+	CSI_LANE_COUNT_ENDMARKER
+};
+
+/**
+ * Device driver information from device tree which is used to
+ * instantiate a sensor driver.
+ */
+struct ub953_devinfo
+{
+	/**
+	 * compatible string name
+	 */
+	char type[I2C_NAME_SIZE];
+
+	/**
+	 * alias address
+	 */
+	u32 addr;
+
+	/**
+	 * physical device address 
+	 */
+	u32 physical_addr;
+
+	/**
+	 * device tree node
+	 */
+	struct device_node *of_node;
+};
+
+
+struct ub953_cfg
+{
+	int n_lanes;
+	int continuous_clock;
+	int div_m_val;
+	int hs_clk_div;
+	int div_n_val;
+	int gpio_rmten;
+	int gpio_out_src;
+	int gpio_out_en;
+	int gpio_in_en;
+	int i2c_voltage_sel;
+	int fsync_gpio;
+	int wait_for_self_configure;
+};
+
+
+
+/**
+ * The device has 8 bit addresses and 8 bit values
+ */
+static struct regmap_config ub953_regmap_cfg =
+{
+	.reg_bits = 8,
+	.val_bits = 8,
+};
+
+
+/**
+ * ub953 driver class
+ */
+struct ub953
+{
+	struct i2c_client *client;
+	struct device *dev;
+	struct regmap *map;
+	struct mutex indirect_access_lock;
+
+	/**
+	 * sensor instance loaded by this driver
+	 */
+	struct i2c_client *sensor;
+
+	struct ub953_cfg cfg;
+};
+
+
+
+/* static int ub953_reg_read(struct ub953 *self, u8 addr, u8 *out) */
+/* { */
+/* 	int err = 0; */
+/* 	unsigned int val = 0; */
+/* 	if((err = regmap_read(self->map, addr, &val))) */
+/* 	{ */
+/* 		dev_warn(self->dev, "regmap_read returned %d", err); */
+/* 		return err; */
+/* 	} */
+/* 	*out = val; */
+/* 	dev_dbg(self->dev, "read: %#.2x=%#.2x", addr, *out); */
+/* 	return 0; */
+/* } */
+
+
+/* static int ub953_reg_write(struct ub953 *self, u8 addr, u8 val) */
+/* { */
+/* 	int err = 0; */
+/* 	dev_dbg(self->dev, "write: %#.2x=%#.2x", addr, val); */
+/* 	if((err = regmap_write(self->map, addr, val))) */
+/* 	{ */
+/* 		dev_err(self->dev, "write error: %d", err); */
+/* 		return err; */
+/* 	} */
+/* 	return 0; */
+/* } */
+
+
+/** 
+ * Allocates device managed memory
+ *
+ * @param dev device to allocate from
+ * @param len desired amount of memory
+ * @param out where to store pointer
+ *
+ * @return 0 on success
+ */
+static int ub953_kzalloc(struct device *dev, size_t len, void *out)
+{
+	void **real_out = out;
+	if(!(*real_out = devm_kzalloc(dev, len, GFP_KERNEL)))
+	{
+		dev_err(dev, "memory allocation failure");
+		return -ENOMEM;
+	}
+	return 0;
+}
+
+
+/** 
+ * Creates a device managed register map instance
+ *
+ * @param client managing device
+ * @param cfg register map configuration
+ * @param out_map output
+ *
+ * @return 0 on success
+ */
+static int ub953_regmap_init(struct i2c_client *client,
+			     struct regmap_config *cfg,
+			     struct regmap **out_map)
+{
+	if(!(*out_map = devm_regmap_init_i2c(client, cfg)))
+	{
+		dev_err(&client->dev, "regmap_init failed");
+		return -EINVAL;
+	}
+	return 0;
+}
+
+/** 
+ * Loads device information from a device tree node
+ *
+ * @param self driver instance
+ * @param node device tree node
+ * @param out where to store results
+ *
+ * @return 0 on success
+ */
+static int ub953_devinfo_load(struct ub953 *self,
+			      struct device_node *node,
+			      struct ub953_devinfo *out)
+{
+	int err = 0;
+	const char *type = NULL;
+
+	TRY(err, of_property_read_u32(node, "reg", &out->addr));
+	TRY(err, of_property_read_u32(node, "physical-addr",
+				      &out->physical_addr));
+	TRY(err, of_property_read_string(node, "compatible", &type));
+	/* TRY(err, of_property_read_string(node, "type", &type)); */
+	strncpy(out->type, type, sizeof(out->type));
+
+	out->of_node = node;
+	dev_dbg(self->dev, "reg=%#.2x, physical-addr=%#.2x, type=(%s)",
+		out->addr, out->physical_addr, out->type);
+	return 0;
+}
+
+
+/** 
+ * Loads sensor settings from device tree
+ *
+ * @param self driver instance
+ * @param out_info where to write values to
+ *
+ * @return 0 on success
+ */
+static int ub953_sensor_load(struct ub953 *self, struct ub953_devinfo *out_info)
+{
+	struct device_node *node = self->dev->of_node;
+	struct device_node *child = NULL;
+	int count = 0;
+	int err = 0;
+	
+	for_each_available_child_of_node(node, child)
+	{
+		if(count > 1)
+		{
+			dev_warn(self->dev,
+				 "%s: expecting 1 node",
+				 child->name);
+			return 0;
+		}
+		++count;
+		TRY(err, ub953_devinfo_load(self, child, out_info));
+	}
+	if(count != 1)
+	{
+		dev_warn(self->dev, "%s: expecting one sensor but saw %d!",
+			 node->name, count);
+		return -EINVAL;
+	}	
+	return 0;
+}
+
+
+/** 
+ * Instantiates an i2c_client for the sensor
+ *
+ * @param self driver instance
+ * @param devinfo device driver information (for loading sensor)
+ *
+ * @return 0 on success
+ */
+static int ub953_sensor_create(struct ub953 *self,
+			       const struct ub953_devinfo *devinfo)
+{
+	struct i2c_adapter *adap = to_i2c_adapter(self->client->dev.parent);
+	struct i2c_board_info i2c_info = {0};
+
+	strncpy(i2c_info.type, devinfo->type, sizeof(i2c_info.type));
+	i2c_info.addr = devinfo->addr;
+	i2c_info.of_node = devinfo->of_node;
+
+	self->sensor = i2c_new_device(adap, &i2c_info);
+	if(!self->sensor)
+	{
+		dev_err(self->dev,
+			"could not create i2c client for sensor"
+			" adapter=%s type=%s addr=%#.2x",
+			adap->name, i2c_info.type, i2c_info.addr);
+		return -ENOMEM;
+	}
+	
+	return 0;
+}
+
+static void ub953_cfg_dump(struct ub953 *self, const struct ub953_cfg *cfg)
+{
+	dev_dbg(self->dev,
+		"div-m-val=%d"
+		" hs-clk-div=%d"
+		" div-n-val=%d"
+		" gpio-rmten=%d"
+		" gpio-out-src=%d"
+		" gpio-out-en=%d"
+		" gpio-in-en=%d"
+		" i2c-voltage-sel=%d",
+		cfg->div_m_val,
+		cfg->hs_clk_div,
+		cfg->div_n_val,
+		cfg->gpio_rmten,
+		cfg->gpio_out_src,
+		cfg->gpio_out_en,
+		cfg->gpio_in_en,
+		cfg->i2c_voltage_sel);
+
+}
+
+static void ub953_of_read_optional(struct device_node *node, const char *name, int *val, int default_val)
+{
+	if (of_property_read_s32(node, name, val) != 0)
+		*val = default_val;
+}
+
+static int ub953_wait_for_data(struct ub953 *self)
+{
+	int err;
+	unsigned int val = 0;
+	unsigned int tries = 40;  /* 2 seconds */
+
+	do {
+		err = regmap_read(self->map, 0x61, &val);
+		dev_dbg(self->dev, "Waiting for data... (VC=%x, Data ID=%x)\n", ((val >> 6) & 0x3), (val & 0x3F));
+		if (val == 0) {
+			usleep_range(50*1000,50*1000);
+		}
+		/* check for timeout */
+		if (--tries == 0) {
+			dev_dbg(self->dev, "Timeout waiting for CSI data.");
+			break;
+		}
+	} while ((err == 0 || err == -ETIMEDOUT) && val == 0);
+
+	return err;
+}
+
+static int ub953_reset(struct ub953 *self, const struct ub953_cfg *cfg)
+{
+	int err;
+	int is_known;
+	int i;
+	int tries;
+	static const char *VALID_IDS[] = {
+		"_UB953",
+	};
+
+	char fpd3_tx_id[6];
+
+	if (cfg->wait_for_self_configure)
+		TRY(err, ub953_wait_for_data(self));
+
+	/* No reset gpio, try digital reset */
+	TRY(err, regmap_write(self->map, UB953_REG_RESET_CTL, 0x01));
+	usleep_range(4 * 1000, 5 * 1000);
+
+	is_known = false;
+	for (tries = 50; --tries > 0; ) {
+		err = regmap_bulk_read(self->map, UB953_REG_FPD3_TX_ID0, fpd3_tx_id,
+					  ARRAY_SIZE(fpd3_tx_id));
+
+		if (err == 0)
+			break;
+
+		usleep_range(10 * 1000, 10 * 1000);
+	}
+
+	if (err < 0)
+		return err;
+
+	for(i=0; i<ARRAY_SIZE(VALID_IDS); ++i) {
+		if (memcmp(fpd3_tx_id, VALID_IDS[i], sizeof(fpd3_tx_id)) == 0) {
+			is_known = true;
+			break;
+		}
+	}
+
+	if(!is_known) {
+		dev_warn(self->dev, "Unexpected FPD3_TX_ID: %.*s\n",
+			 (int)ARRAY_SIZE(fpd3_tx_id), fpd3_tx_id);
+	}
+
+	return 0;
+}
+
+static int ub953_indirect_write(struct ub953 *self, unsigned int page, unsigned int addr, unsigned int data)
+{
+	int err;
+	struct mutex *lock = &self->indirect_access_lock;
+
+	mutex_lock(lock);
+	TRY_MUTEX(lock, err, regmap_write(self->map, UB953_REG_IND_ACC_CTL, (page & 0x7) << 2));
+	TRY_MUTEX(lock, err, regmap_write(self->map, UB953_REG_IND_ACC_ADDR, addr));
+	TRY_MUTEX(lock, err, regmap_write(self->map, UB953_REG_IND_ACC_DATA, data));
+	mutex_unlock(lock);
+
+	return 0;
+}
+
+static int ub953_init(struct ub953 *self, const struct ub953_cfg *cfg)
+{
+	int err;
+	enum ub953_csi_lane_count lane_cnt;
+
+	TRY(err, ub953_reset(self, cfg));
+
+	ub953_cfg_dump(self, cfg);
+
+	switch (cfg->n_lanes) {
+		case 1:
+			lane_cnt = UB953_CSI_LANE_COUNT_1;
+			break;
+		case 2:
+			lane_cnt = UB953_CSI_LANE_COUNT_2;
+			break;
+		case 4:
+			lane_cnt = UB953_CSI_LANE_COUNT_4;
+			break;
+		default:
+			dev_err(self->dev, "n_lanes invalid value (%u)", cfg->n_lanes);
+			return -EINVAL;
+	}
+
+	TRY(err, regmap_update_bits(self->map,
+		UB953_GENERAL_CFG,
+		(0x1 << 6) |
+			(0x3 << 4) |
+			0x1,
+		((cfg->continuous_clock & 0x1) << 6) |
+			((lane_cnt & 0x3) << 4) |
+			(cfg->i2c_voltage_sel & 0x01)));
+
+	if (cfg->hs_clk_div >= 0 && cfg->div_m_val >= 0 && cfg->div_n_val >= 0) {
+		TRY(err, regmap_write(self->map,
+			UB953_REG_CLKOUT_CTRL0,
+			(cfg->hs_clk_div & 0x07) << 5 |
+				(cfg->div_m_val & 0x1F)));
+		TRY(err, regmap_write(self->map,
+			UB953_REG_CLKOUT_CTRL1,
+			(cfg->div_n_val & 0xFF)));
+	}
+
+	if (cfg->gpio_rmten >= 0 && cfg->gpio_out_src >= 0) {
+		TRY(err, regmap_write(self->map,
+			UB953_REG_LOCAL_GPIO_DATA,
+			((cfg->gpio_rmten & 0x0F) << 4) |
+				(cfg->gpio_out_src & 0x0F)));
+	}
+
+	if (cfg->gpio_out_en >= 0 && cfg->gpio_in_en >= 0) {
+		TRY(err, regmap_write(self->map,
+			UB953_REG_GPIO_INPUT_CTRL,
+			((cfg->gpio_out_en & 0x0F) << 4) |
+				(cfg->gpio_in_en & 0x0F)));
+	}
+
+	// No documentation on what this is or why it is needed?
+	TRY(err, ub953_indirect_write(self, 1, 0x08, 0x07));
+
+	return 0;
+}
+
+static int ub953_cfg_load(struct ub953 *self, struct ub953_cfg *out)
+{
+	struct device_node *node = self->client->dev.of_node;
+
+	ub953_of_read_optional(node, "csi-lane-count", &out->n_lanes, -1);
+	if (out->n_lanes < 1 || out->n_lanes > 4) {
+		dev_err(self->dev, "invalid or missing csi-lane-count");
+		return -EINVAL;
+	}
+
+	ub953_of_read_optional(node, "csi-continuous-clock", &out->continuous_clock, -1);
+	if (out->continuous_clock < 0 || out->continuous_clock > 1) {
+		dev_err(self->dev, "invalid or missing csi-continuous-clock");
+		return -EINVAL;
+	}
+
+	out->wait_for_self_configure = of_property_read_bool(node, "wait-for-self-configure");
+
+	ub953_of_read_optional(node, "div-m-val", &out->div_m_val, -1);
+	ub953_of_read_optional(node, "hs-clk-div", &out->hs_clk_div, -1);
+	ub953_of_read_optional(node, "div-n-val", &out->div_n_val, -1);
+	ub953_of_read_optional(node, "gpio-rmten", &out->gpio_rmten, -1);
+	ub953_of_read_optional(node, "gpio-out-src", &out->gpio_out_src, -1);
+	ub953_of_read_optional(node, "gpio-out-en", &out->gpio_out_en, -1);
+	ub953_of_read_optional(node, "gpio-in-en", &out->gpio_in_en, -1);
+	ub953_of_read_optional(node, "i2c-voltage-sel", &out->i2c_voltage_sel, -1);
+	ub953_of_read_optional(node, "fsync-gpio", &out->fsync_gpio, -1);
+
+	return 0;
+}
+
+
+/** 
+ * Called by Linux when a driver instance is loaded/created.
+ *
+ * @param client 
+ * @param id 
+ *
+ * @return 0 on success
+ */
+static int ub953_probe(struct i2c_client *client,
+		       const struct i2c_device_id *id)
+{
+	int err = 0;
+	struct ub953 *self = NULL;
+	struct device *dev = &client->dev;
+	struct device_node *node = client->dev.of_node;
+	struct ub953_devinfo sensor_info;
+	
+	dev_dbg(dev, "probe");
+
+	if(!IS_ENABLED(CONFIG_OF) || !node)
+	{
+		dev_err(dev, "of not enabled node=%p", node);
+		return -EINVAL;
+	}
+
+	/* allocate memory for 'self' data */
+	TRY(err, ub953_kzalloc(dev, sizeof(*self), &self));
+	i2c_set_clientdata(client, self);
+	self->client = client;
+	self->dev = &client->dev;
+	self->dev->platform_data = self;
+
+	mutex_init(&self->indirect_access_lock);
+
+	memset(&sensor_info, 0, sizeof(sensor_info));
+	TRY(err, ub953_sensor_load(self, &sensor_info));
+
+	TRY(err, ub953_regmap_init(client, &ub953_regmap_cfg, &self->map));
+	memset(&self->cfg, 0, sizeof(self->cfg));
+	TRY(err, ub953_cfg_load(self, &self->cfg));
+	TRY(err, ub953_init(self, &self->cfg));
+
+	TRY(err, ub953_sensor_create(self, &sensor_info));
+
+	dev_info(dev, "probe success");
+	return 0;
+}
+
+
+/** 
+ * Called when Linux unloaded an instance
+ *
+ * @param client 
+ *
+ * @return 0 on success
+ */
+static int ub953_remove(struct i2c_client *client)
+{
+	struct device *dev = &client->dev;
+	struct ub953 *self = i2c_get_clientdata(client);
+	
+	dev_info(dev, "remove");
+
+	if(self->sensor)
+	{
+		i2c_unregister_device(self->sensor);
+	}
+	
+	return 0;
+}
+
+/* On some imagers (e.g. OV10640), the frame sync input cannot be started until
+ * after the imager has been taken out of standby. So, imagers can call this
+ * function to start frame sync */
+int ub953_set_frame_sync_enable(struct device *dev, bool enabled)
+{
+	int err = 0;
+	unsigned int val;
+
+	struct ub953 *self = (struct ub953*)(dev->platform_data);
+	val = ((self->cfg.gpio_rmten & 0x0F) << 4) |
+		(self->cfg.gpio_out_src & 0x0F);
+
+	if (self->cfg.fsync_gpio >= 0) {
+		if (enabled) {
+			val |= ((1 << self->cfg.fsync_gpio) << 4);
+		} else {
+			val &= ~((1 << self->cfg.fsync_gpio) << 4);
+		}
+		TRY(err, regmap_write(self->map, UB953_REG_LOCAL_GPIO_DATA, val));
+	}
+	return err;
+}
+EXPORT_SYMBOL(ub953_set_frame_sync_enable);
+
+static const struct i2c_device_id ub953_id[] =
+{
+	{"ub953", 0},
+	{}
+};
+MODULE_DEVICE_TABLE(i2c, ub953_id);
+
+
+static struct of_device_id ub953_of_match[] =
+{
+	{ .compatible = "d3,ub953"},
+	{ },
+};
+MODULE_DEVICE_TABLE(of, ub953_of_match);
+
+
+static struct i2c_driver ub953_driver =
+{
+	.driver =
+	{
+		.name = "ub953",
+		.owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(ub953_of_match),
+	},
+	.probe = ub953_probe,
+	.remove = ub953_remove,
+	.id_table = ub953_id,
+};
+module_i2c_driver(ub953_driver);
+MODULE_DESCRIPTION("Driver for TI UB953 FPDLINK-III serializer");
+MODULE_VERSION(D3_JETSON_BSP_VERSION);
+MODULE_AUTHOR("Greg Rowe <growe@d3engineering.com>");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/d3/ub960/Kconfig b/drivers/d3/ub960/Kconfig
new file mode 100644
index 000000000000..d3fee40f353a
--- /dev/null
+++ b/drivers/d3/ub960/Kconfig
@@ -0,0 +1,9 @@
+config D3_UB960
+	tristate "UB960 FPDLINK-III Deserializer Driver"
+	help
+	  TI ub960 deserializer (used in D3 serdes board, et. al). 
+
+# config D3_UB960TP
+# 	tristate "UB960 FPDLINK-III Test Pattern Camera Driver"
+# 	help
+# 	  TI ub960 deserializer (used in D3 serdes board, et. al). 
diff --git a/drivers/d3/ub960/Makefile b/drivers/d3/ub960/Makefile
new file mode 100644
index 000000000000..e445b57477c3
--- /dev/null
+++ b/drivers/d3/ub960/Makefile
@@ -0,0 +1,4 @@
+# -*-makefile-*-
+obj-$(CONFIG_D3_UB960)		+= ub960.o
+obj-$(CONFIG_D3_UB960TP)		+= ub960tp.o
+
diff --git a/drivers/d3/ub960/ub960.c b/drivers/d3/ub960/ub960.c
new file mode 100644
index 000000000000..07ecf0b97934
--- /dev/null
+++ b/drivers/d3/ub960/ub960.c
@@ -0,0 +1,2186 @@
+/**
+ * @author Greg Rowe <growe@d3engineering.com>
+ * @author Josh Watts <jwatts@d3engineering.com>
+ *
+ * ub960 FPDLINK-III deserializer driver
+ *
+ * Copyright (c) 2018-2019, D3 Engineering.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/module.h>
+#include <linux/regmap.h>
+#include <linux/regulator/consumer.h>
+#include <linux/of_gpio.h>
+#include <linux/delay.h>
+#include <linux/of_irq.h>
+#include <linux/interrupt.h>
+
+#include <d3/d3-jetson-bsp.h>
+
+#include <d3/ub960.h>
+
+/*
+ * Default frame sync timings used if not specified in device tree
+ */
+#define FRAME_SYNC_DEFAULT_HIGH_TIME_US   (15000)
+#define FRAME_SYNC_DEFAULT_LOW_TIME_US    (35000)
+
+/**
+ * If @p expr evalutes to non-zero assign it to @p err and return @p err
+ */
+#define TRY(err, expr) do {\
+		err = expr; \
+		if (err) { \
+			return err; \
+		} \
+	} while (false)
+
+#define TRY_MUTEX(mutex, err, expr) do {\
+		err = expr; \
+		if (err) { \
+			mutex_unlock(mutex); \
+			return err; \
+		} \
+	} while (false)
+
+#define TRY_MEM(mem, expr) do {\
+		mem = expr; \
+		if (IS_ERR(mem)) \
+			return PTR_ERR(mem); \
+	} while (false)
+
+
+/**
+ * Symbolic register names (see datasheet)
+ */
+enum {
+	UB960_REG_RESET_CTL	= 0x01,
+	UB960_REG_REV_MASK_ID	= 0x03,
+	UB960_REG_RX_PORT_CTL	= 0x0c,
+	UB960_REG_IO_CTL	= 0x0d,
+	UB960_REG_INTERRUPT_CTL	= 0x23,
+	UB960_REG_INTERRUPT_STS	= 0x24,
+	UB960_REG_FPD3_PORT_SEL = 0x4c,
+	UB960_REG_RX_PORT_STS1	= 0x4d,
+	UB960_REG_RX_PORT_STS2	= 0x4e,
+	UB960_REG_BCC_CONFIG	= 0x58,
+	UB960_REG_CSI_VC_MAP	= 0x72,
+	UB960_REG_CSI_RX_STS	= 0x7a,
+	UB960_REG_CSI_PORT_SEL	= 0x32,
+	UB960_REG_CSI_CTL1	= 0x33,
+	UB960_REG_CSI_CTL2	= 0x34,
+	UB960_REG_FWD_CTL1	= 0x20,
+	UB960_REG_GPIO0_PIN_CTL = 0x10,
+	UB960_REG_GPIO1_PIN_CTL = 0x11,
+	UB960_REG_GPIO2_PIN_CTL = 0x12,
+	UB960_REG_GPIO3_PIN_CTL = 0x13,
+	UB960_REG_GPIO4_PIN_CTL = 0x14,
+	UB960_REG_GPIO5_PIN_CTL = 0x15,
+	UB960_REG_GPIO6_PIN_CTL = 0x16,
+	UB960_REG_GPIO7_PIN_CTL = 0x17,
+	UB960_REG_FS_CTL        = 0x18,
+	UB960_REG_FS_HIGH_TIME_1 = 0x19,
+	UB960_REG_FS_HIGH_TIME_0 = 0x1a,
+	UB960_REG_FS_LOW_TIME_1 = 0x1b,
+	UB960_REG_FS_LOW_TIME_0 = 0x1c,
+	UB960_REG_SFILTER_CFG   = 0x41,
+	UB960_REG_AEQ_CTL       = 0x42,
+	UB960_REG_FV_MIN_TIME	= 0xbc,
+	UB960_REG_SLAVE_ID0	= 0x5d,
+	UB960_REG_SLAVE_ALIAS0	= 0x65,
+	UB960_REG_PORT_CONFIG	= 0x6d,
+	UB960_REG_BC_GPIO_CTL0  = 0x6e,
+	UB960_REG_PORT_CONFIG2	= 0x7c,
+	UB960_REG_AEQ_MIN_MAX	= 0xd5,
+	UB960_REG_PORT_ICR_HI	= 0xd8,
+	UB960_REG_PORT_ICR_LO	= 0xd9,
+	UB960_REG_CSI_PLL_CTL	= 0x1f,
+	UB960_REG_IND_ACC_CTL	= 0xb0,
+	UB960_REG_IND_ACC_ADDR	= 0xb1,
+	UB960_REG_IND_ACC_DATA	= 0xb2,
+	UB960_REG_LINK_ERROR_CNT = 0xb9,
+	UB960_REG_FPD3_RX_ID0	= 0xf0,
+};
+
+enum ub960_register_bank {
+	UB960_BANK_PGEN = 0,
+	UB960_BANK_CSI0_TIMING = 0,
+	UB960_BANK_CSI1_TIMING = 0,
+	UB960_BANK_FPD3_0_RESERVED,
+	UB960_BANK_FPD3_1_RESERVED,
+	UB960_BANK_FPD3_2_RESERVED,
+	UB960_BANK_FPD3_3_RESERVED,
+	UB960_BANK_FPD3_SHARE_RESERVED,
+	UB960_BANK_FPD3_ALL_RESERVED,
+	UB960_BANK_CSI2_TX_RESERVED,
+};
+
+enum {
+	UB960_PGEN_RESERVED	= 0x00,
+	UB960_PGEN_CTL		= 0x01,
+	UB960_PGEN_CFG		= 0x02,
+	UB960_PGEN_CSI_DI	= 0x03,
+	UB960_PGEN_LINE_SIZE1	= 0x04,
+	UB960_PGEN_LINE_SIZE0	= 0x05,
+	UB960_PGEN_BAR_SIZE1	= 0x06,
+	UB960_PGEN_BAR_SIZE0	= 0x07,
+	UB960_PGEN_ACT_LPF1	= 0x08,
+	UB960_PGEN_ACT_LPF0	= 0x09,
+	UB960_PGEN_TOT_LPF1	= 0x0a,
+	UB960_PGEN_TOT_LPF0	= 0x0b,
+	UB960_PGEN_TOT_PD1	= 0x0c,
+	UB960_PGEN_TOT_PD0	= 0x0d,
+	UB960_PGEN_VBP		= 0x0e,	/* vertical back porch */
+	UB960_PGEN_VFP		= 0x0f,	/* vertical front porch */
+	UB960_PGEN_COLOR0	= 0x10,
+};
+
+enum {
+	UB960_INT_EN_OFFSET		= 7u,
+	UB960_INT_EN_MASK		= 1u << UB960_INT_EN_OFFSET,
+	UB960_LOCK_STS_CHG_OFFSET	= 0u,
+	UB960_LOCK_STS_CHG_MASK		= 1u << UB960_LOCK_STS_CHG_OFFSET,
+	UB960_LOCK_STS_OFFSET		= 0u,
+	UB960_LOCK_STS_MASK		= 1u << UB960_LOCK_STS_OFFSET,
+};
+
+
+/**
+ * These values are used for programming CSI_PLL_CTL register
+ */
+enum ub960_csi_tx_speed {
+	UB960_CSI_TX_SPEED_MAX  = 0,
+	UB960_CSI_TX_SPEED_1664 = 0,
+	UB960_CSI_TX_SPEED_1600 = 0,
+	UB960_CSI_TX_SPEED_1472 = 0,
+	UB960_CSI_TX_SPEED_1200 = 1,
+	UB960_CSI_TX_SPEED_800  = 2,
+	UB960_CSI_TX_SPEED_400  = 3,
+
+	UB960_CSI_TX_SPEED_ENDMARKER
+};
+
+/**
+ * These values are used for programming CSI_CTL1 register
+ */
+enum ub960_csi_lane_count {
+	UB960_CSI_LANE_COUNT_4 = 0,
+	UB960_CSI_LANE_COUNT_3 = 1,
+	UB960_CSI_LANE_COUNT_2 = 2,
+	UB960_CSI_LANE_COUNT_1 = 3,
+
+	CSI_LANE_COUNT_ENDMARKER
+};
+
+
+/**
+ * Identifies fpdlink ports
+ */
+enum {
+	UB960_PORT_0 = (1 << 0),
+	UB960_PORT_1 = (1 << 1),
+	UB960_PORT_2 = (1 << 2),
+	UB960_PORT_3 = (1 << 3),
+};
+
+
+/**
+ * This device has 8 bit register addresses and 8 bit values.
+ */
+static struct regmap_config ub960_regmap_cfg = {
+	.reg_bits = 8,
+	.val_bits = 8,
+};
+
+/**
+ * Section 7.4.19 of the datasheet states that timing must be set
+ * manually when operating at 400 Mbps.
+ *
+ * # Set CSI-2 Timing parameters
+ * WriteI2C(0xB0,0x2) # set auto-increment, page 0
+ * WriteI2C(0xB1,0x40) # CSI-2 Port 0
+ * WriteI2C(0xB2,0x83) # TCK Prep
+ * WriteI2C(0xB2,0x8D) # TCK Zero
+ * WriteI2C(0xB2,0x87) # TCK Trail
+ * WriteI2C(0xB2,0x87) # TCK Post
+ * WriteI2C(0xB2,0x83) # THS Prep
+ * WriteI2C(0xB2,0x86) # THS Zero
+ * WriteI2C(0xB2,0x84) # THS Trail
+ * WriteI2C(0xB2,0x86) # THS Exit
+ * WriteI2C(0xB2,0x84) # TLPX
+ * # Set CSI-2 Timing parameters
+ * WriteI2C(0xB0,0x2) # set auto-increment, page 0
+ * WriteI2C(0xB1,0x60) # CSI-2 Port 1
+ * WriteI2C(0xB2,0x83) # TCK Prep
+ * WriteI2C(0xB2,0x8D) # TCK Zero
+ * WriteI2C(0xB2,0x87) # TCK Trail
+ * WriteI2C(0xB2,0x87) # TCK Post
+ * WriteI2C(0xB2,0x83) # THS Prep
+ * WriteI2C(0xB2,0x86) # THS Zero
+ * WriteI2C(0xB2,0x84) # THS Trail
+ * WriteI2C(0xB2,0x86) # THS Exit
+ * WriteI2C(0xB2,0x84) # TLPX
+ */
+static const struct reg_sequence UB960_400_TIMING[] = {
+/* # Set CSI-2 Timing parameters */
+/* WriteI2C(0xB0,0x2) # set auto-increment, page 0 */
+	{.reg = 0xB0, .def = 0x2},
+/* WriteI2C(0xB1,0x40) # CSI-2 Port 0 */
+	{.reg = 0xB1, .def = 0x40},
+/* WriteI2C(0xB2,0x83) # TCK Prep */
+	{.reg = 0xB2, .def = 0x83},
+/* WriteI2C(0xB2,0x8D) # TCK Zero */
+	{.reg = 0xB2, .def = 0x8d},
+/* WriteI2C(0xB2,0x87) # TCK Trail */
+	{.reg = 0xB2, .def = 0x87},
+/* WriteI2C(0xB2,0x87) # TCK Post */
+	{.reg = 0xB2, .def = 0x87},
+/* WriteI2C(0xB2,0x83) # THS Prep */
+	{.reg = 0xB2, .def = 0x83},
+/* WriteI2C(0xB2,0x86) # THS Zero */
+	{.reg = 0xB2, .def = 0x86},
+/* WriteI2C(0xB2,0x84) # THS Trail */
+	{.reg = 0xB2, .def = 0x84},
+/* WriteI2C(0xB2,0x86) # THS Exit */
+	{.reg = 0xB2, .def = 0x86},
+/* WriteI2C(0xB2,0x84) # TLPX */
+	{.reg = 0xB2, .def = 0x84},
+ /* Set CSI-2 Timing parameters */
+/* WriteI2C(0xB0,0x2) # set auto-increment, page 0 */
+	{.reg = 0xB0, .def = 0x02},
+/* WriteI2C(0xB1,0x60) # CSI-2 Port 1 */
+	{.reg = 0xB1, .def = 0x60},
+/* WriteI2C(0xB2,0x83) # TCK Prep */
+	{.reg = 0xB2, .def = 0x83},
+/* WriteI2C(0xB2,0x8D) # TCK Zero */
+	{.reg = 0xB2, .def = 0x8d},
+/* WriteI2C(0xB2,0x87) # TCK Trail */
+	{.reg = 0xB2, .def = 0x87},
+/* WriteI2C(0xB2,0x87) # TCK Post */
+	{.reg = 0xB2, .def = 0x87},
+/* WriteI2C(0xB2,0x83) # THS Prep */
+	{.reg = 0xB2, .def = 0x83},
+/* WriteI2C(0xB2,0x86) # THS Zero */
+	{.reg = 0xB2, .def = 0x86},
+/* WriteI2C(0xB2,0x84) # THS Trail */
+	{.reg = 0xB2, .def = 0x84},
+/* WriteI2C(0xB2,0x86) # THS Exit */
+	{.reg = 0xB2, .def = 0x86},
+/* WriteI2C(0xB2,0x84) # TLPX */
+	{.reg = 0xB2, .def = 0x84},
+};
+
+/* This table is taken from an errata document from TI for silicon rev
+ * 4. It is recommended defaults (their recomendations changed so the
+ * power on defaults are incorrect in that rev). For now this is
+ * commented out because it is not correcting any problems I'm
+ * experiencing. */
+/* static const struct reg_sequence UB960_DEFAULTS[] = */
+/* { */
+/* 	{.reg = 0xb0, .def = 0x14, .delay_us=0}, */
+/* 	{.reg = 0xb1, .def = 0x03, .delay_us=0}, */
+/* 	{.reg = 0xb2, .def = 0x04, .delay_us=0}, */
+/* 	{.reg = 0xb1, .def = 0x04, .delay_us=0}, */
+/* 	{.reg = 0xb2, .def = 0x04, .delay_us=0}, */
+
+/* 	{.reg = 0xb0, .def = 0x1e, .delay_us=0}, */
+/* 	{.reg = 0xb1, .def = 0x1e, .delay_us=0}, */
+/* 	{.reg = 0xb2, .def = 0x15, .delay_us=0}, */
+/* 	{.reg = 0xb2, .def = 0x15, .delay_us=0}, */
+/* 	{.reg = 0xb2, .def = 0x15, .delay_us=0}, */
+/* 	{.reg = 0xb2, .def = 0x15, .delay_us=0}, */
+/* 	{.reg = 0xb2, .def = 0x15, .delay_us=0}, */
+/* 	{.reg = 0xb0, .def = 0x1e, .delay_us=0}, */
+/* 	{.reg = 0xb1, .def = 0x30, .delay_us=0}, */
+/* 	{.reg = 0xb2, .def = 0x15, .delay_us=0}, */
+/* 	{.reg = 0xb2, .def = 0x15, .delay_us=0}, */
+/* 	{.reg = 0xb2, .def = 0x15, .delay_us=0}, */
+/* 	{.reg = 0xb2, .def = 0x15, .delay_us=0}, */
+/* 	{.reg = 0xb0, .def = 0x1c, .delay_us=0}, */
+/* 	{.reg = 0xb1, .def = 0x2a, .delay_us=0}, */
+/* 	{.reg = 0xb2, .def = 0x15, .delay_us=0}, */
+/* 	{.reg = 0xb0, .def = 0x1e, .delay_us=0}, */
+/* 	{.reg = 0xb1, .def = 0x25, .delay_us=0}, */
+/* 	{.reg = 0xb2, .def = 0x16, .delay_us=0}, */
+/* 	{.reg = 0xb2, .def = 0x16, .delay_us=0}, */
+/* 	{.reg = 0xb2, .def = 0x16, .delay_us=0}, */
+/* 	{.reg = 0xb2, .def = 0x16, .delay_us=0}, */
+/* 	{.reg = 0xb2, .def = 0x16, .delay_us=0}, */
+/* 	{.reg = 0xb0, .def = 0x1e, .delay_us=0}, */
+/* 	{.reg = 0xb1, .def = 0x36, .delay_us=0}, */
+/* 	{.reg = 0xb2, .def = 0x16, .delay_us=0}, */
+/* 	{.reg = 0xb2, .def = 0x16, .delay_us=0}, */
+/* 	{.reg = 0xb2, .def = 0x16, .delay_us=0}, */
+/* 	{.reg = 0xb2, .def = 0x16, .delay_us=0}, */
+/* 	{.reg = 0xb2, .def = 0x16, .delay_us=0}, */
+/* 	{.reg = 0xb0, .def = 0x18, .delay_us=0}, */
+/* 	{.reg = 0xb1, .def = 0x01, .delay_us=0}, */
+/* 	{.reg = 0xb2, .def = 0xec, .delay_us=0}, */
+/* 	{.reg = 0xb0, .def = 0x1e, .delay_us=0}, */
+/* 	{.reg = 0xb1, .def = 0x10, .delay_us=0}, */
+/* 	{.reg = 0xb2, .def = 0x16, .delay_us=0}, */
+/* 	{.reg = 0xb2, .def = 0x16, .delay_us=0}, */
+/* 	{.reg = 0xb2, .def = 0x16, .delay_us=0}, */
+/* 	{.reg = 0xb2, .def = 0x16, .delay_us=0}, */
+/* 	{.reg = 0xb2, .def = 0x16, .delay_us=0}, */
+/* 	{.reg = 0xb1, .def = 0x2b, .delay_us=0}, */
+/* 	{.reg = 0xb2, .def = 0x16, .delay_us=0}, */
+/* 	{.reg = 0xb2, .def = 0x16, .delay_us=0}, */
+/* 	{.reg = 0xb2, .def = 0x16, .delay_us=0}, */
+/* 	{.reg = 0xb2, .def = 0x16, .delay_us=0}, */
+/* 	{.reg = 0xb2, .def = 0x16, .delay_us=0}, */
+/* 	{.reg = 0x4c, .def = 0x0f, .delay_us=0}, */
+/* 	{.reg = 0x41, .def = 0xa9, .delay_us=0}, */
+/* 	{.reg = 0x05, .def = 0x00, .delay_us=0}, */
+/* 	{.reg = 0x06, .def = 0x01, .delay_us=0}, */
+/* }; */
+
+
+/**
+ * I do not have documentation for these settings. These set values in
+ * the csi2 reserved register set.
+ */
+static const struct reg_sequence UB960_CSI2_RESERVED[] = {
+	{.reg = 0xB0, .def = 0x1C, .delay_us = 100000},
+	{.reg = 0xB1, .def = 0x13, .delay_us = 16000},
+	{.reg = 0xB2, .def = 0x1f, .delay_us = 16000},
+};
+
+
+/**
+ * This structure is used for loading information about the associated
+ * serializer and sensor from the device tree. This driver will
+ * instantiate a serializer. The serializer will instantiate a sensor
+ * driver.
+ */
+struct ub960_devinfo {
+	/**
+	 * This is the 'compatible' string and thus defines which driver
+	 * is loaded.
+	 */
+	char type[I2C_NAME_SIZE];
+
+	/**
+	 * Address programmed into the deserializer. The deserializer
+	 * forwards IO to this address.
+	 */
+	u32 addr;
+
+	/**
+	 * This is the physical address of the serializer. In practice
+	 * there willbe 4 serializers all with the same physical address
+	 * on different ports. It's the @p addr above that needs to be
+	 * different.
+	 */
+	u32 physical_addr;
+
+
+	/**
+	 * device tree node
+	 */
+	struct device_node *of_node;
+};
+
+
+struct ub960; /* Forward reference for ub960_port */
+
+/**
+ * Class for ports
+ */
+struct ub960_port {
+	int index;
+	bool configured;
+	bool enabled;
+	struct delayed_work lock_work;
+	bool locked;
+	struct ub960 *self;
+	struct completion lock_complete;
+
+	/** serializer information from device tree for instantiating driver */
+	struct ub960_devinfo ser_info;
+
+	/**
+	 * sensor information from device tree for programming addresses
+	 * into deserializer
+	 */
+	struct ub960_devinfo sensor_info;
+
+	/**
+	 * Serializer driver instance
+	 */
+	struct i2c_client *ser;
+};
+
+/**
+ * State information about test pattern. Most of this data is
+ * collected from the device tree.
+ */
+struct ub960_test_pattern_info {
+	struct device_node *node;
+
+	char compat[I2C_NAME_SIZE];
+	u32 reg;
+
+	u32 enabled;
+	u32 line_period;
+	u32 width_bytes;
+	u32 height_lines;
+	u32 vc_id;
+	u32 data_type;
+	u32 color0_value;
+};
+
+/**
+ * Holds csi configuration data. The 960 has two CSI ports but they
+ * must be configured identically.
+ */
+struct ub960_csi_info {
+	enum ub960_csi_tx_speed speed;
+	u8 n_lanes;
+	bool continuous_clock;
+};
+
+
+/**
+ * driver class
+ */
+struct ub960 {
+	struct i2c_client *client;
+	struct device *dev;
+	struct regmap *map;
+	struct mutex indirect_access_lock;
+	struct delayed_work status_work;
+	unsigned long lock_settle_time;
+	unsigned long lock_timeout;
+	unsigned long status_period;
+	unsigned long status_count;
+
+	struct regulator *avdd_reg;
+	struct regulator *iovdd_reg;
+
+	unsigned int pdb_gpio;
+	unsigned int irq;
+
+	/* fpd link3 ports */
+	struct ub960_port ports[4];
+	struct ub960_csi_info csi;
+
+	struct ub960_test_pattern_info test_pattern;
+	struct i2c_client *tp_client;
+};
+
+
+static void ub960_port_check_lock_sts(struct work_struct *work);
+
+
+int ub960_s_stream(struct i2c_client *self_in,
+		   struct i2c_client *src,
+		   int enable)
+{
+	int err = 0;
+	struct ub960 *self = i2c_get_clientdata(self_in);
+
+	/* nothing to do for enable */
+	if (enable) {
+		return 0;
+	}
+
+	dev_dbg(self->dev, "%s notified end-of-stream,"
+		" performing digital reset", src->dev.driver->name);
+	TRY(err, regmap_write(self->map, UB960_REG_RESET_CTL, 0x01));
+	usleep_range(3 * 1000, 4 * 1000);
+	return err;
+}
+EXPORT_SYMBOL_GPL(ub960_s_stream);
+
+
+/**
+ * Helper for setting gpio value (lifted from example code)
+ *
+ * @param gpio gpio id
+ * @param val on or off
+ */
+static void ub960_gpio_set(unsigned int gpio, int val)
+{
+	if (gpio_cansleep(gpio))
+		gpio_set_value_cansleep(gpio, val);
+	else
+		gpio_set_value(gpio, val);
+}
+
+
+/**
+ * Gets a device managed regulator
+ *
+ * @param self driver instance
+ * @param name name of regulator
+ * @param out where to store regulator
+ *
+ * @return 0 on success
+ */
+static int ub960_regulator_get(struct ub960 *self, const char *name,
+			       struct regulator **out)
+{
+	*out = devm_regulator_get(self->dev, name);
+	if (IS_ERR(*out)) {
+		dev_warn(self->dev, "could not find regulator: %s", name);
+		*out = NULL;
+		return -ENOENT;
+	}
+	return 0;
+}
+
+
+/**
+ * Enables a regulator
+ *
+ * @param self driver instance
+ * @param regulator the regulator to enable
+ * @param name name of the regulator (for debug)
+ *
+ * @return 0 on success
+ */
+static int ub960_regulator_enable(struct ub960 *self,
+				  struct regulator *regulator, const char *name)
+{
+	int err = 0;
+	if (!regulator)
+		return 0;
+
+	err = regulator_enable(regulator);
+	if (err) {
+		dev_err(self->dev, "could not enable regulator: %s", name);
+		return err;
+	}
+	return 0;
+}
+
+
+/**
+ * Acquires the regulators for the device(s)
+ *
+ * @param self driver instance
+ *
+ * @return 0 on success
+ */
+static int ub960_regulators_get(struct ub960 *self)
+{
+	/* It's OK if the regulators aren't present */
+	ub960_regulator_get(self, "avdd", &self->avdd_reg);
+	ub960_regulator_get(self, "iovdd", &self->iovdd_reg);
+	ub960_regulator_enable(self, self->avdd_reg, "avdd");
+	ub960_regulator_enable(self, self->iovdd_reg, "iovdd");
+	return 0;
+}
+
+
+/**
+ * Gets a gpio from the device tree by name.
+ *
+ * @param self driver instance
+ * @param name gpio name (for debugging)
+ * @param out gpio id
+ *
+ * @return 0 on success
+ */
+static int ub960_gpio_get(struct ub960 *self, const char *name,
+			  unsigned int *out)
+{
+	int err = 0;
+
+	err = of_get_named_gpio(self->client->dev.of_node, name, 0);
+	if (!gpio_is_valid(err)) {
+		dev_warn(self->dev, "gpio not present: %s: %d", name, err);
+		return err;
+	}
+	*out = err;
+	return 0;
+}
+
+
+/**
+ * Gets devices managed gpio request
+ *
+ * @param self driver instance
+ * @param id gpio id
+ * @param name gpio name for debugging
+ *
+ * @return 0 on success
+ */
+static int ub960_gpio_request(struct ub960 *self, unsigned int id,
+			      const char *name)
+{
+	int err = 0;
+
+	err = devm_gpio_request(self->dev, id, name);
+	if (err) {
+		dev_err(self->dev, "gpio request failed %s: %d", name, err);
+		return err;
+	}
+	return 0;
+}
+
+
+/**
+ * Exports a gpio
+ *
+ * @param self driver instance
+ * @param id gpio id
+ * @param name gpio name for debug
+ *
+ * @return 0 on success
+ */
+static int ub960_gpio_export(struct ub960 *self, unsigned int id,
+			     const char *name)
+{
+	int err = 0;
+
+	err = gpio_export(id, false);
+	if (err) {
+		dev_err(self->dev, "%s gpio export failed: %d", name, err);
+		return err;
+	}
+	return 0;
+}
+
+
+/**
+ * Sets gpio direction to output
+ *
+ * @param self driver instance
+ * @param id gpio id
+ * @param name gpio name for debugging
+ * @param value initial output value
+ *
+ * @return 0 on success
+ */
+static int ub960_gpio_direction_output(struct ub960 *self, unsigned int id,
+				       const char *name, int value)
+{
+	int err = 0;
+
+	err = gpio_direction_output(id, value);
+	if (err) {
+		dev_err(self->dev, "gpio %s direction error: %d", name, err);
+		return err;
+	}
+	return 0;
+}
+
+
+/**
+ * Gets all gpios for ub960
+ *
+ * @param self driver instance
+ *
+ * @return 0 on success
+ */
+static int ub960_gpios_get(struct ub960 *self)
+{
+	int err = 0;
+
+	ub960_gpio_get(self, "pdb-gpios", &self->pdb_gpio);
+
+	if (self->pdb_gpio) {
+		TRY(err, ub960_gpio_request(self, self->pdb_gpio,
+					    "cam_pdb_gpio"));
+		TRY(err, ub960_gpio_export(self, self->pdb_gpio,
+					   "cam_pdb_gpio"));
+		TRY(err, ub960_gpio_direction_output(self, self->pdb_gpio,
+						     "pdb_gpio", 0));
+	}
+
+	err = of_irq_get(self->dev->of_node, 0);
+	if (err > 0)
+		self->irq = err;
+	else if (err < 0) {
+		if (err == -EPROBE_DEFER) {
+			dev_warn(self->dev, "deferred because of gpio error");
+			return -EPROBE_DEFER;
+		}
+	}
+
+	return 0;
+}
+
+
+static int ub960_reset(struct ub960 *self)
+{
+	int err = 0;
+	int is_known;
+	int i;
+	int tries;
+	static const char VALID_IDS[2][6] = {
+		"_UB960",
+		"_UB954"
+	};
+
+	char fpd3_rx_id[6];
+
+	if (self->pdb_gpio) {
+		// active low, set low to power down
+		dev_dbg(self->dev, "using pdb_gpio for reset");
+		ub960_gpio_set(self->pdb_gpio, false);
+		usleep_range(3 * 1000, 4 * 1000);
+		ub960_gpio_set(self->pdb_gpio, true);
+		usleep_range(3 * 1000, 4 * 1000);
+	} else {
+		/* No reset gpio, try digital reset */
+		dev_dbg(self->dev, "no pdb_gpio, trying digital reset");
+		TRY(err, regmap_write(self->map, UB960_REG_RESET_CTL, 0x02));
+		dev_dbg(self->dev, "err = %i after regmap_write(UB960_REG_RESET_CTL)", err);
+		usleep_range(3 * 1000, 4 * 1000);
+	}
+
+	is_known = false;
+	for (tries = 5; --tries > 0; ) {
+		err = regmap_bulk_read(self->map, UB960_REG_FPD3_RX_ID0, fpd3_rx_id,
+					  ARRAY_SIZE(fpd3_rx_id));
+		dev_dbg(self->dev, "err = %i after regmap_bulk_read(UB960_REG_FPD3_RX_ID0)", err);
+
+		if (err == 0)
+			break;
+
+		usleep_range(50 * 1000, 50 * 1000);
+	}
+
+	if (err < 0)
+		return err;
+
+	for(i=0; i<ARRAY_SIZE(VALID_IDS); ++i) {
+		if (memcmp(fpd3_rx_id, VALID_IDS[i], sizeof(fpd3_rx_id)) == 0) {
+			is_known = true;
+			break;
+		}
+	}
+
+	if(!is_known) {
+		dev_warn(self->dev, "Unexpected FPD3_RX_ID: %.*s\n",
+			 (int)ARRAY_SIZE(fpd3_rx_id), fpd3_rx_id);
+	}
+	return 0;
+}
+
+/**
+ * Checks to see if the device is supported
+ *
+ * @param self driver instance
+ * @param out_is_supported result of test
+ *
+ * @return 0 on sucess
+ */
+static int ub960_is_device_supported(struct ub960 *self, bool *out_is_supported)
+{
+	int err = 0;
+	unsigned int id = 0;
+
+	*out_is_supported = true;
+	TRY(err, regmap_read(self->map, UB960_REG_REV_MASK_ID, &id));
+	id = (id >> 4) & 0xF;
+	dev_info(self->dev, "revision mask id: %#.2x", id);
+
+	switch (id) {
+	/* PDS90UB960-Q1 A0 */
+	case 0x2:
+		dev_info(self->dev, "detected: PDS90UB960-Q1 A0");
+		break;
+	/* PDS90UB960-Q1 A1 */
+	case 0x3:
+		dev_info(self->dev, "detected: PDS90UB960-Q1 A1");
+		break;
+	/* DS90UB960-Q1 A0 */
+	case 0x4:
+		dev_info(self->dev, "detected: DS90UB960-Q1 A0");
+		break;
+	case 0:
+	case 1:
+	default:
+		*out_is_supported = false;
+		break;
+	}
+	return 0;
+}
+
+/**
+ * Selects the fpd link port to program
+ *
+ * @param self driver instance
+ * @param read_port which port to read from (0-3)
+ * @param write_ports_mask which ports to write to
+ *
+ * @return 0 on success
+ */
+static int ub960_fdp3_port_select(struct ub960 *self, u8 read_port,
+				  u8 write_ports_mask)
+{
+	int err = 0;
+	/* bits 5 and 4 RX_READ_PORT 0-3 (direct port mapping)*/
+	/* bit 0, port1, bit1, port 2, */
+	TRY(err, regmap_write(self->map, UB960_REG_FPD3_PORT_SEL,
+			      (read_port << 4) | write_ports_mask));
+	return 0;
+}
+
+/**
+ * Congigures ub960 slave id.
+ *
+ * @param self driver instance
+ * @param id which slave id
+ * @param addr address of slave id
+ *
+ * @return 0 on sucess
+ */
+static int ub960_slave_id_set(struct ub960 *self, u8 id, u8 addr)
+{
+	int err = 0;
+	TRY(err, regmap_write(self->map, UB960_REG_SLAVE_ID0 + id, addr << 1));
+	return 0;
+}
+
+
+/**
+ * Configures slave alias address
+ *
+ * @param self driver instance
+ * @param id which slave id
+ * @param addr address
+ *
+ * @return 0 on success
+ */
+static int ub960_slave_alias_set(struct ub960 *self, u8 id, u8 addr)
+{
+	int err = 0;
+	TRY(err, regmap_write(self->map, UB960_REG_SLAVE_ALIAS0 + id, addr << 1));
+	return 0;
+}
+
+
+/**
+ * Returns the 8 bit value for CSI_CTL1 register from settings read
+ * from the device tree.
+ *
+ * @param self driver instance
+ *
+ * @return see description
+ */
+static u8 ub960_csi_info_to_reg(struct ub960 *self)
+{
+	u8 val = 0;
+	enum ub960_csi_lane_count lane_cnt;
+	/* 0 csi enable */
+	/* 1 cont clock  */
+	/* 3:2 CSI_ULP (not in the driver yet) */
+	/* 5:4 lane count */
+	/* 6: cal_en (should be enabled for 1.6 Gbps */
+
+	/* Do not set the enable flag yet... */
+	val |= (self->csi.continuous_clock << 1);
+
+
+	switch (self->csi.n_lanes) {
+		case 1:
+			lane_cnt = UB960_CSI_LANE_COUNT_1;
+			break;
+		case 2:
+			lane_cnt = UB960_CSI_LANE_COUNT_2;
+			break;
+		case 3:
+			lane_cnt = UB960_CSI_LANE_COUNT_3;
+			break;
+		case 4:
+			lane_cnt = UB960_CSI_LANE_COUNT_4;
+			break;
+		default:
+			dev_err(self->dev, "n_lanes invalid value (%u)", self->csi.n_lanes);
+			return -EINVAL;
+	}
+	val |= (lane_cnt << 4);
+	/* Enabled calibration for high speed. */
+	if (self->csi.speed == UB960_CSI_TX_SPEED_1600)
+		val |= (1 << 6);
+	return val;
+}
+
+
+/**
+ * Initializes channel/port settings but does not start CSI streaming
+ * (the function name is, perhaps, not an ideal choice).
+ *
+ * @param self driver instance
+ * @param chan_id channel id
+ * @param slave_id1 slave id of serializer
+ * @param slave_alias1 slave alias of serializer
+ * @param slave_id2 slave id of sensor
+ * @param slave_alias2 slave alias of sensor
+ *
+ * @return 0 on success
+ */
+static int ub960_chan_start(struct ub960 *self, u8 chan_id, u8 slave_id1,
+			    u8 slave_alias1, u8 slave_id2, u8 slave_alias2)
+{
+	u8 val = 0;
+	int err = 0;
+	struct mutex *lock = &self->indirect_access_lock;
+
+	mutex_lock(lock);
+
+	/* 	{0x4C, 0x01}, /\* 0x01 *\/ */
+	TRY_MUTEX(lock, err, ub960_fdp3_port_select(self, chan_id, (1 << chan_id)));
+	/* {0x32, 0x01}, /\*Enable TX port 0*\/ */
+	TRY_MUTEX(lock, err, regmap_write(self->map, UB960_REG_CSI_PORT_SEL, 0x1));
+
+
+	val = ub960_csi_info_to_reg(self);
+	dev_dbg(self->dev, "csi_ctl1: %#x", val);
+	TRY_MUTEX(lock, err, regmap_write(self->map, UB960_REG_CSI_CTL1, val));
+
+	/* {0xBC, 0x80}, /\* Frame valid minimum time*\/ */
+	TRY_MUTEX(lock, err, regmap_write(self->map, UB960_REG_FV_MIN_TIME, 0x80));
+	/* {0x5D, 0x30}, /\*Serializer I2C Address*\/ */
+	TRY_MUTEX(lock, err, ub960_slave_id_set(self, 0, slave_id1));
+	/* {0x65, (IMX390_UB960_PORT_0_SER_ADDR << 1U)}, */
+	TRY_MUTEX(lock, err, ub960_slave_alias_set(self, 0, slave_alias1));
+	/* {0x5E, 0x42}, /\*Sensor I2C Address*\/ */
+	TRY_MUTEX(lock, err, ub960_slave_id_set(self, 1, slave_id2));
+	/* {0x66, (IMX390_UB960_PORT_0_SENSOR_ADDR << 1U)}, */
+	TRY_MUTEX(lock, err, ub960_slave_alias_set(self, 1, slave_alias2));
+	/* {0x6D, 0x7C}, /\*CSI Mode*\/ */
+	TRY_MUTEX(lock, err, regmap_write(self->map, UB960_REG_PORT_CONFIG, 0x7c));
+	/* {0x72, 0x00}, /\*VC Map - All to 0 *\/ */
+
+	/* 0 - 0
+	 * 1 - 0x55
+	 * 2 - 0xaa
+	 * 3 - 0xff
+	 */
+	val = (chan_id << 6) | (chan_id << 4) | (chan_id << 2) | chan_id;
+	TRY_MUTEX(lock, err, regmap_write(self->map, UB960_REG_CSI_VC_MAP, val));
+	/* /\* GJR: based on the datasheet this should be 0x02 for the */
+	/*  * register to match the comment. *\/ */
+	/* {0x7C, 0x00}, /\*Line Valid active high, Frame Valid active high*\/ */
+	TRY_MUTEX(lock, err, regmap_write(self->map, UB960_REG_PORT_CONFIG2, 0x0));
+	/* {0xD5, 0xF2}, /\*Auto Attenuation*\/ */
+	TRY_MUTEX(lock, err, regmap_write(self->map, UB960_REG_AEQ_MIN_MAX, 0xf2));
+
+
+	TRY_MUTEX(lock, err, regmap_update_bits(self->map, UB960_REG_INTERRUPT_CTL,
+						(1 << chan_id), (1 << chan_id)));
+	TRY_MUTEX(lock, err, regmap_update_bits(self->map, UB960_REG_PORT_ICR_LO,
+						UB960_LOCK_STS_MASK, UB960_LOCK_STS_MASK));
+
+	mutex_unlock(lock);
+	return 0;
+}
+
+
+/**
+ * Configures a channel/port
+ *
+ * @param self driver instance
+ * @param id port id
+ *
+ * @return
+ */
+static int ub960_chan_cfg(struct ub960 *self, u8 id)
+{
+	int err = 0;
+	struct reg_sequence seq[] = {
+		{UB960_REG_AEQ_CTL,         0x71},
+		{UB960_REG_SFILTER_CFG,     0xA9},
+		{UB960_REG_LINK_ERROR_CNT,  0x33},
+		// Route FrameSync to BC_GPIO0
+		{UB960_REG_BC_GPIO_CTL0,    0x8a},
+	};
+
+	TRY(err, regmap_multi_reg_write(self->map, seq, ARRAY_SIZE(seq)));
+	return 0;
+}
+
+
+/**
+ * Starts the ub960
+ *
+ * @param self driver instance
+ *
+ * @return 0 on success
+ */
+static int ub960_csi_configure(struct ub960 *self)
+{
+	int err = 0;
+
+	TRY(err, ub960_reset(self));
+
+	/* TRY(err, regmap_multi_reg_write(self->map, */
+	/* 			       UB960_DEFAULTS, */
+	/* 			       ARRAY_SIZE(UB960_DEFAULTS))); */
+
+	/* lower two bits are csi tx speed */
+	TRY(err, regmap_write(self->map, UB960_REG_CSI_PLL_CTL, (1 << 2) | (self->csi.speed & 0x3)));
+	TRY(err, regmap_multi_reg_write(self->map, UB960_CSI2_RESERVED,
+					ARRAY_SIZE(UB960_CSI2_RESERVED)));
+	if (self->csi.speed == UB960_CSI_TX_SPEED_400) {
+		dev_warn(self->dev,
+			 "writing 400 mbps timing settings (untested!)");
+		TRY(err, regmap_multi_reg_write(self->map,
+						UB960_400_TIMING,
+						ARRAY_SIZE(UB960_400_TIMING)));
+	}
+
+	/* @todo move settings to device tree */
+
+	/* IO_CTL: bit 7: select 3.3v io supply
+	 * bit 6: 0 ... use detected voltage (and ignore bit 7!)
+	 * bit 5-4: IO supply mode (0b01 isn't valid!)*/
+	/* {0x0D, 0x90}, /\*I/O to 3V3 - Options not valid with datashee*\/ */
+	TRY(err, regmap_write(self->map, UB960_REG_IO_CTL, 0x90));
+
+	/* RX_PORT_CTL disable ports */
+	/* {0x0C, 0x0F}, /\*Disable all ports*\/ */
+	TRY(err, regmap_write(self->map, UB960_REG_RX_PORT_CTL, 0x00));
+
+	/* {0x32, 0x01}, /\*Enable TX port 0*\/ */
+	TRY(err, regmap_write(self->map, UB960_REG_CSI_PORT_SEL, 0x1));
+
+	/* forwarding enabled */
+	TRY(err, regmap_write(self->map, UB960_REG_FWD_CTL1, 0x0));
+
+	/* enable interrupt pin */
+	if (self->irq)
+		TRY(err, regmap_update_bits(self->map, UB960_REG_INTERRUPT_CTL,
+					    UB960_INT_EN_MASK, UB960_INT_EN_MASK));
+
+	return 0;
+}
+
+
+/**
+ * Reads a u32 from a device tree node and prints a warning on error.
+ *
+ * @param self driver instance, for warnings
+ * @param node node to read from
+ * @param name property name
+ * @param out where value is stored
+ *
+ * @return 0 on success
+ */
+static int ub960_of_read_u32(struct ub960 *self, struct device_node *node,
+			     const char *name, u32 *out)
+{
+	int err = 0;
+
+	err = of_property_read_u32(node, name, out);
+	if (err)
+		dev_warn(self->dev, "missing property: %s", name);
+	return err;
+}
+
+
+/**
+ * Reads a string property from a device tree node reporting warnings
+ *
+ * @param self driver instance for reporting warnings
+ * @param node device tree node to read from
+ * @param name property name
+ * @param out where to store result
+ *
+ * @return 0 on success
+ */
+static int ub960_of_read_string(struct ub960 *self, struct device_node *node,
+				const char *name, const char **out)
+{
+	int err = 0;
+
+	err = of_property_read_string(node, name, out);
+	if (err)
+		dev_warn(self->dev, "missing property: %s", name);
+	return err;
+
+}
+
+/**
+ * Configures FrameSync signal to either be generated internally or taken from
+ * a GPIO pin based on device tree options.
+ *
+ * @param self driver instance
+ *
+ * @return 0 on success
+ */
+static int ub960_fsync_configure(struct ub960 *self, struct device_node *node)
+{
+	int err = 0;
+	u32 mode = 0;
+	u32 high_time = 0;
+	u32 low_time = 0;
+	u32 reg_val;
+
+	err = of_property_read_u32(node, "frame-sync-mode", &mode);
+	if (err)
+	{
+		mode = 0;
+		dev_warn(self->dev, "using default frame-sync-mode: %d", mode);
+	}
+
+	err = of_property_read_u32(node, "frame-sync-high-time-us", &high_time);
+	if (err)
+	{
+		high_time = FRAME_SYNC_DEFAULT_HIGH_TIME_US;
+		dev_warn(self->dev, "using default frame-sync-high-time-us: %d", high_time);
+	}
+
+	err = of_property_read_u32(node, "frame-sync-low-time-us", &low_time);
+	if (err)
+	{
+		low_time = FRAME_SYNC_DEFAULT_LOW_TIME_US;
+		dev_warn(self->dev, "using default frame-sync-low-time-us: %d", low_time);
+	}
+
+	/* Convert high/low times from microseconds to number of clock periods
+	 * NOTE: These calculations assume a 50 Mbps backchannel frequency
+	 *       (BC_FREQ_SELECT=6). This makes FS_CLK_PD = 600 ns
+	 */
+	high_time = (high_time * 1000) / 600;
+	low_time = (low_time * 1000) / 600;
+	if (high_time > 0xffff) {
+		dev_warn(self->dev, "Frame sync high time too long. Reducing to 0xffff.\n");
+		high_time = 0xffff;
+	}
+	if (low_time > 0xffff) {
+		dev_warn(self->dev, "Frame sync low time too long. Reducing to 0xffff.\n");
+		low_time = 0xffff;
+	}
+
+	/* Configure high time and low time registers */
+	TRY(err, regmap_write(self->map, UB960_REG_FS_HIGH_TIME_1,
+		(high_time >> 8) & 0xff));
+	TRY(err, regmap_write(self->map, UB960_REG_FS_HIGH_TIME_0,
+		(high_time & 0xff)));
+	TRY(err, regmap_write(self->map, UB960_REG_FS_LOW_TIME_1,
+		(low_time >> 8) & 0xff));
+	TRY(err, regmap_write(self->map, UB960_REG_FS_LOW_TIME_0,
+		(low_time & 0xff)));
+
+	/* Configure FS_CTL register */
+	reg_val = (mode << 4);
+	if (mode == 0) {
+		reg_val |= 1;  // FS_GEN_ENABLE
+	}
+	TRY(err, regmap_write(self->map, UB960_REG_FS_CTL, reg_val));
+
+	return 0;
+}
+
+
+/**
+ * Loads device information from device tree
+ *
+ * @param self driver instance
+ * @param node device tree node to read from
+ * @param out extracted device info
+ *
+ * @return 0 on success
+ */
+static int ub960_devinfo_load(struct ub960 *self,
+			      struct device_node *node,
+			      struct ub960_devinfo *out)
+{
+	int err = 0;
+	const char *type = NULL;
+
+	TRY(err, ub960_of_read_u32(self, node, "reg", &out->addr));
+	TRY(err, ub960_of_read_u32(self, node, "physical-addr",
+				   &out->physical_addr));
+	TRY(err, ub960_of_read_string(self, node, "compatible", &type));
+	strncpy(out->type, type, sizeof(out->type));
+
+	out->of_node = node;
+	dev_dbg(self->dev, "reg=%#.2x, physical-addr=%#.2x, type=(%s)",
+		out->addr, out->physical_addr, out->type);
+	return 0;
+}
+
+
+/**
+ * Loads serializer info from device tree
+ *
+ * @param self driver instance
+ * @param node device tree node
+ * @param port which port/channel to load (values stored here)
+ *
+ * @return 0 on success
+ */
+static int ub960_serializer_load(struct ub960 *self,
+				 struct device_node *node,
+				 struct ub960_port *port)
+{
+	struct device_node *child = NULL;
+
+	int err = 0;
+	int count = 0;
+
+	TRY(err, ub960_devinfo_load(self, node, &port->ser_info));
+
+
+	/* @todo fix the kludgy 'count' nonsense */
+	for_each_available_child_of_node(node, child) {
+		if (count > 1) {
+			dev_warn(self->dev, "%s: expecting 1 node", child->name);
+			return 0;
+		}
+		TRY(err, ub960_devinfo_load(self, child, &port->sensor_info));
+		++count;
+	}
+	if (count != 1) {
+		dev_warn(self->dev, "%s: expecting one sensor but saw %d!",
+			 node->name, count);
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int ub960_set_port_enabled(struct ub960 *self, struct ub960_port *port,
+				  bool enable)
+{
+	int err;
+	const unsigned int port_en = 1 << port->index;
+
+	port->enabled = enable;
+	TRY(err, regmap_update_bits(self->map, UB960_REG_RX_PORT_CTL, port_en,
+				    (enable ? port_en : 0)));
+
+	return 0;
+}
+
+/**
+ * Loads a single port based on id.
+ *
+ * @param self driver instance
+ * @param node device tree node
+ * @param id port/channel id
+ *
+ * @return 0
+ */
+static int ub960_port_load(struct ub960 *self, struct device_node *node,
+			   struct ub960_port *port)
+{
+	struct device_node *child = NULL;
+	int err = 0;
+	int count = 0;
+
+	dev_dbg(self->dev, "Configure port %d", port->index);
+
+	port->self = self;
+	port->locked = false;
+	INIT_DELAYED_WORK(&port->lock_work, ub960_port_check_lock_sts);
+	init_completion(&port->lock_complete);
+
+	/* @todo fix the kludgy 'count' nonsense */
+	for_each_available_child_of_node(node, child) {
+		if (count > 1) {
+			dev_warn(self->dev,
+				 "%s: expecting 1 node",
+				 child->name);
+			return 0;
+		}
+
+		TRY(err, ub960_serializer_load(self, child, port));
+		++count;
+	}
+	/* sanity check */
+	if (count == 0)
+		dev_warn(self->dev, "port %d has no serializers\n", port->index);
+
+	port->configured = (count > 0);
+
+	return 0;
+}
+
+
+/**
+ * Loads all ports from the device tree
+ *
+ * @param self driver instance
+ *
+ * @return 0 on success
+ */
+static int ub960_ports_load(struct ub960 *self)
+{
+	/* int err = 0; */
+	struct device_node *child = NULL;
+	u32 reg = 0;
+	int err = 0;
+
+	for_each_available_child_of_node(self->dev->of_node, child) {
+		err = of_property_read_u32(child, "reg", &reg);
+		if (err)
+			continue;
+
+		if (reg > ARRAY_SIZE(self->ports) - 1) {
+			dev_warn(self->dev,
+				 "ignoring port reg=%d, ub960 has 4 ports", reg);
+			continue;
+		}
+		self->ports[reg].index = reg;
+
+		TRY(err, ub960_port_load(self, child, &self->ports[reg]));
+	}
+	return 0;
+}
+
+
+/**
+ * Instantiates i2c_client instance for serializer.
+ *
+ * @param self ub960 driver instance
+ * @param port which port to instantiate
+ *
+ * @return 0 on success
+ */
+static int ub960_serializer_create(struct ub960 *self, struct ub960_port *port)
+{
+	struct i2c_adapter *adap = to_i2c_adapter(self->client->dev.parent);
+	struct i2c_board_info i2c_info = {0};
+
+	/* there was no entry in the device tree for this
+	 * port
+	 */
+	if (port->ser_info.addr == 0)
+		return 0;
+
+	if (port->ser) {
+		dev_warn(self->dev, "Serializer already created for port %d\n", port->index);
+		return 0;
+	}
+
+	strncpy(i2c_info.type, port->ser_info.type, sizeof(i2c_info.type));
+	i2c_info.addr = port->ser_info.addr;
+	i2c_info.of_node = port->ser_info.of_node;
+
+	port->ser = i2c_new_device(adap, &i2c_info);
+	if (!port->ser) {
+		dev_err(self->dev,
+			"could not create i2c client for serializer"
+			" adapter=%s type=%s addr=%#.2x",
+			adap->name, i2c_info.type, i2c_info.addr);
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
+static int ub960_serializer_destroy(struct ub960 *self, struct ub960_port *port)
+{
+	dev_warn(self->dev, "TODO: Implement serializer destroy\n");
+	WARN_ON_ONCE(true);
+	return 0;
+}
+
+/**
+ * Writes the channel/port settings to the ub960
+ *
+ * @param self driver instance
+ *
+ * @return 0 on success
+ */
+static int ub960_ports_configure(struct ub960 *self)
+{
+	int err = 0;
+	int i = 0;
+	struct mutex *lock = &self->indirect_access_lock;
+
+
+	for (i = 0; i < ARRAY_SIZE(self->ports); ++i) {
+		struct ub960_port *p = &self->ports[i];
+
+		if (!p->configured)
+			continue;
+
+		mutex_lock(lock);
+		TRY_MUTEX(lock, err, ub960_fdp3_port_select(self, i, 1 << i));
+		TRY_MUTEX(lock, err, regmap_write(self->map, UB960_REG_BCC_CONFIG, 0x5e));
+		mutex_unlock(lock);
+
+		TRY(err, ub960_chan_cfg(self, i));
+
+		TRY(err, ub960_chan_start(self, i,
+					  p->ser_info.physical_addr,
+					  p->ser_info.addr,
+					  p->sensor_info.physical_addr,
+					  p->sensor_info.addr));
+
+		/* Enable port */
+		TRY(err, ub960_set_port_enabled(self, p, true));
+	}
+	return 0;
+}
+
+
+/**
+ * Get the csi transmit speed from the device tree.
+ *
+ * @param self driver instance
+ * @param node of node to read from
+ *
+ * @return csi tx speed
+ */
+static enum ub960_csi_tx_speed ub960_load_csi_tx_speed(struct ub960 *self,
+		struct device_node *node)
+{
+	/* default to 1600 */
+	const char *name = "csi-tx-speed-mbps";
+	u32 val = 1600;
+	enum ub960_csi_tx_speed speed = val;
+
+	if (of_property_read_u32(node, name, &val) != 0) {
+		dev_warn(self->dev,
+			 "property %s not present,"
+			 " defaulting to %u Mbps",
+			 name, val);
+		return val;
+	}
+	switch (val) {
+	case 1664:
+	case 1600:
+	case 1472:
+		speed = UB960_CSI_TX_SPEED_1600;
+		break;
+	case 1200:
+		speed = UB960_CSI_TX_SPEED_1200;
+		break;
+	case 800:
+		speed = UB960_CSI_TX_SPEED_800;
+		break;
+	case 400:
+		/* these are valid */
+		speed = UB960_CSI_TX_SPEED_400;
+		break;
+	default:
+		dev_warn(self->dev, "%s invalid value (%u)", name, val);
+	}
+	return speed;
+}
+
+
+/**
+ * Maps csi tx speed enum to human readable string
+ *
+ * @param speed
+ *
+ * @return human readable string
+ */
+static const char *ub960_csi_tx_speed_to_string(enum ub960_csi_tx_speed speed)
+{
+	const char *MAP[] = {
+		"1472-1664",
+		"1200",
+		"800",
+		"400"
+	};
+
+	if (speed >= UB960_CSI_TX_SPEED_ENDMARKER)
+		return "invalid";
+
+	return MAP[speed];
+}
+
+
+/**
+ * Loads CSI parameters from device tree
+ *
+ * @param self driver instance
+ * @param node where to read from
+ *
+ * @return 0 on success
+ */
+static int ub960_load_csi(struct ub960 *self, struct device_node *node)
+{
+
+	int err = 0;
+	u32 val = 0;
+	const char *key;
+
+	self->csi.speed = ub960_load_csi_tx_speed(self, node);
+
+
+	key = "csi-lane-count";
+	TRY(err, ub960_of_read_u32(self, node, key, &val));
+	if ((val < 1)
+	    || (val > 4)) {
+		dev_err(self->dev, "invalid %s:%u (1-4 valid)", key, val);
+		return -EINVAL;
+	}
+	self->csi.n_lanes = val;
+
+	key = "csi-continuous-clock";
+	TRY(err, ub960_of_read_u32(self, node, key, &val));
+	if (val > 1) {
+		dev_err(self->dev, "invalid %s:%u (0 or 1 valid)", key, val);
+		return -EINVAL;
+	}
+	self->csi.continuous_clock = val;
+
+	dev_info(self->dev, "csi speed:%s lanes:%u continuous-clock:%s",
+		 ub960_csi_tx_speed_to_string(self->csi.speed),
+		 self->csi.n_lanes,
+		 self->csi.continuous_clock ? "yes" : "no");
+	return 0;
+}
+
+/**
+ * Loads test pattern parameters from device tree node
+ *
+ * @param self driver instance
+ * @param node device tree node to read
+ *
+ * @return 0 on success
+ */
+/* static int ub960_test_pattern_load(struct ub960 *self, struct device_node *node) */
+/* { */
+/* 	int err = 0; */
+/* 	const char *str; */
+
+/* 	self->test_pattern.node = node; */
+
+/* 	TRY(err, ub960_of_read_string(self, node, "compatible", &str)); */
+/* 	strncpy(self->test_pattern.compat, str, sizeof(self->test_pattern.compat)); */
+
+/* 	TRY(err, ub960_of_read_u32(self, node, "reg", */
+/* 				   &self->test_pattern.reg)); */
+/* 	TRY(err, ub960_of_read_u32(self, node, "line-period", */
+/* 				   &self->test_pattern.line_period)); */
+/* 	TRY(err, ub960_of_read_u32(self, node, "width-bytes", */
+/* 				   &self->test_pattern.width_bytes)); */
+/* 	TRY(err, ub960_of_read_u32(self, node, "height-lines", */
+/* 				   &self->test_pattern.height_lines)); */
+/* 	TRY(err, ub960_of_read_u32(self, node, "vc-id", */
+/* 				   &self->test_pattern.vc_id)); */
+/* 	TRY(err, ub960_of_read_u32(self, node, "data-type", */
+/* 				   &self->test_pattern.data_type)); */
+/* 	TRY(err, ub960_of_read_u32(self, node, "color0-value", */
+/* 				   &self->test_pattern.color0_value)); */
+
+/* 	return 0; */
+/* } */
+
+/**
+ * Sets the enable bit on CSI_CTL register to turn on CSI output
+ *
+ * @param self driver instance
+ *
+ * @return 0 on success
+ */
+static int ub960_csi_enable(struct ub960 *self)
+{
+	int err = 0;
+	u8 val = 0;
+
+	val = ub960_csi_info_to_reg(self);
+	val |= 1;
+	TRY(err, regmap_write(self->map, UB960_REG_CSI_CTL1, val));
+	return 0;
+}
+
+/**
+ * Writes to an indirect register
+ *
+ * @param self driver instance
+ * @param bank register bank
+ * @param addr indirect address
+ * @param val value to write
+ *
+ * @return 0 on success
+ */
+static int ub960_reg_indirect_write(struct ub960 *self,
+				    enum ub960_register_bank bank,
+				    u8 addr, u8 val)
+{
+	int err = 0;
+	struct reg_sequence to_write[] = {
+		{.reg = UB960_REG_IND_ACC_CTL, .def = bank, .delay_us = 0},
+		{.reg = UB960_REG_IND_ACC_ADDR, .def = addr, .delay_us = 0},
+		{.reg = UB960_REG_IND_ACC_DATA, .def = val, .delay_us = 0},
+	};
+	TRY(err, regmap_multi_reg_write(self->map, to_write, ARRAY_SIZE(to_write)));
+	return 0;
+}
+
+/**
+ * This configures and turns on the test pattern
+ *
+ * @param self driver instance
+ *
+ * @return 0 on success
+ */
+static int ub960_test_pattern_enable(struct ub960 *self)
+{
+	int err = 0;
+	u8 val = 0;
+	/* Prior to enabling test pattern */
+	/* disable video forwarding (FWD_CTL1 set register 0x20 to 0x30 */
+	TRY(err, regmap_write(self->map, UB960_REG_FWD_CTL1, 0xF0));
+	/* configure CSI-2 speed (already done)*/
+	/* enabled csi-2 transmitter for port0 using csi_ctl */
+
+
+	/* fixed color, block size "controls the size of the fixed
+	 * color field in bytes"*/
+	val = (1 << 7) | 1;
+	TRY(err, ub960_reg_indirect_write(self, UB960_BANK_PGEN,
+					  UB960_PGEN_CFG, val));
+
+	/* vc id and data type */
+	val = (self->test_pattern.vc_id << 6) | self->test_pattern.data_type;
+	TRY(err, ub960_reg_indirect_write(self, UB960_BANK_PGEN,
+					  UB960_PGEN_CSI_DI, val));
+	/* line width in bytes */
+	val = (self->test_pattern.width_bytes & 0x0000ff00) >> 8;
+	TRY(err, ub960_reg_indirect_write(self, UB960_BANK_PGEN,
+					  UB960_PGEN_LINE_SIZE1, val));
+	val = (self->test_pattern.width_bytes & 0x000000ff);
+	TRY(err, ub960_reg_indirect_write(self, UB960_BANK_PGEN,
+					  UB960_PGEN_LINE_SIZE0, val));
+
+
+	/* active lines per frame */
+	val = (self->test_pattern.height_lines & 0x0000ff00) >> 8;
+	TRY(err, ub960_reg_indirect_write(self, UB960_BANK_PGEN,
+					  UB960_PGEN_ACT_LPF1, val));
+	val = (self->test_pattern.height_lines & 0x000000ff);
+	TRY(err, ub960_reg_indirect_write(self, UB960_BANK_PGEN,
+					  UB960_PGEN_ACT_LPF0, val));
+
+	/* total lines per frame including blanking */
+	/* line period (time period depends on CSI speed)*/
+	/* vertical back porch */
+	/* vertical front porch */
+
+	/* color0 - For the time being we're just going to use a
+	 * single byte for the color pattern. This is easy enough to
+	 * verify with a hex editor. */
+	val = self->test_pattern.color0_value & 0xff;
+	TRY(err, ub960_reg_indirect_write(self, UB960_BANK_PGEN,
+					  UB960_PGEN_COLOR0, val));
+
+	/* total line period (effectively controls frame rate) */
+	val = (self->test_pattern.line_period & 0xff00) >> 8;
+	TRY(err, ub960_reg_indirect_write(self, UB960_BANK_PGEN,
+					  UB960_PGEN_TOT_PD1, val));
+
+	val = self->test_pattern.line_period & 0xff;
+	TRY(err, ub960_reg_indirect_write(self, UB960_BANK_PGEN,
+					  UB960_PGEN_TOT_PD0, val));
+
+	/* Enable the test pattern */
+	TRY(err, ub960_reg_indirect_write(self, UB960_BANK_PGEN,
+					  UB960_PGEN_CTL, 1));
+
+	return 0;
+}
+
+/**
+ * Loads parameters from device tree
+ *
+ * @param self driver instance
+ * @param node device tree node
+ *
+ * @return 0 on success
+ */
+static int ub960_configuration_load(struct ub960 *self,
+				    struct device_node *node)
+{
+	/* struct device_node *tp_node = NULL; */
+	int err = 0;
+
+	/* Load test pattern values if it is present */
+	/* tp_node = of_find_node_by_name(node, "test-pattern"); */
+	/* if (tp_node != NULL) { */
+	/* 	if (of_device_is_available(tp_node)) { */
+	/* 		dev_dbg(self->dev, "loading test-pattern parameters"); */
+	/* 		err = ub960_test_pattern_load(self, tp_node); */
+	/* 		if (err) { */
+	/* 			of_node_put(tp_node); */
+	/* 			return err; */
+	/* 		} */
+	/* 	} */
+	/* 	of_node_put(tp_node); */
+	/* } */
+
+	/* load parameters for csi ports */
+	dev_dbg(self->dev, "loading csi parameters");
+	TRY(err, ub960_load_csi(self, node));
+
+	/* Read port data from device tree. Do this first, avoid
+	 * touching the hardware in case there's a device tree
+	 * misconfiguration. */
+	dev_dbg(self->dev, "loading fpdlink port parameters");
+	TRY(err, ub960_ports_load(self));
+
+	return 0;
+}
+
+/**
+ * This creates an instance of the test pattern driver. I'm not very
+ * fond of how this is done but it is functional...so there's that...
+ *
+ * @param self driver instance
+ *
+ * @return 0 on success
+ */
+static int ub960_test_pattern_driver_start(struct ub960 *self)
+{
+	struct i2c_adapter *adap = to_i2c_adapter(self->client->dev.parent);
+	struct i2c_board_info i2c_info = {0, };
+
+	strncpy(i2c_info.type, self->test_pattern.compat, sizeof(i2c_info.type));
+	i2c_info.addr = self->test_pattern.reg;;
+	i2c_info.of_node = self->test_pattern.node;
+
+	self->tp_client = i2c_new_device(adap, &i2c_info);
+	if (!self->tp_client) {
+		dev_err(self->dev,
+			"could not create i2c client for test pattern adapter=%s type=%s addr=%#.2x",
+			adap->name, i2c_info.type, i2c_info.addr);
+		return -ENOMEM;
+	}
+
+	dev_info(self->dev, "created test pattern driver");
+
+	return 0;
+}
+
+
+struct bitfield {
+	const char *name;
+	uint offset;
+	uint mask;
+	uint value;
+};
+
+#ifdef VERBOSE_STATUS
+
+#define BITFIELD(NAME, OFFSET, MASK, VALUE) \
+	{ #NAME, OFFSET, MASK, VALUE }
+#define BITFIELD_SINGLE(NAME, OFFSET) \
+	BITFIELD(NAME, OFFSET, 1u, 1u)
+
+static inline uint get_bitfield_value(struct bitfield *b, uint value)
+{
+	return ((value >> b->offset) & b->mask);
+}
+static inline bool is_bitfield_set(struct bitfield *b, uint value)
+{
+	return (get_bitfield_value(b, value) == b->mask);
+}
+static inline void strncat_bitfields(char *buf, int buf_len, struct bitfield *b, uint value)
+{
+	bool first = true;
+	if (!b)
+		return;
+	buf[0] = '\0';
+	while (b->name != NULL) {
+		if (is_bitfield_set(b, value)) {
+			if (!first)
+				strncat(buf, "|", buf_len);
+			else
+				first = false;
+			strncat(buf, b->name, buf_len);
+		}
+		b++;
+	}
+}
+
+struct bitfield RX_PORT_STS1_FIELDS[] = {
+	BITFIELD(RX_PORT_NUM_0, 6, 3, 0),
+	BITFIELD(RX_PORT_NUM_1, 6, 3, 1),
+	BITFIELD(RX_PORT_NUM_2, 6, 3, 2),
+	BITFIELD(RX_PORT_NUM_3, 6, 3, 3),
+	BITFIELD_SINGLE(BCC_CRC_ERROR, 5),
+	BITFIELD_SINGLE(LOCK_STS_CHG, 4),
+	BITFIELD_SINGLE(BCC_SEQ_ERROR, 3),
+	BITFIELD_SINGLE(PARITY_ERROR, 2),
+	BITFIELD_SINGLE(PORT_PASS, 1),
+	BITFIELD_SINGLE(LOCK_STS, 0),
+	{0, }
+};
+
+struct bitfield RX_PORT_STS2_FIELDS[] = {
+	BITFIELD_SINGLE(LINE_LEN_UNSTABLE, 7),
+	BITFIELD_SINGLE(LINE_LEN_CHG, 6),
+	BITFIELD_SINGLE(FPD3_ENCODE_ERROR, 5),
+	BITFIELD_SINGLE(BUFFER_ERROR, 4),
+	BITFIELD_SINGLE(CSI_ERROR, 3),
+	BITFIELD_SINGLE(FREQ_STABLE, 2),
+	BITFIELD_SINGLE(NO_FPD3_CLK, 1),
+	BITFIELD_SINGLE(LINE_CNT_CHG, 0),
+	{0, }
+};
+
+struct bitfield CSI_RX_STS_FIELDS[] = {
+	BITFIELD_SINGLE(LENGTH_ERR, 3),
+	BITFIELD_SINGLE(CKSUM_ERR, 2),
+	BITFIELD_SINGLE(ECC2_ERR, 1),
+	BITFIELD_SINGLE(ECC1_ERR, 0),
+	{0, }
+};
+
+#endif // VERBOSE_STATUS
+
+static inline int ub960_get_port_status(struct ub960_port *port,
+					  unsigned int *rx_port_sts1,
+					  unsigned int *rx_port_sts2,
+					  unsigned int *csi_rx_sts)
+{
+	int err;
+#ifdef VERBOSE_STATUS
+	char buf[128] = {0, };
+#endif
+	struct ub960 *self = port->self;
+	struct mutex *lock = &self->indirect_access_lock;
+
+	mutex_lock(lock);
+	TRY_MUTEX(lock, err, ub960_fdp3_port_select(self, port->index, (1 << port->index)));
+	TRY_MUTEX(lock, err, regmap_read(self->map, UB960_REG_RX_PORT_STS1, rx_port_sts1));
+	TRY_MUTEX(lock, err, regmap_read(self->map, UB960_REG_RX_PORT_STS2, rx_port_sts2));
+	TRY_MUTEX(lock, err, regmap_read(self->map, UB960_REG_CSI_RX_STS, csi_rx_sts));
+	mutex_unlock(lock);
+
+#ifdef VERBOSE_STATUS
+	strncat_bitfields(buf, sizeof(buf), RX_PORT_STS1_FIELDS, rx_port_sts1);
+	dev_dbg_ratelimited(self->dev, "[%d] RX_PORT_STS1: %02x %s\n", port->index,
+			    *rx_port_sts1 & 0xff, buf);
+
+	strncat_bitfields(buf, sizeof(buf), RX_PORT_STS2_FIELDS, rx_port_sts2);
+	dev_dbg_ratelimited(self->dev, "[%d] RX_PORT_STS2: %02x %s\n", port->index,
+			    *rx_port_sts2 & 0xff, buf);
+
+	strncat_bitfields(buf, sizeof(buf), CSI_RX_STS_FIELDS, csi_rx_sts);
+	dev_dbg_ratelimited(self->dev, "[%d] CSI_RX_STS: %02x %s\n", port->index,
+			    *csi_rx_sts & 0xff, buf);
+#else // VERBOSE_STATUS
+	dev_dbg_ratelimited(self->dev, "[%d] RX_PORT_STS1: %02x\n", port->index,
+			    *rx_port_sts1 & 0xff);
+
+	dev_dbg_ratelimited(self->dev, "[%d] RX_PORT_STS2: %02x\n", port->index,
+			    *rx_port_sts2 & 0xff);
+
+	dev_dbg_ratelimited(self->dev, "[%d] CSI_RX_STS: %02x\n", port->index,
+			    *csi_rx_sts & 0xff);
+#endif // VERBOSE_STATUS
+
+	return 0;
+}
+
+
+static void ub960_port_check_lock_sts(struct work_struct *work)
+{
+	int err;
+	struct ub960_port *port = container_of(to_delayed_work(work),
+					       struct ub960_port,
+					       lock_work);
+	struct ub960 *self = port->self;
+	unsigned int rx_port_sts1;
+	unsigned int rx_port_sts2;
+	unsigned int csi_rx_sts;
+	bool locked;
+
+	dev_dbg(self->dev, "%s enter", __func__);
+
+	err = ub960_get_port_status(port, &rx_port_sts1, &rx_port_sts2, &csi_rx_sts);
+	if (err < 0)
+		return;
+
+	locked = ((rx_port_sts1 >> UB960_LOCK_STS_OFFSET) & UB960_LOCK_STS_MASK) == 1;
+
+	dev_dbg_ratelimited(self->dev, "CHECK LOCK: locked=%d, port->locked=%d\n",
+			    locked, port->locked);
+
+	if (locked != port->locked) {
+		port->locked = locked;
+		if (locked) {
+			ub960_serializer_create(self, port);
+			complete(&port->lock_complete);
+		} else
+			ub960_serializer_destroy(self, port);
+	}
+
+	err = ub960_csi_enable(self);
+	if (err < 0) {
+		dev_err(self->dev, "err = %i after ub960_csi_enable", err);
+		return;
+	}
+
+	dev_info(self->dev, "probe success");
+}
+
+static int ub960_handle_port_irq(struct ub960 *self, struct ub960_port *port)
+{
+	int err;
+	unsigned int rx_port_sts1;
+	unsigned int rx_port_sts2;
+	unsigned int csi_rx_sts;
+
+	dev_dbg_ratelimited(self->dev, "HANDLE PORT %d", port->index);
+
+	TRY(err, ub960_get_port_status(port, &rx_port_sts1, &rx_port_sts2, &csi_rx_sts));
+
+	if (rx_port_sts1 & UB960_LOCK_STS_CHG_MASK) {
+		cancel_delayed_work_sync(&port->lock_work);
+		dev_dbg(self->dev, "port->lock_work scheduled");
+		schedule_delayed_work(&port->lock_work, self->lock_settle_time);
+	}
+
+	return 0;
+}
+
+static int ub960_check_status(struct ub960 *self)
+{
+	int err;
+	unsigned int status;
+	struct ub960_port *port;
+	int id;
+
+	TRY(err, regmap_read(self->map, UB960_REG_INTERRUPT_STS, &status));
+
+	if (!status)
+		return -EIO;
+
+	dev_dbg_ratelimited(self->dev, "STATUS: %02x\n", status & 0xff);
+
+	for (id = 0; id < ARRAY_SIZE(self->ports); id++) {
+		port = &self->ports[id];
+
+		if (!port->configured)
+			continue;
+
+		/* Ignore errors, check all ports */
+		if (status & (1 << port->index))
+			ub960_handle_port_irq(self, port);
+	}
+
+	return 0;
+};
+
+static irqreturn_t ub960_handle_irq(int irq, void *arg)
+{
+	struct ub960 *self = (struct ub960 *)arg;
+
+	ub960_check_status(self);
+
+	return IRQ_HANDLED;
+}
+
+static void ub960_remove_port(struct ub960 *self, struct ub960_port *port)
+{
+	if (!port->configured)
+		return;
+
+	dev_dbg(self->dev, "port->lock_work canceled");
+	cancel_delayed_work_sync(&port->lock_work);
+
+	if (port->ser)
+		i2c_unregister_device(port->ser);
+}
+
+static void ub960_poll_status(struct work_struct *work)
+{
+	struct ub960 *self = container_of(to_delayed_work(work), struct ub960,
+					  status_work);
+
+	int err = ub960_check_status(self);
+	int i;
+
+	if(err && self->status_count > 0) {
+		schedule_delayed_work(&self->status_work, self->status_period);
+		self->status_count--;
+	} else if(err) {
+		for (i = 0; i < ARRAY_SIZE(self->ports); ++i) {
+			ub960_remove_port(self, &self->ports[i]);
+		}
+
+		dev_err(self->dev, "probe failure");
+	}
+}
+
+static int ub960_setup_irq(struct ub960 *self)
+{
+	int err;
+
+	if (self->irq) {
+		char *name = devm_kzalloc(self->dev, 48, GFP_KERNEL);
+
+		strcpy(name, dev_name(self->dev));
+		strcat(name, "-irq");
+		TRY(err, devm_request_threaded_irq(self->dev, self->irq, NULL,
+						   ub960_handle_irq, IRQ_TYPE_EDGE_FALLING, name, self));
+	} else {
+		INIT_DELAYED_WORK(&self->status_work, ub960_poll_status);
+		schedule_delayed_work(&self->status_work, self->status_period);
+	}
+
+	return 0;
+}
+
+/**
+ * Called by Linux when loading an instance of the ub960
+ *
+ * @param client
+ * @param id
+ *
+ * @return 0 on success
+ */
+static int ub960_probe(struct i2c_client *client,
+		       const struct i2c_device_id *id)
+{
+	struct device *dev = &client->dev;
+	struct device_node *node = client->dev.of_node;
+	struct ub960 *self = NULL;
+	int err = 0;
+	bool is_supported = false;
+
+	dev_dbg(dev, "probe enter");
+
+	if (!IS_ENABLED(CONFIG_OF) || !node) {
+		dev_err(dev, "of not enabled");
+		return -EINVAL;
+	}
+
+	/* allocate memory for 'self' data */
+	TRY_MEM(self, devm_kzalloc(dev, sizeof(*self), GFP_KERNEL));
+
+	i2c_set_clientdata(client, self);
+	self->client = client;
+	self->dev = &client->dev;
+	self->lock_settle_time = HZ / 4;
+	self->lock_timeout = 4 * HZ;
+	self->status_period = HZ;
+	self->status_count = 10;
+
+	/* Load configuration from device tree */
+	TRY(err, ub960_configuration_load(self, node));
+	dev_dbg(dev, "err = %i after ub960_configuration_load", err);
+
+	/* Setup regulators */
+	dev_dbg(self->dev, "get regulators");
+	TRY(err, ub960_regulators_get(self));
+	dev_dbg(dev, "err = %i after ub960_regulators_get", err);
+
+	/* Setup gpio */
+	dev_dbg(self->dev, "gpio");
+	TRY(err, ub960_gpios_get(self));
+	dev_dbg(dev, "err = %i after ub960_gpios_get", err);
+
+	mutex_init(&self->indirect_access_lock);
+
+	dev_dbg(self->dev, "regmap init");
+	TRY_MEM(self->map, devm_regmap_init_i2c(client, &ub960_regmap_cfg));
+
+	dev_dbg(self->dev, "reset");
+	err = ub960_reset(self);
+	dev_dbg(dev, "err = %i after ub960_reset", err);
+	if (err == -EREMOTEIO || err == -ETIMEDOUT)
+		return -EPROBE_DEFER;
+
+	/* Sanity check */
+	err = ub960_is_device_supported(self, &is_supported);
+	dev_dbg(dev, "err = %i after ub960_is_device_supported", err);
+	if (err == -EREMOTEIO || err == -ETIMEDOUT)
+		return -EPROBE_DEFER;
+	if (!is_supported) {
+		dev_err(dev, "probe failed, unsupported device");
+		return -EINVAL;
+	}
+
+	err |= ub960_csi_configure(self);
+	dev_dbg(dev, "err = %i after ub960_csi_configure", err);
+	err |= ub960_fsync_configure(self, node);
+	dev_dbg(dev, "err = %i after ub960_fsync_configure", err);
+
+	/* configure the ports that have been defined in the device tree */
+	err |= ub960_ports_configure(self);
+	dev_dbg(dev, "err = %i after ub960_ports_configure", err);
+
+
+	TRY(err, ub960_setup_irq(self));
+	dev_dbg(dev, "err = %i after ub960_setup_irq", err);
+	/* TODO: After this point the polled-irq must be recovered upon failure */
+
+	if (self->test_pattern.enabled) {
+		err |= ub960_test_pattern_enable(self);
+		dev_dbg(dev, "err = %i after ub960_test_pattern_enable",  err);
+		err |= ub960_test_pattern_driver_start(self);
+		dev_dbg(dev, "err = %i after ub960_test_pattern_driver_start",  err);
+	}
+
+	return 0;
+}
+
+/**
+ * Called by Linux when unloading an instance
+ *
+ * @param client
+ *
+ * @return 0 on success
+ */
+static int ub960_remove(struct i2c_client *client)
+{
+	struct device *dev = &client->dev;
+	struct ub960 *self = i2c_get_clientdata(client);
+	int i = 0;
+
+	dev_info(dev, "remove");
+
+	cancel_delayed_work_sync(&self->status_work);
+
+	for (i = 0; i < ARRAY_SIZE(self->ports); ++i)
+		ub960_remove_port(self, &self->ports[i]);
+
+	if (regulator_is_enabled(self->avdd_reg))
+		regulator_disable(self->avdd_reg);
+	if (regulator_is_enabled(self->iovdd_reg))
+		regulator_disable(self->iovdd_reg);
+
+	return 0;
+}
+
+
+static const struct i2c_device_id ub960_id[] = {
+	{"ub960", 0},
+	{}
+};
+MODULE_DEVICE_TABLE(i2c, ub960_id);
+
+
+static const struct of_device_id ub960_of_match[] = {
+	{ .compatible = "d3,ub960"},
+	{ },
+};
+MODULE_DEVICE_TABLE(of, ub960_of_match);
+
+static struct i2c_driver ub960_driver = {
+	.driver = {
+		.name = "ub960",
+		.owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(ub960_of_match),
+	},
+	.probe = ub960_probe,
+	.remove = ub960_remove,
+	.id_table = ub960_id,
+};
+module_i2c_driver(ub960_driver);
+
+MODULE_DESCRIPTION("Driver for TI UB960 FPDLINK-III deserializer");
+MODULE_VERSION(D3_JETSON_BSP_VERSION);
+MODULE_AUTHOR("Greg Rowe <growe@d3engineering.com>");
+MODULE_AUTHOR("Josh Watts <jwatts@d3engineering.com>");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/d3/ub960/ub960tp.c b/drivers/d3/ub960/ub960tp.c
new file mode 100644
index 000000000000..d1103710bac3
--- /dev/null
+++ b/drivers/d3/ub960/ub960tp.c
@@ -0,0 +1,767 @@
+/**
+ * @author Greg Rowe <growe@d3engineering.com>
+ *
+ * ub960 test pattern v4l2 driver for Nvidia Jetson camera platform
+ *
+ * Copyright (c) 2018-2019, D3 Engineering.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <media/camera_common.h>
+
+#include <d3/d3-jetson-bsp.h>
+
+/**
+ * If @p expr evalutes to non-zero assign it to @p err and return @p err
+ */
+#define TRY(err, expr) do {\
+		err = expr; \
+		if (err) { \
+			return err; \
+		} \
+	} while (false)
+
+static const int ub960tp_30fps[] = {
+	30,
+};
+
+
+/**
+ * Mode table as expected by Nvidia's camera_common framework
+ */
+static const struct camera_common_frmfmt ub960tp_formats[] = {
+	/* The imager outputs 1936x1096 but includes 4 lines of SMPG
+	 * data.  SMPG is Safety Mechanism Pattern Generator.  There is
+	 * also 1 line of embedded data that cannot be disabled.  The
+	 * embedded data line does NOT count towards the overall
+	 * dimensions. */
+	{
+		.size = {1920, 1080},
+		.framerates = ub960tp_30fps,
+		.num_framerates = 1,
+		.hdr_en = 0,
+		.mode = 0
+	},
+};
+
+
+/**
+ * The is the ub960tp driver class. Some of the pointers are not
+ * strictly needed as they can be obtained via things like
+ * 'client'. These pointers exist for convenience.
+ */
+struct ub960tp {
+	struct camera_common_power_rail	power;
+
+	/* Nvidia's code requires that you have an i2c device. */
+	struct i2c_client *client;
+	struct device *dev;
+	struct regmap *map;
+
+	struct camera_common_data *s_data;
+	struct camera_common_pdata *pdata;
+
+	struct media_pad pad;
+	struct v4l2_ctrl_handler ctrl_handler;
+	struct v4l2_subdev *subdev;
+	struct v4l2_ctrl *ctrls[];
+};
+
+
+static int ub960tp_g_volatile_ctrl(struct v4l2_ctrl *ctrl);
+static int ub960tp_s_ctrl(struct v4l2_ctrl *ctrl);
+static const struct v4l2_ctrl_ops ub960tp_ctrl_ops = {
+	.g_volatile_ctrl = ub960tp_g_volatile_ctrl,
+	.s_ctrl = ub960tp_s_ctrl,
+};
+
+
+static struct v4l2_ctrl_config ctrl_config_list[] = {
+	{
+		.ops = &ub960tp_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_GAIN,
+		.name = "Gain",
+		.type = V4L2_CTRL_TYPE_INTEGER64,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = 1 * FIXED_POINT_SCALING_FACTOR,
+		.max = 1 * FIXED_POINT_SCALING_FACTOR,
+		.def = 1 * FIXED_POINT_SCALING_FACTOR,
+		.step = 1 * FIXED_POINT_SCALING_FACTOR,
+	},
+	{
+		.ops = &ub960tp_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_FRAME_RATE,
+		.name = "Frame Rate",
+		.type = V4L2_CTRL_TYPE_INTEGER64,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = 30 * FIXED_POINT_SCALING_FACTOR,
+		.max = 30 * FIXED_POINT_SCALING_FACTOR,
+		.def = 30 * FIXED_POINT_SCALING_FACTOR,
+		.step = 1 * FIXED_POINT_SCALING_FACTOR,
+	},
+	{
+		.ops = &ub960tp_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_EXPOSURE,
+		.name = "Exposure",
+		.type = V4L2_CTRL_TYPE_INTEGER64,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		/* 30 us  */
+		.min = 30 * FIXED_POINT_SCALING_FACTOR / 1000000,
+		/* 33.3 ms */
+		.max = 33333 * FIXED_POINT_SCALING_FACTOR / 1000000,
+		/* 11 ms */
+		.def = 11000 * FIXED_POINT_SCALING_FACTOR / 1000000,
+		/* Microsecond steps */
+		.step = 1 * FIXED_POINT_SCALING_FACTOR / 1000000,
+	},
+	{
+		.ops = &ub960tp_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_GROUP_HOLD,
+		.name = "Group Hold",
+		.type = V4L2_CTRL_TYPE_INTEGER_MENU,
+		.min = 0,
+		.max = ARRAY_SIZE(switch_ctrl_qmenu) - 1,
+		.menu_skip_mask = 0,
+		.def = 0,
+		.qmenu_int = switch_ctrl_qmenu,
+	},
+	{
+		.ops = &ub960tp_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_HDR_EN,
+		.name = "HDR enable",
+		.type = V4L2_CTRL_TYPE_INTEGER_MENU,
+		.min = 0,
+		.max = ARRAY_SIZE(switch_ctrl_qmenu) - 1,
+		.menu_skip_mask = 0,
+		.def = 0,
+		.qmenu_int = switch_ctrl_qmenu,
+	},
+};
+
+
+
+
+/**
+ * This is called to start the stream. Currently this doesn't really
+ * do anything other than log start/stop.
+ *
+ * @param sd sub device
+ * @param enable enable/disable stream
+ *
+ * @return
+ */
+static int ub960tp_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	/* int err = 0; */
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_common_data *s_data = to_camera_common_data(&client->dev);
+	struct ub960tp *self = (struct ub960tp *)s_data->priv;
+
+
+	dev_dbg(self->dev, "%s", enable ? "START" : "STOP");
+	/* TRY(err, ub960tp_reg_write(self, UB960TP_REG_STANDBY, enable ? 0:1)); */
+	return 0;
+}
+
+
+/**
+ * I am not sure what the intent of this function is.
+ *
+ * @param sd sub device
+ * @param status
+ *
+ * @return 0, always
+ */
+static int ub960tp_g_input_status(struct v4l2_subdev *sd, u32 *status)
+{
+	return 0;
+}
+
+
+/**
+ * Called by Linux when unloading the driver instance.
+ *
+ * @param client which instance
+ *
+ * @return 0, always
+ */
+static int ub960tp_remove(struct i2c_client *client)
+{
+	struct device *dev = &client->dev;
+	dev_info(dev, "remove");
+	return 0;
+}
+
+
+static const struct i2c_device_id ub960tp_id[] = {
+	{"ub960tp", 0},
+	{}
+};
+MODULE_DEVICE_TABLE(i2c, ub960tp_id);
+
+
+static struct v4l2_subdev_video_ops ub960tp_subdev_video_ops = {
+	.s_stream	= ub960tp_s_stream,
+	.g_mbus_config	= camera_common_g_mbus_config,
+	.g_input_status	= ub960tp_g_input_status,
+};
+
+
+static struct v4l2_subdev_core_ops ub960tp_subdev_core_ops = {
+	.s_power	= camera_common_s_power,
+};
+
+
+static int ub960tp_power_on(struct camera_common_data *s_data)
+{
+	/* int err = 0; */
+	struct ub960tp *priv = (struct ub960tp *)s_data->priv;
+	struct camera_common_power_rail *pw = &priv->power;
+
+	dev_dbg(priv->dev, "%s: power on\n", __func__);
+	pw->state = SWITCH_ON;
+	return 0;
+
+}
+
+static int ub960tp_power_off(struct camera_common_data *s_data)
+{
+	/* int err = 0; */
+	struct ub960tp *priv = (struct ub960tp *)s_data->priv;
+	struct camera_common_power_rail *pw = &priv->power;
+
+	dev_dbg(priv->dev, "%s: power off\n", __func__);
+	pw->state = SWITCH_OFF;
+	return 0;
+}
+
+
+/**
+ * v4l2 set and tryset format handler
+ *
+ * @param sd sub dev
+ * @param cfg
+ * @param format format to attempt to set or to set
+ *
+ * @return 0 on success
+ */
+static int ub960tp_set_fmt(struct v4l2_subdev *sd,
+			   struct v4l2_subdev_pad_config *cfg,
+			   struct v4l2_subdev_format *format)
+{
+	int ret;
+	if (format->which == V4L2_SUBDEV_FORMAT_TRY)
+		ret = camera_common_try_fmt(sd, &format->format);
+	else
+		ret = camera_common_s_fmt(sd, &format->format);
+	return ret;
+}
+
+
+/**
+ * Returns the active format
+ *
+ * @param sd sub dev
+ * @param cfg
+ * @param format output - the active format
+ *
+ * @return
+ */
+static int ub960tp_get_fmt(struct v4l2_subdev *sd,
+			   struct v4l2_subdev_pad_config *cfg,
+			   struct v4l2_subdev_format *format)
+{
+	return camera_common_g_fmt(sd, &format->format);
+}
+
+
+static int ub960tp_write_reg(struct camera_common_data *s_data, u16 addr,
+			     u8 val)
+{
+	return 0;
+}
+
+
+static int ub960tp_read_reg(struct camera_common_data *s_data, u16 addr,
+			    u8 *val)
+{
+	return 0;
+}
+
+
+
+static struct v4l2_subdev_pad_ops ub960tp_subdev_pad_ops = {
+	.set_fmt	     = ub960tp_set_fmt,
+	.get_fmt	     = ub960tp_get_fmt,
+	.enum_mbus_code	     = camera_common_enum_mbus_code,
+	.enum_frame_size     = camera_common_enum_framesizes,
+	.enum_frame_interval = camera_common_enum_frameintervals,
+};
+
+
+static struct v4l2_subdev_ops ub960tp_subdev_ops = {
+	.core  = &ub960tp_subdev_core_ops,
+	.video = &ub960tp_subdev_video_ops,
+	.pad   = &ub960tp_subdev_pad_ops,
+};
+
+
+static struct of_device_id ub960tp_of_match[] = {
+	{ .compatible = "d3,ub960tp"},
+	{ },
+};
+MODULE_DEVICE_TABLE(of, ub960tp_of_match);
+
+
+/**
+ * These are for debugging. The Nvidia camera_common code creates a
+ * file in sysfs to read and write the image sensor.
+ */
+static struct camera_common_sensor_ops ub960tp_common_ops = {
+	.power_on = ub960tp_power_on,
+	.power_off = ub960tp_power_off,
+	.write_reg = ub960tp_write_reg,
+	.read_reg  = ub960tp_read_reg,
+};
+
+
+/**
+ * Initializes v4l2 controls (taken from example code).
+ */
+static int ub960tp_ctrls_init(struct ub960tp *self)
+{
+	struct v4l2_ctrl *ctrl;
+	int numctrls;
+	int err;
+	int i;
+
+	dev_dbg(self->dev, "%s++", __func__);
+
+	numctrls = ARRAY_SIZE(ctrl_config_list);
+	v4l2_ctrl_handler_init(&self->ctrl_handler, numctrls);
+
+	for (i = 0; i < numctrls; i++) {
+		ctrl = v4l2_ctrl_new_custom(&self->ctrl_handler,
+					    &ctrl_config_list[i], NULL);
+		if (ctrl == NULL) {
+			dev_err(self->dev, "Failed to init %s ctrl",
+				ctrl_config_list[i].name);
+			continue;
+		}
+
+		if (ctrl_config_list[i].type == V4L2_CTRL_TYPE_STRING &&
+		    ctrl_config_list[i].flags & V4L2_CTRL_FLAG_READ_ONLY) {
+			/* @todo should use ub960tp_kzalloc */
+			ctrl->p_new.p_char = devm_kzalloc(
+						     self->dev,
+						     ctrl_config_list[i].max + 1, GFP_KERNEL);
+			if (!ctrl->p_new.p_char)
+				return -ENOMEM;
+		}
+		self->ctrls[i] = ctrl;
+	}
+
+	self->subdev->ctrl_handler = &self->ctrl_handler;
+	if (self->ctrl_handler.error) {
+		dev_err(self->dev, "Error %d adding controls",
+			self->ctrl_handler.error);
+		err = self->ctrl_handler.error;
+		goto error;
+	}
+
+	if ((err = v4l2_ctrl_handler_setup(&self->ctrl_handler))) {
+		dev_err(self->dev, "Error %d setting default controls", err);
+		goto error;
+	}
+
+	return 0;
+
+error:
+	v4l2_ctrl_handler_free(&self->ctrl_handler);
+	return err;
+}
+
+
+/**
+ * Called when the device is opened. For example this is called when
+ * you execute `media-ctl -p` from userspace.
+ *
+ * @param sd sub device
+ * @param fh
+ *
+ * @return 0, always
+ */
+static int ub960tp_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	dev_dbg(&client->dev, "open");
+	return 0;
+}
+
+
+static const struct v4l2_subdev_internal_ops ub960tp_subdev_internal_ops = {
+	.open = ub960tp_open,
+};
+
+
+static const struct media_entity_operations ub960tp_media_ops = {
+	.link_validate = v4l2_subdev_link_validate,
+};
+
+
+static int ub960tp_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct ub960tp *self =
+		container_of(ctrl->handler, struct ub960tp, ctrl_handler);
+
+	switch (ctrl->id) {
+	default:
+		dev_err(self->dev, "%s: unknown ctrl id", __func__);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+
+/**
+ * Puts the sensor in (or takes out of) register group hold. This
+ * means that you can make changes to the sensor through multiple
+ * registers and have all of the changes activate at the same time.
+ *
+ * @param self driver instance
+ * @param val boolean enable or disable
+ *
+ * @return 0 on success
+ */
+static int ub960tp_group_hold_enable(struct ub960tp *self, s32 val)
+{
+	return 0;
+}
+
+
+/**
+ * Takes fixed point (Q42.22) gain value in decibels and programs the
+ * image sensor.
+ *
+ * @param self driver instance
+ * @param val gain, in decibels, in Q42.22 fixed point format
+ *
+ * @return 0 on success
+ */
+static int ub960tp_gain_set(struct ub960tp *self, s64 val)
+{
+	return 0;
+}
+
+
+/**
+ * This currently doesn't do anything
+ *
+ * @param self driver instance
+ * @param val desired frame rate
+ *
+ * @return 0 on success
+ */
+static int ub960tp_framerate_set(struct ub960tp *self, s64 val)
+{
+	return 0;
+}
+
+
+/**
+ * Sets the exposure time using a fixed point time setting in Q42.22
+ * format.
+ *
+ * @param self driver instance
+ * @param val exposure time in seconds (see description)
+ *
+ * @return 0 on success
+ */
+static int ub960tp_exposure_set(struct ub960tp *self, s64 val)
+{
+	return 0;
+}
+
+
+/**
+ * Enables or disables HDR mode.
+ *
+ * @param self driver instance
+ * @param val enable or disable
+ *
+ * @return 0 on success
+ */
+static int ub960tp_hdr_enable(struct ub960tp *self, s32 val)
+{
+	return 0;
+}
+
+
+/**
+ * v4l2 control handler
+ *
+ * @param ctrl the v4l2 control
+ *
+ * @return 0 on success
+ */
+static int ub960tp_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct ub960tp *self =
+		container_of(ctrl->handler, struct ub960tp, ctrl_handler);
+	int err = 0;
+
+	switch (ctrl->id) {
+	case TEGRA_CAMERA_CID_GAIN:
+		TRY(err, ub960tp_gain_set(self, *ctrl->p_new.p_s64));
+		break;
+	case TEGRA_CAMERA_CID_FRAME_RATE:
+		TRY(err, ub960tp_framerate_set(self, *ctrl->p_new.p_s64));
+		break;
+	case TEGRA_CAMERA_CID_EXPOSURE:
+		TRY(err, ub960tp_exposure_set(self, *ctrl->p_new.p_s64));
+		break;
+	case TEGRA_CAMERA_CID_GROUP_HOLD:
+		TRY(err, ub960tp_group_hold_enable(self, ctrl->val));
+		break;
+	case TEGRA_CAMERA_CID_HDR_EN:
+		TRY(err, ub960tp_hdr_enable(self, ctrl->val));
+		break;
+	default:
+		dev_err(self->dev, "unknown ctrl id=%d", ctrl->id);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+
+/**
+ * Helper function that allocated device managed memory.
+ *
+ * @param dev device driver
+ * @param len desired amount of memory
+ * @param out where to store pointer
+ *
+ * @return 0 on success
+ */
+static int ub960tp_kzalloc(struct device *dev, size_t len, void *out)
+{
+	void **real_out = out;
+	if (!(*real_out = devm_kzalloc(dev, len, GFP_KERNEL))) {
+		dev_err(dev, "memory allocation failure");
+		return -ENOMEM;
+	}
+	return 0;
+}
+
+
+
+
+/**
+ * Pull parameters from device tree.
+ *
+ * @param s_data camera common data (for Nvidia layers)
+ *
+ * @return 0 on success
+ */
+static struct camera_common_pdata *ub960tp_parse_dt(
+	struct ub960tp *self,
+	struct camera_common_data *s_data)
+{
+	struct device_node *node = self->client->dev.of_node;
+	struct camera_common_pdata *board_priv_pdata;
+	const struct of_device_id *match;
+	int err;
+
+	if (!node) {
+		dev_err(self->dev, "no OF node");
+		return NULL;
+	}
+
+	match = of_match_device(ub960tp_of_match, self->dev);
+	if (!match) {
+		dev_err(self->dev, "Failed to find matching dt id");
+		return NULL;
+	}
+
+	board_priv_pdata = devm_kzalloc(self->dev,
+					sizeof(*board_priv_pdata), GFP_KERNEL);
+
+	err = of_property_read_string(node, "mclk",
+				      &board_priv_pdata->mclk_name);
+	if (err) {
+		/* This is not fatal */
+		dev_warn(self->dev, "mclk not in DT");
+	}
+
+	return board_priv_pdata;
+}
+
+
+/**
+ * Initializes media controller
+ *
+ * @param self driver instance
+ *
+ * @return 0 on success
+ */
+static int ub960tp_media_init(struct ub960tp *self)
+{
+	int err = 0;
+#if defined(CONFIG_MEDIA_CONTROLLER)
+	self->pad.flags = MEDIA_PAD_FL_SOURCE;
+	self->subdev->entity.ops = &ub960tp_media_ops;
+	/* The media controller code is slightly different on Tx2
+	 * (kernel 4.4) vs. on Xavier (kernel 4.9) */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 9, 0)
+	self->subdev->entity.type = MEDIA_ENT_T_V4L2_SUBDEV_SENSOR;
+	err = media_entity_init(&self->subdev->entity, 1, &self->pad, 0);
+#else
+	err = tegra_media_entity_init(&self->subdev->entity, 1,
+				      &self->pad, true, true);
+#endif	/* LINUX_VERSION */
+	if (err < 0) {
+		dev_err(self->dev, "unable to init media entity");
+		return err;
+	}
+#endif	/* CONFIG_MEDIA_CONTROLLER */
+	return 0;
+}
+
+
+/**
+ * This is called by the kernel when a new instance of the driver is
+ * instantiated.
+ *
+ * @param client i2c client device
+ * @param id
+ *
+ * @return 0 on success
+ */
+static int ub960tp_probe(struct i2c_client *client,
+			 const struct i2c_device_id *id)
+{
+	int err = 0;
+	struct camera_common_data *common_data;
+	struct device_node *node = client->dev.of_node;
+	struct ub960tp *self = NULL;
+
+	dev_dbg(&client->dev, "ub960tp probe ");
+
+	if (!IS_ENABLED(CONFIG_OF) || !node)
+		return -EINVAL;
+
+	TRY(err, ub960tp_kzalloc(&client->dev,
+				 sizeof(*common_data),
+				 &common_data));
+
+	TRY(err, ub960tp_kzalloc(&client->dev,
+				 sizeof(*self) + sizeof(struct v4l2_ctrl *) *
+				 ARRAY_SIZE(ctrl_config_list),
+				 &self));
+	self->client = client;
+	self->dev = &client->dev;
+
+	common_data->priv = self;
+	common_data->ops = &ub960tp_common_ops;
+	common_data->ctrl_handler = &self->ctrl_handler;
+	common_data->dev = &client->dev;
+	common_data->frmfmt = &ub960tp_formats[0];
+	common_data->colorfmt =
+		camera_common_find_datafmt(MEDIA_BUS_FMT_SRGGB12_1X12);
+
+	/* struct dentry				*debugdir; */
+	/* common_data->debugdir = ; */
+	common_data->power = &self->power;
+	/* struct v4l2_subdev			subdev; */
+	/* common_data->subdev = ; */
+	common_data->ctrls = self->ctrls;
+	/* struct sensor_properties		sensor_props; */
+	/* common_data->sensor_props = ; */
+
+	common_data->priv = self;
+	common_data->numctrls = ARRAY_SIZE(ctrl_config_list);
+	/* handled by camera_common_initialize */
+	/* common_data->csi_port = ; */
+	/* common_data->numlanes = ; */
+
+	/* handled in camera_common_try_fmt */
+	/* common_data->mode = ; */
+	/* common_data->mode_prop_idx; */
+
+	common_data->numfmts = ARRAY_SIZE(ub960tp_formats);
+	common_data->def_mode = 0;
+	common_data->def_width = common_data->frmfmt[0].size.width;
+	common_data->def_height = common_data->frmfmt[0].size.height;
+	common_data->def_clk_freq = 50000000;
+	common_data->fmt_width = common_data->def_width;
+	common_data->fmt_height = common_data->def_height;
+
+	self->s_data = common_data;
+	self->subdev = &common_data->subdev;
+	self->subdev->dev = self->dev;
+	self->s_data->dev = self->dev;
+
+	self->pdata = ub960tp_parse_dt(self, common_data);
+	if (!self->pdata)
+		return -EFAULT;
+
+	/* TRY(err, ub960tp_regmap_init(self->client, */
+	/* 			    &ub960tp_regmap_cfg, */
+	/* 			    &self->map)); */
+
+	TRY(err, camera_common_initialize(common_data, "ub960tp"));
+
+	v4l2_i2c_subdev_init(self->subdev, client, &ub960tp_subdev_ops);
+	TRY(err, ub960tp_ctrls_init(self));
+
+	self->subdev->internal_ops = &ub960tp_subdev_internal_ops;
+	self->subdev->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE |
+			       V4L2_SUBDEV_FL_HAS_EVENTS;
+
+	TRY(err, ub960tp_media_init(self));
+	TRY(err, v4l2_async_register_subdev(self->subdev));
+
+	/* If 390_mode control is removed you'll need to uncomment the
+	 * write_table call below to initialize the sensor. */
+	/* TRY(err, ub960tp_reg_write_table(self, */
+	/* 				mode_1936x1100SP1H, */
+	/* 				ARRAY_SIZE(mode_1936x1100SP1H), */
+	/* 				false)); */
+	dev_dbg(self->dev, "ub960tp probe success: addr=%#.2x", client->addr);
+	return 0;
+}
+
+/**
+ * Linux driver data
+ */
+static struct i2c_driver ub960tp_driver = {
+	.driver =
+	{
+		.name = "ub960tp",
+		.owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(ub960tp_of_match),
+	},
+	.probe = ub960tp_probe,
+	.remove = ub960tp_remove,
+	.id_table = ub960tp_id,
+};
+module_i2c_driver(ub960tp_driver);
+
+MODULE_DESCRIPTION("Test pattern camera driver for ub960 on Nvidia Jetson");
+MODULE_VERSION(D3_JETSON_BSP_VERSION);
+MODULE_AUTHOR("Greg Rowe <growe@d3engineering.com>");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/d3/vg6768/.gitignore b/drivers/d3/vg6768/.gitignore
new file mode 100644
index 000000000000..3d6c91708d6e
--- /dev/null
+++ b/drivers/d3/vg6768/.gitignore
@@ -0,0 +1,8 @@
+.built-in.o.cmd
+built-in.o
+modules.builtin
+modules.order
+.vg6768.o.cmd
+built-in.mod.c
+built-in.o
+
diff --git a/drivers/d3/vg6768/Kconfig b/drivers/d3/vg6768/Kconfig
new file mode 100644
index 000000000000..bffc78276da9
--- /dev/null
+++ b/drivers/d3/vg6768/Kconfig
@@ -0,0 +1,4 @@
+config D3_VG6768
+	bool "ST Micro vg6768 Camera Driver"
+	help
+	  ST Micro vg6768 Camera Driver for Nvidia Tegra systems including Jetson Tx2.
diff --git a/drivers/d3/vg6768/Makefile b/drivers/d3/vg6768/Makefile
new file mode 100644
index 000000000000..2abf2710c413
--- /dev/null
+++ b/drivers/d3/vg6768/Makefile
@@ -0,0 +1,2 @@
+# -*-makefile-*-
+obj-$(CONFIG_D3_VG6768)		+= vg6768.o
diff --git a/drivers/d3/vg6768/vg6768.c b/drivers/d3/vg6768/vg6768.c
new file mode 100644
index 000000000000..a27df6ecd567
--- /dev/null
+++ b/drivers/d3/vg6768/vg6768.c
@@ -0,0 +1,789 @@
+/*
+ * @author Mike Soltiz <msoltiz@d3engineering.com>
+ *
+ * vg6768.c - vg6768 sensor driver
+ *
+ * Copyright (c) 2018-2019, D3 Engineering.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+#include <linux/module.h>
+#include <linux/of_device.h>
+/* Nvidia camera utility code */
+#include <media/camera_common.h>
+
+#include <d3/d3-jetson-bsp.h>
+
+#include "vg6768_tables.h"
+
+
+/**
+ * If @p expr evalutes to non-zero assign it to @p err and return @p err
+ */
+#define TRY(err, expr) if(((err) = (expr))) { return (err); }
+
+/**
+ *  16 bit addresses and 8 bit values.
+ */
+static struct regmap_config vg6768_regmap_cfg =
+{
+	.reg_bits = 16,
+	.val_bits = 8,
+};
+
+struct vg6768 {
+	struct camera_common_power_rail	power;
+
+	struct i2c_client *i2c_client;
+	struct device *dev;
+	struct regmap *map;
+
+	struct camera_common_data *s_data;
+	struct camera_common_pdata *pdata;
+
+	struct media_pad pad;
+	struct v4l2_ctrl_handler ctrl_handler;
+	struct v4l2_subdev *subdev;
+	struct v4l2_ctrl *ctrls[];
+};
+
+static int vg6768_g_volatile_ctrl(struct v4l2_ctrl *ctrl);
+static int vg6768_s_ctrl(struct v4l2_ctrl *ctrl);
+static const struct v4l2_ctrl_ops vg6768_ctrl_ops = {
+	.g_volatile_ctrl = vg6768_g_volatile_ctrl,
+	.s_ctrl = vg6768_s_ctrl,
+};
+
+
+static struct v4l2_ctrl_config ctrl_config_list[] = {
+	{
+		.ops = &vg6768_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_GAIN,
+		.name = "Gain",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = 0 * FIXED_POINT_SCALING_FACTOR,
+		.max = 30 * FIXED_POINT_SCALING_FACTOR,
+		.def = 0 * FIXED_POINT_SCALING_FACTOR,
+		.step = 1,
+	},
+	{
+		.ops = &vg6768_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_EXPOSURE,
+		.name = "Exposure (us)",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		/* 30 us  */
+		.min = 30 * FIXED_POINT_SCALING_FACTOR / 1000000,
+		/* 33.3 ms */
+		.max = 33333 * FIXED_POINT_SCALING_FACTOR / 1000000,
+		/* 11 ms */
+		.def = 11000 * FIXED_POINT_SCALING_FACTOR / 1000000,
+		/* Microsecond steps */
+		.step = 1 * FIXED_POINT_SCALING_FACTOR / 1000000,
+	},
+	{
+		.ops = &vg6768_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_FRAME_RATE,
+		.name = "Frame Rate",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = 30,
+		.max = 30,
+		.def = 30,
+		.step = 1,
+	},
+	{
+		.ops = &vg6768_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_GROUP_HOLD,
+		.name = "Group Hold",
+		.type = V4L2_CTRL_TYPE_INTEGER_MENU,
+		.min = 0,
+		.max = ARRAY_SIZE(switch_ctrl_qmenu) - 1,
+		.menu_skip_mask = 0,
+		.def = 0,
+		.qmenu_int = switch_ctrl_qmenu,
+	},
+	{
+		.ops = &vg6768_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_HDR_EN,
+		.name = "HDR enable",
+		.type = V4L2_CTRL_TYPE_INTEGER_MENU,
+		.min = 0,
+		.max = ARRAY_SIZE(switch_ctrl_qmenu) - 1,
+		.menu_skip_mask = 0,
+		.def = 0,
+		.qmenu_int = switch_ctrl_qmenu,
+	},
+};
+
+/**
+ * Writes a single register value and prints debug information
+ *
+ * @param self
+ * @param addr address
+ * @param val value
+ *
+ * @return 0 on success
+ */
+static int vg6768_reg_write(struct vg6768 *self, u16 addr, u8 val)
+{
+	int err = 0;
+	dev_dbg(self->dev, "write: %#.4x=%#.2x", addr, val);
+	if((err = regmap_write(self->map, addr, val)))
+	{
+		dev_err(self->dev, "write error: %d", err);
+		return err;
+	}
+	return 0;
+}
+
+/**
+ * Reads a single register from the sensor and prints it.
+ *
+ * @param self
+ * @param addr which register
+ * @param out where to store result
+ *
+ * @return 0 on success
+ */
+static int vg6768_reg_read(struct vg6768 *self, u16 addr, u8 *out)
+{
+	int err = 0;
+	unsigned int val = 0;
+	if((err = regmap_read(self->map, addr, &val)))
+	{
+		dev_warn(self->dev, "regmap_read returned %d", err);
+		return err;
+	}
+	*out = val;
+	dev_dbg(self->dev, "read: %#.4x=%#.2x", addr, *out);
+	return 0;
+}
+
+
+/**
+ * This is part of Nvidia camera_common framework. They create a file
+ * in sysfs that you can use to read and write registers. That hooks
+ * into this.
+ *
+ * @param s_data
+ * @param addr address to read
+ * @param val where to store value
+ *
+ * @return 0 on success
+ */
+static int vg6768_read_reg(struct camera_common_data *s_data, u16 addr, u8 *val)
+{
+	int err = 0;
+	struct vg6768 *self = s_data->priv;
+
+	TRY(err, vg6768_reg_read(self, addr, val));
+	return 0;
+}
+
+
+/**
+ * This is part of Nvidia camera_common framework. They create a file
+ * in sysfs that you can use to read and write registers. That hooks
+ * into this.
+ *
+ * @param s_data
+ * @param addr address to write
+ * @param val what to write
+ *
+ * @return 0 on success
+ */
+static int vg6768_write_reg(struct camera_common_data *s_data, u16 addr, u8 val)
+{
+	int err = 0;
+	struct vg6768 *self = s_data->priv;
+
+	TRY(err, vg6768_reg_write(self, addr, val));
+	return 0;
+}
+
+/**
+ * Writes a sequence of registers.
+ *
+ * @param self driver instance
+ * @param vals what to write
+ * @param n_vals how many entries in @p vals
+ * @param do_dbg true to pint debug information
+ *
+ * @return 0 on success
+ */
+static int vg6768_reg_write_table(struct vg6768 *self,
+				  const struct reg_sequence *vals,
+				  size_t n_vals,
+				  bool do_dbg)
+{
+	int err = 0;
+	size_t i = 0;
+	if(do_dbg)
+	{
+		for(i = 0; i<n_vals; ++i)
+		{
+			dev_dbg(self->dev,
+				"write table: %#.2x=%#.2x (delay=%dus)",
+				vals[i].reg, vals[i].def, vals[i].delay_us);
+		}
+	}
+	if((err = regmap_multi_reg_write(self->map, vals, n_vals)) <0)
+	{
+		dev_err(self->dev, "error writing registers: %d", err);
+		return err;
+	}
+	return 0;
+}
+
+/**
+ * This is called to start the stream. Currently this doesn't really
+ * do anything other than log start/stop.
+ *
+ * @param sd sub device
+ * @param enable enable/disable stream
+ *
+ * @return
+ */
+static int vg6768_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	int err = 0;
+	u8 *reg_val = &(u8){0};
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_common_data *s_data = to_camera_common_data(&client->dev);
+	struct vg6768 *self = (struct vg6768 *)s_data->priv;
+
+	dev_dbg(&client->dev, "%s", enable ? "START" : "STOP");
+
+	if (!enable)
+	{
+		msleep(50);
+		TRY(err, vg6768_reg_write_table(self,
+						vg6768_stop,
+						ARRAY_SIZE(vg6768_stop),
+						false));
+		msleep(50);
+	}
+	else
+	{
+		msleep(50);
+		TRY(err, vg6768_reg_write_table(self,
+						vg6768_start,
+						ARRAY_SIZE(vg6768_start),
+						false));
+		msleep(50);
+	}
+
+	TRY(err, vg6768_reg_read(self, 0x004E, reg_val));
+	if (err==0)
+		dev_dbg(self->dev, "vg6768 X_OUTPUT_SIZE: %d", *reg_val);
+
+	TRY(err, vg6768_reg_read(self, 0x0050, reg_val));
+	if (err==0)
+		dev_dbg(self->dev, "vg6768 Y_OUTPUT_SIZE: %d", *reg_val);
+
+	TRY(err, vg6768_reg_read(self, 0x0058, reg_val));
+	if (err==0)
+		dev_dbg(self->dev, "vg6768 FRAME_LENGTH: %d", *reg_val);
+
+	TRY(err, vg6768_reg_read(self, 0x005A, reg_val));
+	if (err==0)
+		dev_dbg(self->dev, "vg6768 LINE_LENGTH: %d", *reg_val);
+
+	return 0;
+}
+
+static int vg6768_g_input_status(struct v4l2_subdev *sd, u32 *status)
+{
+	return 0;
+}
+
+
+static int vg6768_remove(struct i2c_client *client)
+{
+	struct camera_common_data *s_data = to_camera_common_data(&client->dev);
+	struct vg6768 *priv = (struct vg6768 *)s_data->priv;
+
+	v4l2_async_unregister_subdev(priv->subdev);
+#if defined(CONFIG_MEDIA_CONTROLLER)
+	media_entity_cleanup(&priv->subdev->entity);
+#endif
+
+	v4l2_ctrl_handler_free(&priv->ctrl_handler);
+	camera_common_cleanup(s_data);
+	return 0;
+}
+
+
+static const struct i2c_device_id vg6768_id[] = {
+	{"vg6768", 0},
+	{}
+};
+MODULE_DEVICE_TABLE(i2c, vg6768_id);
+
+static struct v4l2_subdev_video_ops vg6768_subdev_video_ops = {
+	.s_stream	= vg6768_s_stream,
+	.g_mbus_config	= camera_common_g_mbus_config,
+	.g_input_status	= vg6768_g_input_status,
+};
+
+
+static struct v4l2_subdev_core_ops vg6768_subdev_core_ops = {
+	.s_power	= camera_common_s_power,
+};
+
+/**
+ * v4l2 set and tryset format handler
+ *
+ * @param sd sub dev
+ * @param cfg
+ * @param format format to attempt to set or to set
+ *
+ * @return 0 on success
+ */
+static int vg6768_set_fmt(struct v4l2_subdev *sd,
+			  struct v4l2_subdev_pad_config *cfg,
+			  struct v4l2_subdev_format *format)
+{
+	int ret;
+	if (format->which == V4L2_SUBDEV_FORMAT_TRY)
+		ret = camera_common_try_fmt(sd, &format->format);
+	else
+		ret = camera_common_s_fmt(sd, &format->format);
+	return ret;
+}
+
+/**
+ * Returns the active format
+ *
+ * @param sd sub dev
+ * @param cfg
+ * @param format output - the active format
+ *
+ * @return
+ */
+static int vg6768_get_fmt(struct v4l2_subdev *sd,
+			  struct v4l2_subdev_pad_config *cfg,
+			  struct v4l2_subdev_format *format)
+{
+	return camera_common_g_fmt(sd, &format->format);
+}
+
+static struct v4l2_subdev_pad_ops vg6768_subdev_pad_ops = {
+	.set_fmt	     = vg6768_set_fmt,
+	.get_fmt	     = vg6768_get_fmt,
+	.enum_mbus_code	     = camera_common_enum_mbus_code,
+	.enum_frame_size     = camera_common_enum_framesizes,
+	.enum_frame_interval = camera_common_enum_frameintervals,
+};
+
+static struct v4l2_subdev_ops vg6768_subdev_ops = {
+	.core  = &vg6768_subdev_core_ops,
+	.video = &vg6768_subdev_video_ops,
+	.pad   = &vg6768_subdev_pad_ops,
+};
+
+
+static struct of_device_id vg6768_of_match[] = {
+	{ .compatible = "d3,vg6768", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, vg6768_of_match);
+
+/**
+ * These are for debugging. The Nvidia camera_common code creates a
+ * file in sysfs to read and write the image sensor.
+ */
+static struct camera_common_sensor_ops vg6768_common_ops = {
+	.write_reg = vg6768_write_reg,
+	.read_reg  = vg6768_read_reg,
+};
+
+static int vg6768_ctrls_init(struct vg6768 *priv)
+{
+	struct i2c_client *client = priv->i2c_client;
+	struct v4l2_ctrl *ctrl;
+	int numctrls;
+	int err;
+	int i;
+
+	dev_dbg(&client->dev, "%s++", __func__);
+
+	numctrls = ARRAY_SIZE(ctrl_config_list);
+	v4l2_ctrl_handler_init(&priv->ctrl_handler, numctrls);
+
+	for (i = 0; i < numctrls; i++) {
+		ctrl = v4l2_ctrl_new_custom(&priv->ctrl_handler,
+					    &ctrl_config_list[i], NULL);
+		if (ctrl == NULL) {
+			dev_err(&client->dev, "Failed to init %s ctrl",
+				ctrl_config_list[i].name);
+			continue;
+		}
+
+		if (ctrl_config_list[i].type == V4L2_CTRL_TYPE_STRING &&
+		    ctrl_config_list[i].flags & V4L2_CTRL_FLAG_READ_ONLY) {
+			ctrl->p_new.p_char = devm_kzalloc(&client->dev,
+							  ctrl_config_list[i].max + 1, GFP_KERNEL);
+			if (!ctrl->p_new.p_char)
+				return -ENOMEM;
+		}
+		priv->ctrls[i] = ctrl;
+	}
+
+	priv->subdev->ctrl_handler = &priv->ctrl_handler;
+	if (priv->ctrl_handler.error) {
+		dev_err(&client->dev, "Error %d adding controls",
+			priv->ctrl_handler.error);
+		err = priv->ctrl_handler.error;
+		goto error;
+	}
+
+	err = v4l2_ctrl_handler_setup(&priv->ctrl_handler);
+	if (err) {
+		dev_err(&client->dev,
+			"Error %d setting default controls", err);
+		goto error;
+	}
+
+	return 0;
+
+error:
+	v4l2_ctrl_handler_free(&priv->ctrl_handler);
+	return err;
+}
+
+static int vg6768_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	dev_dbg(&client->dev, "open");
+	return 0;
+}
+
+
+static const struct v4l2_subdev_internal_ops vg6768_subdev_internal_ops = {
+	.open = vg6768_open,
+};
+
+
+static const struct media_entity_operations vg6768_media_ops = {
+	.link_validate = v4l2_subdev_link_validate,
+};
+
+static int vg6768_g_volatile_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct vg6768 *self =
+		container_of(ctrl->handler, struct vg6768, ctrl_handler);
+
+	switch (ctrl->id)
+	{
+	default:
+		dev_err(self->dev, "%s: unknown ctrl id", __func__);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int vg6768_framerate_set(struct vg6768 *priv, s32 val)
+{
+	int err;
+
+	dev_dbg(&priv->i2c_client->dev,
+		"%s: frame_rate: %d\n", __func__, val);
+
+	err = vg6768_write_reg(priv->s_data, 0x04FC, (uint8_t)val);
+	err |= vg6768_write_reg(priv->s_data, 0x04FD, 0x00);
+	err |= vg6768_write_reg(priv->s_data, 0x04FE, 0x00);
+	err |= vg6768_write_reg(priv->s_data, 0x04FF, 0x00);
+	err |= vg6768_write_reg(priv->s_data, 0x0500, 0x39);
+	err |= vg6768_write_reg(priv->s_data, 0x0501, 0x00);
+	err |= vg6768_write_reg(priv->s_data, 0x0502, 0x00);
+	err |= vg6768_write_reg(priv->s_data, 0x0503, 0x00);
+	if (err)
+		goto fail;
+	return 0;
+
+fail:
+	dev_dbg(&priv->i2c_client->dev,
+		 "%s: FRAME_RATE control error\n", __func__);
+	return err;
+}
+
+static int vg6768_hdr_enable(struct vg6768 *priv, s32 val)
+{
+	int err;
+	int hdr_en = switch_ctrl_qmenu[val];
+
+	if (hdr_en == SWITCH_ON) {
+		err = vg6768_write_reg(priv->s_data, 0x04FC, 0x00);
+		err |= vg6768_write_reg(priv->s_data, 0x04FD, 0x00);
+		err |= vg6768_write_reg(priv->s_data, 0x04FE, 0x00);
+		err |= vg6768_write_reg(priv->s_data, 0x04FF, 0x00);
+		err |= vg6768_write_reg(priv->s_data, 0x0500, 0x42);
+		err |= vg6768_write_reg(priv->s_data, 0x0501, 0x00);
+		err |= vg6768_write_reg(priv->s_data, 0x0502, 0x00);
+		err |= vg6768_write_reg(priv->s_data, 0x0503, 0x00);
+		if (err)
+			goto fail;
+	} else if (hdr_en == SWITCH_OFF) {
+		err = vg6768_write_reg(priv->s_data, 0x04FC, 0x01);
+		err |= vg6768_write_reg(priv->s_data, 0x04FD, 0x00);
+		err |= vg6768_write_reg(priv->s_data, 0x04FE, 0x00);
+		err |= vg6768_write_reg(priv->s_data, 0x04FF, 0x00);
+		err |= vg6768_write_reg(priv->s_data, 0x0500, 0x42);
+		err |= vg6768_write_reg(priv->s_data, 0x0501, 0x00);
+		err |= vg6768_write_reg(priv->s_data, 0x0502, 0x00);
+		err |= vg6768_write_reg(priv->s_data, 0x0503, 0x00);
+		if (err)
+			goto fail;
+	}
+	return 0;
+fail:
+	dev_dbg(&priv->i2c_client->dev,
+		 "%s: HDR control error\n", __func__);
+	return err;
+}
+
+/**
+ * v4l2 control handler
+ *
+ * @param ctrl the v4l2 control
+ *
+ * @return 0 on success
+ */
+static int vg6768_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	struct vg6768 *priv =
+		container_of(ctrl->handler, struct vg6768, ctrl_handler);
+	int err = 0;
+
+	switch (ctrl->id) {
+	case TEGRA_CAMERA_CID_GAIN:
+		//err = vg6768_set_gain(priv, ctrl->val);
+		break;
+	case TEGRA_CAMERA_CID_EXPOSURE:
+		//err = vg6768_set_exposure(priv, ctrl->val);
+		break;
+	case TEGRA_CAMERA_CID_FRAME_RATE:
+		TRY(err, vg6768_framerate_set(priv, ctrl->val));
+		break;
+	case TEGRA_CAMERA_CID_GROUP_HOLD:
+		//err = vg6768_set_group_hold(priv, ctrl->val);
+		break;
+	case TEGRA_CAMERA_CID_HDR_EN:
+		TRY(err, vg6768_hdr_enable(priv, ctrl->val));
+		break;
+	default:
+		dev_err(priv->dev, "%s: unknown ctrl id.\n", __func__);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/**
+ * Helper function that allocated device managed memory.
+ *
+ * @param dev device driver
+ * @param len desired amount of memory
+ * @param out where to store pointer
+ *
+ * @return 0 on success
+ */
+static int vg6768_kzalloc(struct device *dev, size_t len, void *out)
+{
+	void **real_out = out;
+	if(!(*real_out = devm_kzalloc(dev, len, GFP_KERNEL)))
+	{
+		dev_err(dev, "memory allocation failure");
+		return -ENOMEM;
+	}
+	return 0;
+}
+
+/**
+ * Allocates a device managed register map.
+ *
+ * @param client which i2c client to use
+ * @param cfg register map configuration
+ * @param out_map where to store instance
+ *
+ * @return 0 on success
+ */
+static int vg6768_regmap_init(struct i2c_client *client,
+			      struct regmap_config *cfg,
+			      struct regmap **out_map)
+{
+	if(!(*out_map = devm_regmap_init_i2c(client, cfg)))
+	{
+		dev_err(&client->dev, "regmap_init failed");
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int vg6768_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	int err = 0;
+	struct camera_common_data *common_data;
+	struct device_node *node = client->dev.of_node;
+	struct vg6768 *self = NULL;
+
+	dev_dbg(&client->dev, "vg6768 probe enter: addr=%#.2x", client->addr);
+
+	if (!IS_ENABLED(CONFIG_OF) || !node)
+		return -EINVAL;
+
+	TRY(err, vg6768_kzalloc(&client->dev,
+				sizeof(*common_data),
+				&common_data));
+
+	TRY(err, vg6768_kzalloc(&client->dev,
+				sizeof(*self) + sizeof(struct v4l2_ctrl *) *
+				ARRAY_SIZE(ctrl_config_list),
+				&self));
+	self->dev = &client->dev;
+
+	common_data->priv = self;
+	common_data->ops = &vg6768_common_ops;
+	common_data->ctrl_handler = &self->ctrl_handler;
+	common_data->dev = &client->dev;
+	common_data->frmfmt = &vg6768_frmfmt[0];
+	common_data->colorfmt =
+		camera_common_find_datafmt(MEDIA_BUS_FMT_RGB888_1X24);
+
+	/* struct dentry				*debugdir; */
+	/* common_data->debugdir = ; */
+	common_data->power = &self->power;
+	/* struct v4l2_subdev			subdev; */
+	/* common_data->subdev = ; */
+	common_data->ctrls = self->ctrls;
+	/* struct sensor_properties		sensor_props; */
+	/* common_data->sensor_props = ; */
+
+	common_data->priv = (void *)self;
+	common_data->numctrls = ARRAY_SIZE(ctrl_config_list);
+	/* handled by camera_common_initialize */
+	/* common_data->csi_port = ; */
+	/* common_data->numlanes = ; */
+
+	/* handled in camera_common_try_fmt */
+	/* common_data->mode = ; */
+	/* common_data->mode_prop_idx; */
+
+	common_data->numfmts = ARRAY_SIZE(vg6768_frmfmt);
+	common_data->def_mode = VG6768_DEFAULT_MODE;
+	common_data->def_width =
+		common_data->frmfmt[VG6768_DEFAULT_MODE].size.width;
+	common_data->def_height =
+		common_data->frmfmt[VG6768_DEFAULT_MODE].size.height;
+	common_data->def_clk_freq = 50000000;
+	common_data->fmt_width = common_data->def_width;
+	common_data->fmt_height = common_data->def_height;
+
+	self->i2c_client = client;
+	self->s_data = common_data;
+	self->subdev = &common_data->subdev;
+	self->subdev->dev = &client->dev;
+	self->s_data->dev = &client->dev;
+
+	TRY(err, vg6768_regmap_init(client,
+				    &vg6768_regmap_cfg,
+				    &self->map));
+	TRY(err, camera_common_initialize(common_data, "vg6768"));
+
+	v4l2_i2c_subdev_init(self->subdev, client, &vg6768_subdev_ops);
+	TRY(err, vg6768_ctrls_init(self));
+
+	self->subdev->internal_ops = &vg6768_subdev_internal_ops;
+	self->subdev->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE |
+		V4L2_SUBDEV_FL_HAS_EVENTS;
+
+#if defined(CONFIG_MEDIA_CONTROLLER)
+	dev_dbg(&client->dev, "init media entity");
+	self->pad.flags = MEDIA_PAD_FL_SOURCE;
+	self->subdev->entity.ops = &vg6768_media_ops;
+	/* The media controller code is slightly different on Tx2
+	 * (kernel 4.4) vs. on Xavier (kernel 4.9) */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 9, 0)
+	self->subdev->entity.type = MEDIA_ENT_T_V4L2_SUBDEV_SENSOR;
+	err = media_entity_init(&self->subdev->entity, 1, &self->pad, 0);
+#else
+	err = tegra_media_entity_init(&self->subdev->entity, 1,
+				      &self->pad, true, true);
+#endif
+	if (err < 0)
+	{
+		dev_err(&client->dev, "unable to init media entity");
+		return err;
+	}
+#endif
+/* #if defined(CONFIG_MEDIA_CONTROLLER) */
+/* 	self->pad.flags = MEDIA_PAD_FL_SOURCE; */
+/* 	self->subdev->entity.type = MEDIA_ENT_T_V4L2_SUBDEV_SENSOR; */
+/* 	self->subdev->entity.ops = &vg6768_media_ops; */
+/* 	TRY(err, media_entity_init(&self->subdev->entity, 1, &self->pad, 0)); */
+/* #endif */
+	TRY(err, v4l2_async_register_subdev(self->subdev));
+
+	dev_dbg(self->dev, "vg6768 configuring imager: addr=%#.2x",
+		client->addr);
+	TRY(err, vg6768_reg_write_table(self,
+					mode_1920X1080_30fps,
+					ARRAY_SIZE(mode_1920X1080_30fps),
+					false));
+	dev_dbg(self->dev, "vg6768 configuring imager done");
+
+	msleep(20);
+	TRY(err, vg6768_reg_write_table(self,
+					vg6768_isp_start,
+					ARRAY_SIZE(vg6768_isp_start),
+					false));
+	msleep(100);
+	msleep(50);
+	TRY(err, vg6768_reg_write_table(self,
+					mode_1920X1080_30fps,
+					ARRAY_SIZE(mode_1920X1080_30fps),
+					false));
+	dev_dbg(self->dev, "vg6768 probe success: addr=%#.2x", client->addr);
+	return 0;
+};
+
+
+
+/**
+ * Linux driver data
+ */
+static struct i2c_driver vg6768_driver =
+{
+	.driver =
+	{
+		.name = "vg6768",
+		.owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(vg6768_of_match),
+	},
+	.probe = vg6768_probe,
+	.remove = vg6768_remove,
+	.id_table = vg6768_id,
+};
+
+module_i2c_driver(vg6768_driver);
+
+MODULE_DESCRIPTION("Driver for VG6768 camera on Nvidia Jetson");
+MODULE_VERSION(D3_JETSON_BSP_VERSION);
+MODULE_AUTHOR("Thirdy Buno <luis.buno@global-imi.com>");
+MODULE_AUTHOR("Mike Soltiz <msoltiz@d3engineering.com>");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/d3/vg6768/vg6768.h b/drivers/d3/vg6768/vg6768.h
new file mode 100644
index 000000000000..fe2e1a005fae
--- /dev/null
+++ b/drivers/d3/vg6768/vg6768.h
@@ -0,0 +1,85 @@
+/**
+ * Copyright (c) 2016-2017, NVIDIA Corporation.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __VG6768_H__
+#define __VG6768_H__
+
+#include <linux/ioctl.h>  /* For IOCTL macros */
+#include <media/nvc.h>
+#include <media/nvc_image.h>
+
+#define VG6768_IOCTL_SET_MODE			_IOW('o', 1, struct vg6768_mode)
+#define VG6768_IOCTL_GET_STATUS		_IOR('o', 2, __u8)
+#define VG6768_IOCTL_SET_FRAME_RATE		_IOW('o', 3, __u32)
+#define VG6768_IOCTL_SET_COARSE_TIME		_IOW('o', 4, __u32)
+#define VG6768_IOCTL_SET_GAIN			_IOW('o', 5, __u16)
+#define VG6768_IOCTL_GET_SENSORDATA		_IOR('o', 6, \
+	 struct vg6768_sensordata)
+#define VG6768_IOCTL_SET_GROUP_HOLD		_IOW('o', 7, struct vg6768_ae)
+#define VG6768_IOCTL_SET_HDR_COARSE_TIME	_IOW('o', 8, struct vg6768_hdr)
+#define VG6768_IOCTL_SET_POWER			_IOW('o', 20, __u32)
+
+struct vg6768_mode {
+	__u32 xres;
+	__u32 yres;
+	__u32 frame_length;
+	__u32 coarse_time;
+	__u32 coarse_time_short;
+	__u16 gain;
+	__u8 hdr_en;
+};
+
+struct vg6768_hdr {
+	__u32 coarse_time_long;
+	__u32 coarse_time_short;
+};
+
+struct vg6768_ae {
+	__u32 frame_length;
+	__u8  frame_length_enable;
+	__u32 coarse_time;
+	__u32 coarse_time_short;
+	__u8  coarse_time_enable;
+	__s32 gain;
+	__u8  gain_enable;
+};
+
+#ifdef __KERNEL__
+struct vg6768_power_rail {
+	struct regulator *dvdd;
+	struct regulator *avdd;
+	struct regulator *iovdd;
+	struct regulator *ext_reg1;
+	struct regulator *ext_reg2;
+	struct clk *mclk;
+	unsigned int pwdn_gpio;
+	unsigned int cam1_gpio;
+	unsigned int reset_gpio;
+	unsigned int af_gpio;
+};
+
+struct vg6768_platform_data {
+	const char *mclk_name; /* NULL for default default_mclk */
+	unsigned int cam1_gpio;
+	unsigned int reset_gpio;
+	unsigned int af_gpio;
+	bool ext_reg;
+	int (*power_on)(struct vg6768_power_rail *pw);
+	int (*power_off)(struct vg6768_power_rail *pw);
+};
+#endif /* __KERNEL__ */
+
+#endif  /* __VG6768_H__ */
diff --git a/drivers/d3/vg6768/vg6768_tables.h b/drivers/d3/vg6768/vg6768_tables.h
new file mode 100644
index 000000000000..2ee0a7e2f19e
--- /dev/null
+++ b/drivers/d3/vg6768/vg6768_tables.h
@@ -0,0 +1,184 @@
+/*
+ * @author Mike Soltiz <msoltiz@d3engineering.com>
+ *
+ * Copyright (c) 2018-2019, D3 Engineering.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+#ifndef __VG6768_TABLES__
+#define __VG6768_TABLES__
+
+#define VG6768_DEFAULT_MODE VG6768_MODE_1920X1080_30FPS
+
+enum {
+	VG6768_MODE_1920X1080_30FPS = 0,
+	VG6768_MODE_END
+};
+
+static const int vg6768_30fps[] = {
+	30,
+};
+
+
+static const struct camera_common_frmfmt vg6768_frmfmt[] = {
+	{
+		.size = {1920, 1080},
+		.framerates = vg6768_30fps,
+		.num_framerates = 1,
+		.hdr_en = 0,
+		.mode = VG6768_MODE_1920X1080_30FPS
+	},
+};
+
+static const struct reg_sequence vg6768_isp_start[] = {
+	{0x04FC, 0x00},
+	{0x04FD, 0x00},
+	{0x04FE, 0x00},
+	{0x04FF, 0x00},
+	{0x0500, 0x11},
+	{0x0501, 0x00},
+	{0x0502, 0x00},
+	{0x0503, 0x00},
+};
+
+static const struct reg_sequence mode_1920X1080_30fps[] = {
+/* Set CSI2 TX Interface sequence */
+	{0x04F4, 0x03}, //Lane mapping in application board
+	{0x04F5, 0x02}, //Lane mapping in application board
+	{0x04F6, 0x01},	//Lane mapping in application board
+	{0x04F7, 0x00},	//Lane mapping in application board
+	{0x04F8, 0x20},	//Data Bit Rate (800 Mbs)
+	{0x04F9, 0x03}, //Data Bit Rate
+	{0x04FA, 0x00}, //Data Bit Rate
+	{0x04FB, 0x00}, //Data Bit Rate
+	{0x04FC, 0x83}, //Lane Number + Virtual Channel (4 lanes, no Virtual Channels)
+	{0x04FD, 0x00},	//Lane Number + Virtual Channel
+	{0x04FE, 0x00},	//Lane Number + Virtual Channel
+	{0x04FF, 0x00},	//Lane Number + Virtual Channel
+	{0x0500, 0x34},	//Opcode = 0x34 Set CSI2 TX Interface
+	{0x0501, 0x00},
+	{0x0502, 0x00},
+	{0x0503, 0x00},
+	{0x0151, 0x01},//Disable ASIL lines
+	{0x0153, 0x01},//Disable ASIL lines
+
+/* Set Input Image Configuration sequence 0,0-1923,1083*/
+	{0x04F8, 0x83},	//Image bottom right index
+	{0x04F9, 0x07}, //Image bottom right index
+	{0x04FA, 0x3B}, //Image bottom right index
+	{0x04FB, 0x04}, //Image bottom right index
+	{0x04FC, 0x00}, //Image top left index
+	{0x04FD, 0x00},	//Image top left index
+	{0x04FE, 0x00},	//Image top left index
+	{0x04FF, 0x00},	//Image top left index
+	{0x0500, 0x33},	//Opcode = 0x33 Set Input Image Configuration
+	{0x0501, 0x00},
+	{0x0502, 0x00},
+	{0x0503, 0x00},
+
+/* Set Output Image Configuration sequence rgb888, 1920x1080*/
+	{0x04F8, 0x02},	//Format: 0x09-YUV422 10 bits, 0x02-RGB888, 0x08-YUV422 8 bits, 0x05-YUV420 8 bits
+	{0x04F9, 0x00},
+	{0x04FA, 0x00},
+	{0x04FB, 0x00},
+	{0x04FC, 0x80}, //Image Width
+	{0x04FD, 0x07},	//Image Width
+	{0x04FE, 0x38},	//Image Height
+	{0x04FF, 0x04},	//Image Heigth
+	{0x0500, 0x37},	//Opcode = 0x37 Set Output Image Configuration
+	{0x0501, 0x00},
+	{0x0502, 0x00},
+	{0x0503, 0x00},
+
+/* Set CSI RX Interface sequence */
+	{0x04F4, 0x04}, //Lane mapping in application board
+	{0x04F5, 0x03}, //Lane mapping in application board
+	{0x04F6, 0x02},	//Lane mapping in application board
+	{0x04F7, 0x01},	//Lane mapping in application board
+	{0x04F8, 0x18},	//Data Bit Rate
+	{0x04F9, 0x03}, //Data Bit Rate
+	{0x04FA, 0x00}, //Data Bit Rate
+	{0x04FB, 0x00}, //Data Bit Rate
+	{0x04FC, 0x03}, //Lane Number 4
+	{0x04FD, 0x00},
+	{0x04FE, 0x00},
+	{0x04FF, 0x00},
+	{0x0500, 0x31},	//Opcode = 0x31 Set CSI RX Interface
+	{0x0501, 0x00},
+	{0x0502, 0x00},
+	{0x0503, 0x00},
+
+/* Set Output Image Source sequence */
+	{0x04FC, 0x03}, //Source 0x03-ISP for display vision
+	{0x04FD, 0x00},
+	{0x04FE, 0x00},
+	{0x04FF, 0x00},
+	{0x0500, 0x36},	//Opcode = 0x36 Set Output Image Source
+	{0x0501, 0x00},
+	{0x0502, 0x00},
+	{0x0503, 0x00},
+
+/* Set Dynamic Range sequence */
+	{0x04FC, 0x01}, //Standard = 0x01, High = 0x00
+	{0x04FD, 0x00},
+	{0x04FE, 0x00},
+	{0x04FF, 0x00},
+	{0x0500, 0x42},	//Opcode = 0x42 Set Dynamic Range
+	{0x0501, 0x00},
+	{0x0502, 0x00},
+	{0x0503, 0x00},
+
+/* Set Frame Rate sequence */
+	{0x04FC, 0x1D}, //Frame Rate (29???)
+	{0x04FD, 0x00},
+	{0x04FE, 0x00},
+	{0x04FF, 0x00},
+	{0x0500, 0x39},	//Opcode = 0x39 Set Frame Rate
+	{0x0501, 0x00},
+	{0x0502, 0x00},
+	{0x0503, 0x00},
+
+/* Set Exposure Mode sequence */
+	{0x04FC, 0x00}, //0x00: Day 60Hz, 0x01: Night 60Hz, 0x02: Day 50Hz, 0x03: Night 50Hz, 0x04: No Motion Blur
+	{0x04FD, 0x00},
+	{0x04FE, 0x00},
+	{0x04FF, 0x00},
+	{0x0500, 0x53},	//Opcode = 0x53 Set Exposure Mode
+	{0x0501, 0x00},
+	{0x0502, 0x00},
+	{0x0503, 0x00},
+
+};
+
+static const struct reg_sequence vg6768_start[] = {
+	{0x04FC, 0x00},
+	{0x04FD, 0x00},
+	{0x04FE, 0x00},
+	{0x04FF, 0x00},
+	{0x0500, 0x11},
+	{0x0501, 0x00},
+	{0x0502, 0x00},
+	{0x0503, 0x00},
+};
+
+static const struct reg_sequence vg6768_stop[] = {
+	{0x04FC, 0x00},
+	{0x04FD, 0x00},
+	{0x04FE, 0x00},
+	{0x04FF, 0x00},
+	{0x0500, 0x12},
+	{0x0501, 0x00},
+	{0x0502, 0x00},
+	{0x0503, 0x00},
+};
+#endif  /* __VG6768_TABLES__ */
diff --git a/include/d3/config-eeprom.h b/include/d3/config-eeprom.h
new file mode 100644
index 000000000000..1efd91bef2b7
--- /dev/null
+++ b/include/d3/config-eeprom.h
@@ -0,0 +1,36 @@
+/*
+ * config-eeprom.h: Interface to the D3 configuration-eeprom-reading driver.
+ *
+ * This header file does not rely on, or reference, any EEPROM driver
+ * or EEPROM specifics.
+ *
+ * Copyright (c) 2019, D3 Engineering  All rights reserved.
+ * Author: Christopher White <cwhite@d3engineering.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ */
+
+#ifndef _D3_CONFIG_EEPROM_H
+#define _D3_CONFIG_EEPROM_H
+
+#include <linux/types.h>
+
+/// The size of the data.  TODO replace this with a more sophisticated approach.
+#define CONFIG_EEPROM_DATA_SIZE (128)
+
+/// The data read from the EEPROM.
+struct config_eeprom_data {
+	/// Parameters for drivers/d3/overlay-loader.
+	char overlay_loader_params[CONFIG_EEPROM_DATA_SIZE];
+} __attribute__ ((packed));
+
+extern struct config_eeprom_data *config_eeprom_get_data(void);
+
+#endif /* _D3_CONFIG_EEPROM_H */
diff --git a/include/d3/d3-jetson-bsp.h b/include/d3/d3-jetson-bsp.h
new file mode 100644
index 000000000000..393f202f073c
--- /dev/null
+++ b/include/d3/d3-jetson-bsp.h
@@ -0,0 +1,13 @@
+#ifndef _D3_JETSON_BSP_H_IN
+#define _D3_JETSON_BSP_H_IN
+
+/* This file is processed by autoconf. */
+
+#define D3_JETSON_BSP_VERSION_MAJOR 2
+#define D3_JETSON_BSP_VERSION_MINOR 0
+#define D3_JETSON_BSP_VERSION_PATCH 0
+#define D3_JETSON_BSP_BUILDID "98dbeefb-81a9-44d2-ab75-65d02c784d1e"
+#define D3_JETSON_BSP_VERSION "2.0.0"
+
+
+#endif
diff --git a/include/d3/of_private.h b/include/d3/of_private.h
new file mode 100644
index 000000000000..18bbb4517e25
--- /dev/null
+++ b/include/d3/of_private.h
@@ -0,0 +1,98 @@
+#ifndef _LINUX_OF_PRIVATE_H
+#define _LINUX_OF_PRIVATE_H
+/*
+ * Private symbols used by OF support code
+ *
+ * Paul Mackerras	August 1996.
+ * Copyright (C) 1996-2005 Paul Mackerras.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+/**
+ * struct alias_prop - Alias property in 'aliases' node
+ * @link:	List node to link the structure in aliases_lookup list
+ * @alias:	Alias property name
+ * @np:		Pointer to device_node that the alias stands for
+ * @id:		Index value from end of alias name
+ * @stem:	Alias string without the index
+ *
+ * The structure represents one alias property of 'aliases' node as
+ * an entry in aliases_lookup list.
+ */
+struct alias_prop {
+	struct list_head link;
+	const char *alias;
+	struct device_node *np;
+	int id;
+	char stem[0];
+};
+
+extern struct mutex of_mutex;
+extern struct list_head aliases_lookup;
+extern struct kset *of_kset;
+
+
+static inline struct device_node *kobj_to_device_node(struct kobject *kobj)
+{
+	return container_of(kobj, struct device_node, kobj);
+}
+
+#if defined(CONFIG_OF_DYNAMIC)
+extern int of_property_notify(int action, struct device_node *np,
+			      struct property *prop, struct property *old_prop);
+extern void of_node_release(struct kobject *kobj);
+extern int __of_changeset_apply(struct of_changeset *ocs);
+extern int __of_changeset_revert(struct of_changeset *ocs);
+#else /* CONFIG_OF_DYNAMIC */
+static inline int of_property_notify(int action, struct device_node *np,
+				     struct property *prop, struct property *old_prop)
+{
+	return 0;
+}
+#endif /* CONFIG_OF_DYNAMIC */
+
+/**
+ * General utilities for working with live trees.
+ *
+ * All functions with two leading underscores operate
+ * without taking node references, so you either have to
+ * own the devtree lock or work on detached trees only.
+ */
+struct property *__of_prop_dup(const struct property *prop, gfp_t allocflags);
+__printf(2, 3) struct device_node *__of_node_dup(const struct device_node *np, const char *fmt, ...);
+
+extern const void *__of_get_property(const struct device_node *np,
+				     const char *name, int *lenp);
+extern int __of_add_property(struct device_node *np, struct property *prop);
+extern int __of_add_property_sysfs(struct device_node *np,
+		struct property *prop);
+extern int __of_remove_property(struct device_node *np, struct property *prop);
+extern void __of_remove_property_sysfs(struct device_node *np,
+		struct property *prop);
+extern int __of_update_property(struct device_node *np,
+		struct property *newprop, struct property **oldprop);
+extern void __of_update_property_sysfs(struct device_node *np,
+		struct property *newprop, struct property *oldprop);
+
+extern void __of_attach_node(struct device_node *np);
+extern int __of_attach_node_sysfs(struct device_node *np);
+extern void __of_detach_node(struct device_node *np);
+extern void __of_detach_node_sysfs(struct device_node *np);
+
+extern void __of_sysfs_remove_bin_file(struct device_node *np,
+				       struct property *prop);
+
+/* iterators for transactions, used for overlays */
+/* forward iterator */
+#define for_each_transaction_entry(_oft, _te) \
+	list_for_each_entry(_te, &(_oft)->te_list, node)
+
+/* reverse iterator */
+#define for_each_transaction_entry_reverse(_oft, _te) \
+	list_for_each_entry_reverse(_te, &(_oft)->te_list, node)
+
+#endif /* _LINUX_OF_PRIVATE_H */
diff --git a/include/d3/ub960.h b/include/d3/ub960.h
new file mode 100644
index 000000000000..0cc0fe07c59e
--- /dev/null
+++ b/include/d3/ub960.h
@@ -0,0 +1,30 @@
+/**
+ * @author Greg Rowe <growe@d3engineering.com>
+ *
+ * Egregious kludge until a well though out approach to serdes can be
+ * implemented.
+ *
+ * Copyright (c) 2019, D3 Engineering.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+#ifndef _UB960_H
+#define _UB960_H
+
+#include <linux/i2c.h>
+
+int ub960_s_stream(struct i2c_client *self,
+		   struct i2c_client *src,
+		   int enable);
+
+#endif
-- 
2.17.1

